# This program is part of the Revised Mathematisch Centrum Algol 68 Test Set
  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.'

  These test sets are available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#numr13#
BEGIN #Test inverse trig functions#
      PROC warn = (STRING s) VOID:
           BEGIN print ((newline, s))
           END;
      
      REAL zero = 0;
      
      REAL sums1 := zero, sumsqs1 := zero, maxs1 := zero, ats1,
      INT cs1 := 0;
      
      REAL sums2 := zero, sumsqs2 := zero, maxs2 := zero, ats2,
      INT cs2 := 0;
      
      REAL sums3 := zero, sumsqs3 := zero, maxs3 := zero, ats3,
      INT cs3 := 0;
      
      REAL sumc1 := zero, sumsqc1 := zero, maxc1 := zero, atc1,
      INT cc1 := 0;
      
      REAL sumc2 := zero, sumsqc2 := zero, maxc2 := zero, atc2,
      INT cc2 := 0;
      
      REAL sumc3 := zero, sumsqc3 := zero, maxc3 := zero, atc3,
      INT cc3 := 0;
      
      REAL sumt1 := zero, sumsqt1 := zero, maxt1 := zero, att1,
      INT ct1 := 0;
      
      REAL sumt2 := zero, sumsqt2 := zero, maxt2 := zero, att2,
      INT ct2 := 0;
      
      REAL sumt3 := zero, sumsqt3 := zero, maxt3 := zero, att3,
      INT ct3 := 0;
      
      REAL sumsc := zero, sumsqsc := zero, maxsc := zero, atsc,
      INT csc := 0;
      
      REAL sumcs := zero, sumsqcs := zero, maxcs := zero, atcs,
      INT ccs := 0;
      
      REAL piby2 = pi / 2;
      
      PROC asin = (REAL x, PROC VOID l) REAL:
           IF # x positive, 0<=arcsin(x)<pi/2 #
              REAL y = arcsin (x);
              
              PROC e = (STRING s) VOID:
                   (print ((newline, newline, "arcsin(", x, " ) =", y));
                    warn (s);
                    l);
              
              y < zero
           THEN e ("arcsin yields result of wrong sign");
                SKIP
           ELIF y > piby2
           THEN e ("arcsin exceeds pi/2");
                #allow rounding up# SKIP
           ELSE IF # sin(arcsin(x))=x ? #
                   REAL z = sin (y);
                   
                   REAL d1 = ABS z + ABS x;
                   
                   d1 = zero
                THEN cs1 +:= 1
                ELIF REAL d2 = ABS ((ABS z - ABS x) / smallreal);
                     
                     REAL d = (d2 + d2) / d1;
                     
                     sums1 +:= d;
                     sumsqs1 +:= d * d;
                     cs1 +:= 1;
                     d > maxs1
                THEN maxs1 := d;
                     ats1 := x
                FI;
                IF # arcsin(-x)=-arcsin(x) ? #
                   REAL z = arcsin (-x);
                   
                   SIGN z /= -SIGN y
                THEN print ((newline, newline, "arcsin(", -x, " ) =", z));
                     warn ("arcsin yields result of wrong sign");
                     l
                ELIF REAL d1 = ABS y + ABS z;
                     
                     d1 = zero
                THEN cs2 +:= 1
                ELIF REAL d2 = ABS ((ABS y - ABS z) / smallreal);
                     
                     REAL d = (d2 + d2) / d1;
                     
                     sums2 +:= d;
                     sumsqs2 +:= d * d;
                     cs2 +:= 1;
                     d > maxs2
                THEN maxs2 := d;
                     ats2 := x
                FI;
                y
           FI;
      
      PROC acos = (REAL x, PROC VOID l) REAL:
           IF # x positive, 0<=arccos(x)<pi/2 #
              REAL y = arccos (x);
              
              PROC e = (STRING s) VOID:
                   (print ((newline, newline, "arccos(", x, " ) = ", y));
                    warn (s);
                    l);
              
              y < zero
           THEN e ("arccos yields result of wrong sign");
                SKIP
           ELIF y > piby2
           THEN e ("arccos exceeds pi/2");
                #allow rounding up# SKIP
           ELSE IF x >= smallreal
                #otherwise arccos(x)=pi/2 and cos(arccos(x))=0#
                THEN IF # cos(arccos(x))=x ? #
                        REAL z = cos (y);
                        
                        REAL d1 = ABS z + ABS x;
                        
                        d1 = zero
                     THEN cc1 +:= 1
                     ELSE REAL d2 = ABS ((ABS z - ABS x) / smallreal);
                          
                          REAL d = (d2 + d2) / d1;
                          
                          sumc1 +:= d;
                          sumsqc1 +:= d * d;
                          cc1 +:= 1;
                          (d > maxc1 | maxc1 := d; atc1 := x)
                     FI
                FI;
                IF # arccos(-x)=pi-arccos(x) ? #
                   REAL z = arccos (-x);
                   
                   z < piby2
                THEN print ((newline, newline, "arccos(", -x, " ) =", z));
                     warn ("result should exceed pi/2");
                     l
                ELIF z > pi
                THEN print ((newline, newline, "arccos(", -x, " ) =", z));
                     warn ("arccos should not exceed pi");
                     l
                ELIF REAL zz = pi - y;
                     
                     REAL d1 = ABS zz + ABS z;
                     
                     d1 = zero
                THEN cc2 +:= 1
                ELIF REAL d2 = ABS ((ABS zz - ABS z) / smallreal);
                     
                     REAL d = (d2 + d2) / d1;
                     
                     sumc2 +:= d;
                     sumsqc2 +:= d * d;
                     cc2 +:= 1;
                     d > maxc2
                THEN maxc2 := d;
                     atc2 := x
                FI;
                y
           FI;
      
      PROC atan = (REAL x, PROC VOID l) REAL:
           IF # x positive, 0<=arctan(x)<pi/2 #
              REAL y = arctan (x);
              
              PROC e = (STRING s) VOID:
                   (print ((newline, newline, "arctan(", x, " ) =", y));
                    warn (s);
                    l);
              
              y < zero
           THEN e ("arctan yields result of wrong sign");
                SKIP
           ELIF y > piby2
           THEN e ("arctan exceeds pi/2");
                #allow rounding up# SKIP
           ELIF # tan(arctan(x))=x ? #
                x < maxreal / 2
           THEN IF REAL z = tan (y);
                   
                   REAL d1 = ABS z + ABS x;
                   
                   d1 = zero
                THEN ct1 +:= 1
                ELIF REAL d2 = ABS ((ABS z - ABS x) / smallreal);
                     
                     REAL d = (d2 + d2) / d1;
                     
                     sumt1 +:= d;
                     sumsqt1 +:= d * d;
                     ct1 +:= 1;
                     d > maxt1
                THEN maxt1 := d;
                     att1 := x
                FI;
                IF # arctan(-x)=-arctan(x) ? #
                   REAL z = arctan (-x);
                   
                   SIGN z /= -SIGN y
                THEN print ((newline, newline, "arctan(", -x, " ) =", z));
                     warn ("arctan yields result of wrong sign");
                     l
                ELIF REAL d1 = ABS y + ABS z;
                     
                     d1 = zero
                THEN ct2 +:= 1
                ELIF REAL d2 = ABS ((ABS y - ABS z) / smallreal);
                     
                     REAL d = (d2 + d2) / d1;
                     
                     sumt2 +:= d;
                     sumsqt2 +:= d * d;
                     ct2 +:= 1;
                     d > maxt2
                THEN maxt2 := d;
                     att2 := x
                FI;
                y
           FI;
      
      PROC test = (REAL a, b, h) VOID:
           BEGIN REAL arcsin x = asin (a / h, VOID: GOTO l), arcsin y = asin (b / h, VOID: GOTO l), arccos x = acos (a / h, VOID: GOTO l), arccos y = acos (b / h, VOID: GOTO l), arctan x = atan (a / b, VOID: GOTO l), arctan y = atan (b / a, VOID: GOTO l);
                 
                 IF # arcsin(x)+arcsin(y)=pi/2 #
                    REAL z = arcsin x + arcsin y;
                    
                    REAL d = ABS (z - piby2) / (piby2 * smallreal);
                    
                    sums3 +:= d;
                    sumsqs3 +:= d * d;
                    cs3 +:= 1;
                    d > maxs3
                 THEN maxs3 := d;
                      ats3 := a / h
                 FI;
                 IF # arccos(x)+arccos(y)=pi/2 #
                    REAL z = arccos x + arccos y;
                    
                    REAL d = ABS (z - piby2) / (piby2 * smallreal);
                    
                    sumc3 +:= d;
                    sumsqc3 +:= d * d;
                    cc3 +:= 1;
                    d > maxc3
                 THEN maxc3 := d;
                      atc3 := b / h
                 FI;
                 IF # arctan(x)+arctan(y)=pi/2 #
                    REAL z = arctan x + arctan y;
                    
                    REAL d = ABS (z - piby2) / (piby2 * smallreal);
                    
                    sumt3 +:= d;
                    sumsqt3 +:= d * d;
                    ct3 +:= 1;
                    d > maxt3
                 THEN maxt3 := d;
                      att3 := a / b
                 FI;
                 IF #arcsin(x)=arccos(y)#
                    REAL z = arcsin x + arccos y;
                    
                    z = zero
                 THEN csc +:= 1
                 ELIF REAL zz = ABS (arcsin x - arccos y) / z;
                      
                      REAL d = (zz + zz) / smallreal;
                      
                      sumsc +:= d;
                      sumsqsc +:= d * d;
                      csc +:= 1;
                      d > maxsc
                 THEN maxsc := d;
                      atsc := a / h
                 FI;
                 IF #arccos(x)=arcsin(y)#
                    REAL z = arccos x + arcsin y;
                    
                    z = zero
                 THEN ccs +:= 1
                 ELIF REAL zz = ABS (arccos x - arcsin y) / z;
                      
                      REAL d = (zz + zz) / smallreal;
                      
                      sumcs +:= d;
                      sumsqcs +:= d * d;
                      ccs +:= 1;
                      d > maxcs
                 THEN maxcs := d;
                      atcs := b / h
                 FI;
                 l: SKIP
           END;
      
      PROC gcd = (INT a, b) INT:
           IF INT c = a MOD b;
              
              c = 0
           THEN b
           ELSE gcd (b, c)
           FI;
      
      INT c := 200;
      
      #number of triangles tested#
      FOR i FROM 2 TO maxint 
      WHILE c > 0
      DO FOR j FROM i - 1 BY -2 TO 1 
         WHILE #generate Pythagorean triangle#
               IF gcd (i, j) = 1 AND (ODD i /= ODD j)
               THEN REAL i2 = i * i, j2 = j * j, ij = i * j;
                    
                    REAL short = i2 - j2, long = ij + ij, hypot = i2 + j2;
                    
                    test (short, long, hypot);
                    c -:= 1
               ELSE c
               FI > 0
         DO SKIP
         OD
      OD;
      PROC p = (STRING s, REAL max, at, sum, sumsq, INT c) VOID:
           (print ((newline, newline, s, newline));
            print (("Maximum relative error = smallreal*", fixed (max, -(realwidth % 2 + 2), realwidth % 2), newline));
            (max /= zero | print (("Occurred at x = ", at, newline)));
            print (("Average relative error = smallreal*", fixed (sum / c, -(realwidth % 2 + 2), realwidth % 2), newline));
            print (("R.M.S. relative error = smallreal*", fixed (sumsq / c, -(realwidth % 2 + 2), realwidth % 2), newline));
            print (("Number of tests = ", whole (c, -5))));
      
      p ("Checks on sin(arcsin(x))=x :", maxs1, ats1, sums1, sumsqs1, cs1);
      p ("Checks on arcsin(-x)=-arcsin(x) :", maxs2, ats2, sums2, sumsqs2, cs2);
      p ("Checks on arcsin(x)+arcsin(y)=pi/2 :", maxs3, ats3, sums3, sumsqs3, cs3);
      p ("Checks on cos(arccos(x))=x :", maxc1, atc1, sumc1, sumsqc1, cc1);
      p ("Checks on arccos(-x)=pi-arccos(x) :", maxc2, atc2, sumc2, sumsqc2, cc2);
      p ("Checks on arccos(x)+arccos(y)=pi/2 :", maxc3, atc3, sumc3, sumsqc3, cc3);
      p ("Checks on tan(arctan(x))=x :", maxt1, att1, sumt1, sumsqt1, ct1);
      p ("Checks on arctan(-x)=-arctan(x) :", maxt2, att2, sumt2, sumsqt2, ct2);
      p ("Checks on arctan(x)+arctan(y)=pi/2 :", maxt3, att3, sumt3, sumsqt3, ct3);
      p ("Checks on arcsin(x)=arccos(y) :", maxsc, atsc, sumsc, sumsqsc, csc);
      p ("Checks on arccos(x)=arcsin(y) :", maxcs, atcs, sumcs, sumsqcs, ccs);
      #Special values#
      IF REAL a = asin (zero, VOID: GOTO l1);
         
         a /= zero
      THEN print ((newline, newline, "arcsin(0) =", a));
           warn ("arcsin(0) should be 0")
      FI;
      l1:
      IF REAL a = asin (1, VOID: GOTO l2);
         
         a /= piby2
      THEN print ((newline, newline, "arcsin(1) differs from pi/2 by smallreal*", fixed (ABS (piby2 - a) / smallreal, -(realwidth % 2 + 2), realwidth % 2)))
      FI;
      l2:
      IF REAL a = acos (1, VOID: GOTO l3);
         
         a /= zero
      THEN print ((newline, newline, "arccos(1) =", a));
           warn ("arccos(1) should be 0")
      FI;
      l3:
      IF REAL a = acos (zero, VOID: GOTO l4);
         
         a /= piby2
      THEN print ((newline, newline, "arccos(0) differs from pi/2 by smallreal*", fixed (ABS (piby2 - a) / smallreal, -(realwidth % 2 + 2), realwidth % 2)))
      FI;
      l4:
      IF REAL a = arccos (-1);
         
         a /= pi
      THEN print ((newline, newline, "arccos(-1) differs from pi by smallreal*", fixed (ABS (pi - a) / smallreal, -(realwidth % 2 + 2), realwidth % 2)))
      FI;
      l5:
      IF REAL a = atan (zero, VOID: GOTO l6);
         
         a /= zero
      THEN print ((newline, newline, "arctan(0) =", a));
           warn ("arctan(0) should be 0")
      FI;
      l6:
      print ((newline, newline, "smallreal =", smallreal, newline))
END