<html>
<head>
<title>Algol 68 Genie - An Algol 68 interpreter</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: Arial,Helvetica;}
u {font-size: 10pt; font-family: Arial,Helvetica;}
dd {font-size: 10pt; font-family: Arial,Helvetica;}
h1 {font-size: 16pt; font-family: Arial,Helvetica;}
h2 {font-size: 14pt; font-family: Arial,Helvetica;}
h3 {font-size: 12pt; font-family: Arial,Helvetica;}
h4 {font-size: 10pt; font-family: Arial,Helvetica;}
td {font-size: 8pt; font-family: Arial,Helvetica;}
ul {font-size: 10pt; font-family: Arial,Helvetica;}
body {font-size: 10pt; font-family: Arial,Helvetica;}
code {font-size: 10pt; font-family: Fixed,"Courier New",Courier;}
pre {font-size: 8pt; font-family: Fixed,"Courier New",Courier;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>Documentation for Algol 68 Genie Mark 9</small>
</td>
</table>

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>Example: Exact determinant of Hilbert matrix</h2>
</td>
<td width="30%" valign=top bgcolor="white">
<img src="logo.gif">
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<small><b>Algol68G Mark 9</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="introduction.html"><small>Introduction</small></a><br>
&nbsp;&middot;&nbsp;<a href="install.html"><small>Installation</small></a><br>
&nbsp;&middot;&nbsp;<a href="description.html"><small>Description</small></a><br>
&nbsp;&middot;&nbsp;<a href="synopsis.html"><small>Synopsis</small></a><br>
&nbsp;&middot;&nbsp;<a href="syntax.html"><small>Syntax</small></a><br>
&nbsp;&middot;&nbsp;<a href="environ.html"><small>Environment</small></a><br>
<br>
<small><b>Extensions</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="extensions.html"><small>UNIX</small></a><br>
&nbsp;&middot;&nbsp;<a href="postgresql.html"><small>PostgreSQL</small></a><br>
&nbsp;&middot;&nbsp;<a href="drawing.html"><small>Drawing</small></a><br>
&nbsp;&middot;&nbsp;<a href="numerical.html"><small>Numerical</small></a><br>
<br>
&nbsp;&middot;&nbsp;<a href="contents.html"><small>Contents</small></a><br>
&nbsp;&middot;&nbsp;<a href="examples.html"><small>Example&nbsp;programs</small></a><br>
&nbsp;&middot;&nbsp;<a href="resources.html"><small>A68 Resources</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#obtaining"><small>Downloads</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#contact"><small>Contact</small></a>
</td>
</tr>
</table>
<!-- End navigation bar -->
</td>
</table>

<font color=black>
<pre>
COMMENT
An application for multi-precision LONG LONG INT. 
Calculate exact determinant of Hilbert matrices using fractions.
COMMENT

BEGIN

# 
Fraction data structure and denotation through the "DIV" operator.
A fraction has positive denominator; the nominator holds the sign.
#

      MODE FRAC = STRUCT (NUM nom, den), NUM = LONG LONG INT;

      OP N = (FRAC u) NUM: nom OF u,
         D = (FRAC u) NUM: den OF u;

      PR precision=101 PR # NUM can hold a googol! #
 
      FRAC zero = 0 DIV 1, one = 1 DIV 1;

      OP DIV = (NUM n, d) FRAC: 
         IF d = 0
         THEN print ("Zero denominator"); stop 
         ELSE NUM gcd = ABS n GCD ABS d;
              (SIGN n * SIGN d * ABS n OVER gcd, ABS d OVER gcd)
         FI;

      OP DIV = (INT n, d) FRAC: NUM (n) DIV NUM (d);

      PRIO DIV = 2;

      OP GCD = (NUM a, b) NUM:
         IF b = 0 
         THEN ABS a
         ELSE b GCD (a MOD b)
         FI;

      PRIO GCD = 8;
  
# Basic operators for fractions. #
 
      OP - = (FRAC u) FRAC: - N u DIV D u;
  
      OP + = (FRAC u, v) FRAC: N u * D v + N v * D u DIV D u * D v;
  
      OP - = (FRAC u, v) FRAC: u + - v;

      OP * = (FRAC u, v) FRAC: N u * N v DIV D u * D v;

      OP / = (FRAC u, v) FRAC: u * (D v DIV N v);

      OP +:= = (REF FRAC u, FRAC v) REF FRAC: u := u + v;

      OP -:= = (REF FRAC u, FRAC v) REF FRAC: u := u - v;
  
      OP *:= = (REF FRAC u, FRAC v) REF FRAC: u := u * v;

      OP /:= = (REF FRAC u, FRAC v) REF FRAC: u := u / v;

      OP = = (FRAC u, v) BOOL: N u = N v ANDF D u = D v;
  
      OP /= = (FRAC u, v) BOOL: NOT (u = v);
  
# Matrix algebra. #

      OP INNER = ([] FRAC u, v) FRAC:
         # Innerproduct of two arrays of rationals #
         BEGIN FRAC s := zero;
               FOR i TO UPB u
               DO s +:= u[i] * v[i]
               OD;
               s
         END;

      PRIO INNER = 8;
  
      PROC lu decomposition = (REF [, ] FRAC a, REF [] INT p) VOID:
           # LU-decomposition cf. Crout, of a matrix of rationals. #
           BEGIN INT n = 1 UPB a;
                 FOR k TO n
                 DO FRAC piv := zero, INT k1 := k - 1;
                    REF INT pk = p[k];
                    REF [] FRAC aik = a[, k], aki = a[k,];
                    FOR i FROM k TO n
                    DO aik[i] -:= a[i, 1 : k1] INNER aik[1 : k1];
                       IF piv = zero ANDF aik[i] /= zero
                       THEN piv := aik[i]; 
                            pk := i
                       FI
                    OD;
                    IF piv = zero
                    THEN print((newline, "Singular matrix")); stop
                    FI;
                    IF pk /= k
                    THEN FOR i TO n
                         DO FRAC r = aki[i];
                            aki[i] := a[pk, i]; 
                            a[pk, i] := -r
                         OD
                    FI;
                    FOR i FROM k + 1 TO n
                    DO aki[i] -:= aki[1 : k1] INNER a[1 : k1, i] /:= piv
                    OD 
                 OD
           END;
  
      PROC determinant = ([,] FRAC a) FRAC:
           # Determinant of a decomposed matrix is its trace. #
           BEGIN FRAC d := one;
                 FOR i TO 1 UPB a
                 DO d *:= a[i, i]
                 OD;
                 d
           END;

# Table of required results. #  
  
      [] NUM table = BEGIN
         LONG LONG 1,
         LONG LONG 12,
         LONG LONG 2160,
         LONG LONG 6048000,
         LONG LONG 266716800000,
         LONG LONG 186313420339200000, 
         LONG LONG 2067909047925770649600000,
         LONG LONG 365356847125734485878112256000000, 
         LONG LONG 1028781784378569697887052962909388800000000, 
         LONG LONG 46206893947914691316295628839036278726983680000000000
      END;

# Compute determinant of Hilbert matrix of increasing rank. #
   
      FOR n TO UPB table
      DO [1 : n, 1 : n] FRAC a;
         FOR i TO n
         DO a[i, i] := 1 DIV 2 * i - 1;
            FOR j FROM i + 1 TO n
            DO a[i, j] := a[j, i] := 1 DIV i + j - 1
            OD
         OD;
         lu decomposition(a, LOC [1 : n] INT);
         FRAC det = determinant (a);
         print(("Rank ", whole (n, 0), 
                ", determinant ", whole (N det, 0), " / ", whole (D det, 0),
                (N det = 1 AND D det = table[n] | ", ok" | ", not ok" ), newline))
      OD
END
</pre>
</font>

<p>
<br>
<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<font color="black">
<small>Copyright &copy; 2001-2006 J. Marcel van der Veer.</small>
</font>
</td>
<td width="50%" align=right valign=top bgcolor="white">
<font color="black">
<small>Documentation for Algol 68 Genie Mark 9 (March 2006)</small>
</font>
</td>
</table>
</p>

</body>
</html>
