<!-- RRHeader -->
<html>
<head>
<title>Revised Report on the Algorithmic Language Algol 68 - Algol 68 Genie</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: arial, sans-serif;}
u {font-size: 10pt; font-family: arial, sans-serif;}
dd {font-size: 10pt; font-family: arial, sans-serif;}
h1 {font-size: 14pt; font-family: arial, sans-serif;}
h2 {font-size: 12pt; font-family: arial, sans-serif;}
h3 {font-size: 10pt; font-family: arial, sans-serif;}
h4 {font-size: 10pt; font-family: arial, sans-serif;}
td {font-size: 10pt; font-family: arial, sans-serif;}
ul {font-size: 10pt; font-family: arial, sans-serif;}
body {font-size: 10pt; font-family: arial, sans-serif;}
tt {font-size: 10pt; font-family: "courier new", monospace;}
code {font-size: 10pt; font-family: "courier new", monospace;}
var {font-size: 10pt; font-weight: normal; font-style: normal; font-family: "courier new", monospace; color: darkred;}
pre {font-size: 10pt; font-family: "courier new", monospace;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>
<b>Revised Report on the Algorithmic Language Algol 68</b>
</small>
</td>
</table>


<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>
Algol 68 Revised Report
</h2>
<h3>
PART II - Fundamental Constructions
</h3>
</td>
<td width="30%" bgcolor="white" valign=top align=center>
<img src="algol68.gif" align=center>
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<p>
<a href="algol.html"><small><b>A68G Home</b></small></a>
<p>
<a href="report_contents.html"><small><b>Revised Report</b></small></a>
<p>
<a href="algol.html#obtaining"><small><b>Downloads</b></small></a>
</td>
</tr>
</table>
<!-- End navigation bar -->
</td>
</table>

<p>
{This part presents the essential structure of <b>programs</b>:
<ul>
<li> the general rules for constructing them;
<li> the ways of defining <b>indicators</b> and their properties, at each new level of construction;
<li> the constructs available for programming primitive actions.}
</ul>

<h3>
<p>
<a name=3></a>3. Clauses
</h3>

{Clauses provide
<ul>
<li> a hierarchical structure for <b>programs</b>, 
<li> the introduction of new <b>ranges</b> of definitions, 
<li> serial or collateral composition, parallelism, choices and loops.}
</ul>

<h3>
<a name=301></a>3.0.1. Syntax
</h3>

<p>
<a name=301a></a>a) <b>*phrase : SOME unit</b> {<a href="report_2.html#321d">32d</a>}  <b>; NEST declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>.</b>
<br>
<a name=301b></a>b) <b>*SORT MODE expression : SORT MODE NEST UNIT</b> {<a href="report_2.html#51A">5A</a>}  <b>.</b>
<br>
<a name=301c></a>c) <b>*statement : strong void NEST UNIT</b> {<a href="report_2.html#51A">5A</a>}  <b>.</b>
<br>
<a name=301d></a>d) <b>*MOID constant : MOID NEST DEFIED identifier with TAG</b> {<a href="report_2.html#481a">48a, b</a>}  <b>; MOID NEST denoter</b> {<a href="report_4.html#801a">80a</a>}  <b>.</b>
<br>
<a name=301e></a>e) <b>*MODE variable : reference to MODE NEST DEFIED identifier with TAG</b> {<a href="report_2.html#431a">43a, b</a>}  <b>.</b>
<br>
<a name=301f></a>f) <b>*NEST range : SOID NEST serial clause defining LAYER</b> {<a href="report_2.html#321a">32a</a>}  <b>; SOID NEST chooser CHOICE STYLE clause</b> {<a href="report_2.html#341b">34b</a>}  <b>; SOID NEST case part of choice using UNITED</b> {<a href="report_2.html#341i">34i</a>}  <b>; NEST STYLE repeating part with DEC</b> {<a href="report_2.html#351e">35e</a>}  <b>; NEST STYLE while do part</b> {<a href="report_2.html#351f">35f</a>}  <b>; PROCEDURE NEST routine text</b> {<a href="report_2.html#5411a">541a, b</a>} <b>.</b>

<p>
{<b>NEST-ranges</b> arise in the definition of "identification" {<a href="report_3.html#722b">7.2.2.b</a>}.}

<h3>
<a name=302></a>3.0.2. Semantics
</h3>

<p>
A "nest" is a <b>'NEST'</b>. The nest  "of" a construct is the <b>'NEST'</b> enveloped by the original of that construct, but not by any <b>'defining LAYER'</b> contained in that original.

<p>
{The nest of a construct carries a record of all the <b>declarations</b>  forming the environment in which that construct is to be interpreted.
<br>
Those constructs which are contained in a <b>range</b> <i>R</i>, but not in any smaller <b>range</b> contained within <i>R</i>, may be said to comprise a  "reach". All constructs in a given reach have the same nest, which is that of the immediately surrounding reach with the addition of one extra <b>'LAYER'</b>. The syntax ensures {<a href="report_2.html#321b">3.2.1.b</a>  , <a href="report_2.html#341i">3.4.1.i, j, k</a> , <a href="report_2.html#351e">3.5.1.e</a>,  <a href="report_2.html#5411b">5.4.1.1.b</a>}  that each <b>'PROP'</b> {<a href="report_2.html#481E">4.8.1.E</a>} or "property" in the extra <b>'LAYER'</b> is matched by a <b>defining-indicator</b> {<a href="report_2.html#481a">4.8.1.a</a>} contained in a <b>definition</b> in that reach.}

<h3>
<a name=31></a>3.1. Closed clauses
</h3>


<p>
{<b>Closed-clauses</b> are usually used to construct <b>units</b> from <b>serial-clauses</b> as, e.g., 
<pre>
(REAL x; read (x); x) in
(REAL x; read (x); x) + 3.14.
</pre>
}

<h3>
<a name=311></a>3.1.1. Syntax
</h3>

<p>
<a name=311A></a>A) <b>SOID :: SORT MOID.</b>
<br>
<a name=311B></a>B) <b>PACK :: STYLE pack.</b>
<br>
<a name=311a></a>a) <b>SOID NEST closed clause</b> {<a href="report_1.html#221a">22a</a> , <a href="report_2.html#51D">5D</a>, <a href="report_2.html#5511a">551a</a>, <a href="report_5.html#A3411h">A341h</a>, <a href="report_5.html#A3491a">A349a</a>}  <b>: SOID NEST serial clause defining LAYER</b> {<a href="report_2.html#321a">32a</a>}  <b>PACK.</b> {<b>LAYER :: new DECSETY LABSETY.</b>}

<p>
<pre>
{Example
a) BEGIN x := 1; y := 2 END }
</pre>
{The yield of a <b>closed-clause</b> is that of its constituent <b>serial-clause</b>, by way of pre-elaboration {<a href="report_1.html#2141c">2.1.4.1.c</a>}.}

<h3>
<a name=32></a>3.2. Serial clauses
</h3>

<p>
{The purposes of <b>serial-clauses</b>  are
<ul>
<li> the construction of new <b>ranges</b> of definitions, and
<li> the serial composition of actions.
</ul>

<p>
A <b>serial-clause</b> consists of a possibly empty sequence of unlabelled <b>phrases</b>, the last of which, if any, is a <b>declaration</b>, followed by a sequence of possibly labelled <b>units</b>. The <b>phrases</b> and the <b>units</b> are separated by <b>go-on-tokens</b>, viz., semicolons. Some of the <b>units</b> may instead be separated by <b>completers</b>, viz.,  <tt>EXIT</tt>s; after a <b>completer</b>, the next <b>unit</b> must be labelled so that it can be reached. The value of the final <b>unit</b>, or of a <b>unit</b> preceding an <tt>EXIT</tt>, determines the value of the <b>serial-clause</b>.

<p>
For example, the following <b>serial-clause</b> yields <tt>true</tt> if and only if the vector <tt>a</tt> contains the integer 8:

<pre>
INT n; read (n);
[1 : n] INT a; read (a);
FOR i TO n DO IF a [i] = 8 THEN GOTO success FI OD;
FALSE EXIT
success: TRUE. }
</pre>

<h3>
<a name=321></a>3.2.1. Syntax
</h3>

<p>
<a name=321a></a>a) <b>SOID NEST serial clause defining new PROPSETY</b> {<a href="report_2.html#311a">31a</a> , <a href="report_2.html#341f">34f, l</a>, <a href="report_2.html#351h">35h</a>}  <b>: SOID NEST new PROPSETY series with PROPSETY</b> {b}<b>.</b> 
{Here<b> PROPSETY  :: DECSETY LABSETY.</b>}

<p>
<a name=321b></a>b) <b>SOID NEST series with PROPSETY</b> {a, b, <a href="report_2.html#341c">34c</a>}  <b>: strong void NEST unit</b> {d}<b>, go on</b> {<a href="report_4.html#941f">94f</a>}  <b>token, SOID NEST series with PROPSETY</b> {b}<b>; where (PROPSETY) is (DECS DECSETY LABSETY), NEST declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>, go on</b> {<a href="report_4.html#941f">94f</a>}  <b>token, SOID NEST series with DECSETY LABSETY</b> {b}<b>; where (PROPSETY) is (LAB LABSETY), NEST label definition of LAB</b> {c}<b>, SOID NEST series with LABSETY</b> {b}<b>; where (PROPSETY) is (LAB LABSETY) and SOID balances SOID1 and SOID2</b> {e}<b>, SOID1 NEST unit</b> {d}<b>, completion</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST label definition of LAB</b> {c}<b>, SOID2 NEST series with LABSETY</b> {b}<b>; where (PROPSETY) is (EMPTY), SOID NEST unit</b> {d}<b>.</b>
<br>
<a name=321c></a>c) <b>NEST label definition of label TAG</b> {b}<b> : label NEST defining identifier with TAG</b> {<a href="report_2.html#481a">48a</a>}  <b>, label</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>
<br>
<a name=321d></a>d) <b>SOME unit</b> {b, <a href="report_2.html#331b">33b, g</a>  , <a href="report_2.html#341i">34i</a>, <a href="report_2.html#351d">35d</a>, <a href="report_2.html#461m">46m, n</a>, <a href="report_2.html#5211c">521c</a>, <a href="report_2.html#5321e">532e</a>, <a href="report_2.html#5411a">541a, b</a>, <a href="report_2.html#5431c">543c</a>, <a href="report_5.html#A34A1b">A34Ab, c, d</a>}  <b>: SOME UNIT</b> {<a href="report_2.html#51A">5A</a>  , -}<b>.</b>
<br>
<a name=321e></a>e) <b>WHETHER SORT MOID balances SORT1 MOID1 and SORT2 MOID2</b> {b, <a href="report_2.html#331b">33b</a> , <a href="report_2.html#341d">34d, h</a>}  <b>: WHETHER SORT balances SORT1 and SORT2</b> {f}<b> and MOID balances MOID1 and MOID2</b> {g}<b>.</b>
<br>
<a name=321f></a>f) <b>WHETHER SORT balances SORT1 and SORT2</b> {e, <a href="report_2.html#5221a">522a</a>}  <b>: where (SORT1) is (strong), WHETHER (SORT2) is (SORT) ; where (SORT2) is (strong), WHETHER (SORT1) is (SORT).</b>
<br>
<a name=321g></a>g) <b>WHETHER MOID balances MOID1 and MOID2</b> {e}<b> :  where (MOID1) is (MOID2), WHETHER (MOID) is (MOID1) ; where (MOID1) is (transient MOID2), WHETHER (MOID) is (MOID1) ; where (MOID2) is (transient MOID1), WHETHER (MOID) is (MOID2).</b>
<br>
<a name=321h></a>h) <b>*SOID unitary clause : SOID NEST unit</b> {d}<b>.</b>
<br>
<a name=321i></a>i) <b>*establishing clause : SOID NEST serial clause defining LAYER</b> {<a href="report_2.html#321a">32a</a>}  <b>; MODE NEST enquiry clause defining LAYER</b> {<a href="report_2.html#341c">34c</a>}  <b>.</b>

<P>
<pre>
{Examples:
b) read (x1); REAL s:=0;
     sum: FOR i TO n DO (x1[i] &gt; 0 | s +:= x1[i] | nonpos) OD EXIT
     nonpos: print (s) &bull;
   REAL s := 0;
     sum: FOR i TO n DO (x1[i] &gt; 0 | s +:= x1[i] | nonpos) OD EXIT
     nonpos: print (s) &bull;
   sum: FOR i TO n DO (x1[i] &gt; 0 | s +:= x1[i] | nonpos) OD EXIT
     nonpos: print (s) &bull;
   FOR i TO n DO (x1[i] &gt; 0 | s +:= x1[i] | nonpos) OD EXIT
     nonpos: print (s) &bull;

   print (s)
c) sum:
d) print (s) }
</pre>

<p>
{Often, a <b>series</b> must be "balanced" {<a href="report_2.html#321e">3.2.1.e</a>}. For remarks concerning balancing, see <a href="report_2.html#341">3.4.1</a> .}

<h3>
<a name=322></a>3.2.2. Semantics
</h3>

<p>
<a name=322a></a>a) The yield of a <b>serial-clause</b>, in an environ <i>E</i>, is the yield of the elaboration of its <b>series</b>, or of any <b>series</b> elaborated "in its place" {<a href="report_2.html#5442">5.4.4.2</a>}, in the environ "established" {b} around <i>E</i> according to that <b>serial-clause</b>; it is required that the yield be not newer in scope than <i>E</i>.

<p>
<a name=322b></a>b) The environ <i>E</i> "established"
<ul>
<li>upon an environ, <i>E1</i>, possibly not specified, {which determines its scope, }
<li>around an environ <i>E2</i> {which determines its composition}, 
<li>according to a <b>NOTION-defining-new-PROPSETY</b> <i>C</i>, possibly absent, {which prescribes its locale, }
<li>with values V<sub>1</sub>, ... , V<sub>n</sub>, possibly absent, {which are possibly to be ascribed, } </li>
</ul>
is determined as follows:
<br>
&bull;  if <i>E1</i> is not specified, then let <i>E1</i> be <i>E2</i>;
<br>
&bull;  <i>E</i> is newer in scope than <i>E1</i> and is composed of <i>E2</i> and a new locale corresponding to <b>'PROPSETY'</b>, if <i>C</i> is present, and to <b>'EMPTY'</b> otherwise;
<DL compact>
<dd>
<a name=322cA></a>
Case A: <i>C</i> is an <b>establishing-clause</b>:
<DL compact>
<dd>
For each constituent <b>mode-definition</b> <i>M</i>, if any, of <i>C</i>, 
<ul>
<li>the scene composed of <ol type=1>
<li>the <b>actual-declarer</b> of <i>M</i>, and
<li>the environ necessary for {<a href="report_3.html#722c">7.2.2.c</a>} that <b>actual-declarer</b> in <i>E</i>, </li></ol>is ascribed in <i>E</i> to the <b>mode-indication</b> of <i>M</i>;</li>
</ul>
<dd>
For each constituent <b>label-definition</b> <i>L</i>, if any, of <i>C</i>, 
<ul>
<li>the scene composed of <ol type=1>
<li>the <b>series</b> of which <i>L</i> is a direct descendent, and
<li>the environ <i>E</i>, </li></ol>is ascribed in <i>E</i> to the <b>label-identifier</b> of <i>L</i>:</li>
</ul>
<dd>
If each <b>'PROP'</b> enveloped by <b>'PROPSETY'</b> is some <b>'DYADIC TAD'</b> or <b>'label TAG'</b>, 
<dd>
then <i>E</i> is said to be "nonlocal" {see <a href="report_2.html#5232b">5.2.3.2.b</a>} ;
</dl>
</dd>
<dd>
<a name=322cB></a>
Case B: <i>C</i> is a <b>declarative</b>, a <b>for-part</b> or a <b>specification</b>:
<DL compact>
<dd>
For i = 1 ... n, where <i>n</i> is the number of <b>'DEC'</b>s enveloped by <b>'PROPSETY'</b>, 
<br>
&bull;  V<sub>i</sub> is ascribed {<a href="report_2.html#482a">4.8.2.a</a>} in <i>E</i> to the <i>i</i>-th constituent <b>defining-identifier</b>, if any, of <i>C</i> and, otherwise {in the case of an invisible <b>for-part</b>} , to an <b>integral-defining-indicator-with-letter-aleph</b>;
<dd>
If <i>C</i> is a <b>for-part</b> or a <b>specification</b>, 
<br>
then <i>E</i> is nonlocal.
</dd>
</dl>
{Other cases, i.e., when <i>C</i> is absent:
<br>
&bull;  <i>E</i> is local (see <a href="report_2.html#5232b">5.2.3.2.b</a>), but not further defined. }
</dd>
</dl>

<p>
<a name=322c></a>c) The yield <i>W</i> of a <b>series</b> <i>C</i> is determined as follows:
<br>
If C contains a direct descendent <b>unit</b> which is not followed by a <b>go-on-token</b>, 
then
<ul>
&bull;  <i>W</i> is the yield of that <b>unit</b>;
</ul>
otherwise, 
<ul>
&bull;  the <b>declaration</b> or the <b>unit</b>, if any, of <i>C</i> is elaborated;
<br>
&bull;  <i>W</i> is the yield of the <b>series</b> of <i>C</i>.
</ul>
{See also <a href="report_2.html#5442cA">5.4.4.2.Case A</a> .}

<h3>
<a name=33></a>3.3. Collateral and parallel clauses
</h3>

<p>
{<b>Collateral-clauses</b> allow an arbitrary merging of streams of actions. <b>Parallel-clauses</b> provide, moreover, levels of coordination for the synchronization {<a href="report_5.html#A24">10.2.4</a>}  of that merging.
<br>
A <b>collateral-</b> or <b>parallel-clause</b> consists of a sequence of <b>units</b> separated by <b>and-also-symbols</b> (viz., "<tt>, </tt>"), and is enclosed by parentheses or by a <tt>BEGIN</tt>-<tt>END</tt> pair; a <b>parallel-clause</b> begins moreover with <tt>PAR</tt>.
<br>
<b>Collateral-clauses</b>, but not <b>parallel-clauses</b>, may yield stowed values composed from the yields of the constituent <b>units</b>.
<br>
Examples of <b>collateral-clauses</b> yielding stowed values:
<pre>
[ ] INT q = (1, 4, 9, 16, 25);
STRUCT (INT price, STRING category) bike := (150, "sport").
</pre>
Example of a <b>parallel-clause</b> which synchronizes eating and speaking:.
<pre>
PROC VOID eat, speak; SEMA mouth = LEVEL 1;
   PAR BEGIN
       DO
           DOWN mouth;
           eat;
           UP mouth
       OD, 
       DO
           DOWN mouth;
           speak;
           UP mouth
       OD
   END.}
</pre>

<h3>
<a name=331></a>3.3.1. Syntax
</h3>

<p>
<a name=331a></a>a) <b>strong void NEST collateral clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>}  <b>: strong void NEST joined portrait</b> {b}<b> PACK.</b>
<br>
<a name=331b></a>b) <b>SOID NEST joined portrait</b> {a, b, c, d, <a href="report_2.html#341g">34g</a>}  <b>: where SOID balances SOID1 and SOID2</b> {<a href="report_2.html#321e">32e</a>}  <b>, SOID1 NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, SOID2 NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>or alternatively SOID2 NEST joined portrait</b> {b}<b>.</b>
<br>
<a name=331c></a>c) <b>strong void NEST parallel clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>}  <b>: parallel</b> {<a href="report_4.html#941f">94f</a>}  <b>token, strong void NEST joined portrait</b> {b}<b> PACK.</b>
<br>
<a name=331d></a>d) <b>strong ROWS of MODE NEST collateral clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>}  <b>: where (ROWS) is (row), strong MODE NEST joined portrait</b> {b}<b> PACK ;  where (ROWS) is (row ROWS1), strong ROWS1 of MODE NEST joined portrait</b> {b}<b>  PACK ; EMPTY PACK.</b>
<br>
<a name=331e></a>e) <b>strong structured with FIELDS FIELD mode NEST collateral clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>}  <b>: NEST FIELDS FIELD portrait</b> {f}<b> PACK.</b>
<br>
<a name=331f></a>f) <b>NEST FIELDS FIELD portrait</b> {e, f}<b> : NEST FIELDS portrait</b> {f, g}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST FIELD portrait</b> {g}<b>.</b> {<b>FIELD :: MODE field TAG.</b>}
<br>
<a name=331g></a>g) <b>NEST MODE field TAG portrait</b> {f}<b> : strong MODE NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=331h></a>h) <b>*structure display : strong structured with FIELDS FIELD mode NEST collateral clause</b> {e}<b>.</b>
<br>
<a name=331i></a>i) <b>*row display : strong ROWS of MODE NEST collateral clause</b> {d}<b>.</b>
<br>
<a name=331j></a>j) <b>*display : strong STOWED NEST collateral clause</b> {d, e}<b>.</b>
<br>
<a name=331k></a>k) <b>*vacuum : EMPTY PACK.</b>

<p>
<pre>
{Examples:
a) (x := 1, y := 2)             
b) x := 1, y := 2
c) x := 1, y := 2 d) (1, 2) (in [ ] REAL (1, 2))
e) (1, 2) (in COMPL (1, 2))      
f) 1, 2
g) 1 }
</pre>

<p>
{<b>Structure-displays</b> must contain at least two <b>FIELD-portraits</b>, for, otherwise, in the reach of
<ul>
<tt>MODE M = STRUCT (REF M m); M nobuo, yoneda;</tt>, 
</ul>
the <b>assignation</b>  <tt>nobuo := (yoneda)</tt> would be syntactically ambiguous and could produce different effects; however, <tt>m OF nobuo := yoneda</tt> is unambiguous.
<br>
<b>Row-displays</b> contain zero, two or more constituent <b>units</b>. It is also possible to present a single value as a multiple value, e.g., <tt>[1: 1]  INT v := 123</tt>, but this uses a coercion known as rowing {<a href="report_3.html#66">6.6</a>}.}

<h3>
<a name=332></a>3.3.2. Semantics
</h3>

<p>
<a name=332a></a>a) The elaboration of a <b>void-collateral-clause</b> or <b>void-parallel-clause</b> consists of the collateral elaboration of its constituent <b>units</b> and yields <tt>empty</tt>.

<p>
<a name=332b></a>b) The yield <i>W</i> of a <b>STOWED-collateral-clause</b>  <i>C</i> is determined as follows:
<br>
If the direct descendent of <i>C</i> is a <b>vacuum</b>, 
<br>
then
<ul>
{<b>'STOWED'</b> is some <b>'ROWS of MODE'</b> and} each bound pair in the descriptor of <i>W</i> is (1, 0) {and it has one ghost element whose value is irrelevant};
</ul>
otherwise, 
<ul>
<li>let V<sub>1</sub>, ... , V<sub>m</sub> be the {collateral} yields of the constituent <b>units</b> of <i>C</i>; </li>
<br>
<a name=332cA></a>Case A: <b>'STOWED'</b> is some <b>'structured with FIELDS mode'</b>:
<br>
&bull;  the fields of <i>W</i>, taken in order, are V<sub>1</sub>, ... ,      V<sub>m</sub>;
<br>
<a name=332cB></a>Case B: <b>'STOWED'</b> is some <b>'row of MODE1'</b>:
<br>
&bull;  <i>W</i> is composed of
<ol type=i>
<li>a descriptor ( (1, m)), 
<li>V<sub>1</sub>, ... , V<sub>m</sub>;
</ol>
<dd>
For i = 1 ... m, 
<ul>
&bull;  the element selected by the index (i) in <i>W</i> is <i>V<sub>i</sub></i>;
</ul>
<br><a name=332cC></a>Case C: <b>'STOWED'</b> is some <b>'row ROWS of MODE2'</b>:
<ul>
<li> it is required that the descriptors of V<sub>1</sub>, ... ,        V<sub>m</sub> be identical;
<li> let the descriptor of {say} <i>V<sub>1</sub></i> be ( (l<sub>1</sub>, u<sub>1</sub>), ..., (l<sub>n</sub>, u<sub>n</sub>));
<li> <i>W</i> is composed of
<ol type=i>
<li> a descriptor ( (1, m), (l<sub>1</sub>, u<sub>1</sub>), ...,          (l<sub>n</sub>, u<sub>n</sub>));
<li> the elements of V<sub>1</sub>, ... , V<sub>m</sub>;
</ol>
<br>
For i = 1 ... m, 
<ul>
<li>the element selected by an index (i, i<sub>1</sub>, ... ,          i<sub>n</sub>) in <i>W</i> is that selected by (i<sub>1</sub>, ... ,          i<sub>n</sub>) in V<sub>i</sub>. </li>
</ul>
</ul>
</ul>

<p>
{Note that in <tt>[, , ]CHAR block = ("abc", "def")</tt>, the descriptor of the three-dimensional yield <i>W</i> will be ( (1, 2), (1, 1), (1, 3)), since the <b>units</b> <tt>"abc"</tt> and <tt>"def"</tt> are first rowed {<a href="report_3.html#66">6.6</a>}, so that <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i> have descriptors ( (1, 1),  (1, 3)).}

<h3>
<a name=34></a>3.4. Choice clauses
</h3>

<p>
{<b>Choice-clauses</b> enable a dynamic choice to be made among different paths in a computation. The choice among the alternatives (the <b>in-CHOICE-</b> and the <b>out-CHOICE-clause</b>)  is determined by the success or failure of a test on a truth value, on an integer or on a mode. The value under test is computed by an <b>enquiry-clause</b> before the choice is made.

<p>
A <b>choice-using-boolean-clause</b> (or <b>conditional-clause</b>) is of the form
<br>
<tt> (x &gt; 0 | x | 0)</tt> in the "brief" style, or
<br>
<tt>IF x &gt; 0 THEN x ELSE 0 FI</tt> in the "bold" style;
<br>
<tt>x &gt; 0</tt> is the <b>enquiry-clause</b>, <tt>THEN x</tt> is the <b>in-CHOICE-clause</b> and <tt>ELSE 0</tt> is the <b>out-CHOICE-clause</b>; all three may have the syntactical structure of a <b>series</b>, because all <b>choice-clauses</b> are well closed. A <b>choice-using-boolean-clause</b> may also be reduced to
<br>
<tt> (x &lt; 0 | x := - x)</tt> or
<br>
<tt>IF x &lt; 0 THEN x := - x FI</tt>;
<br>
the omitted <b>out-CHOICE-clause</b> is then understood to be an <tt>ELSE SKIP</tt>. On the other hand, the choice can be reiterated by writing
<br>
<tt> (x &gt; 0 | 1 + x |: x &lt; 0 | 1 - x | 1)</tt> or
<br>
<tt>IF x &gt; 0 THEN 1  + x ELIF x &lt; 0 THEN 1 - x ELSE 1 FI</tt>, 
<br>and so on; this is to be understood as
<br>
<tt> (x &gt; 0 | 1 + x | (x &lt; 0 | 1 - x | 1))</tt>.

<p>
<b>CASE-clauses</b>, which define choices depending on an integer or on a mode, are different in that the <b>in-CASE-clause</b> is further decomposed into <b>units</b>. The general pattern is
<br>
<tt> (- | -, ... , - | -)</tt> or
<br>
<tt>CASE -IN-, ... , -OUT- ESAC</tt>.
<br>
The choice may also be reiterated by use of <tt>OUSE</tt>.

<p>
In a <b>choice-using-integral-clause</b> (or <b>case-clause</b>), the parts are simply <b>units</b> and there must be at least two of them; the choice among the <b>units</b> follows their textual ordering.
<br>
Example:
<pre>
PROC VOID work, relax, enjoy;
CASE INT day; read (day); day
IN work, work, work, work, work, relax, enjoy
OUT print ( (day, "is not in the week"))
ESAC.
</pre>

In a <b>choice-using-UNITED-clause</b> (or <b>conformity-clause</b>), which tests modes, each <b>case-part-of-CHOICE</b> is of the form <tt> (DECLARER identifier): unit</tt> or <tt> (DECLARER): unit</tt>. The mode specified by the <b>declarer</b> is compared with the mode of the value under test; the <b>identifier</b>, if present, is available inside the <b>unit</b> to access that value, with the full security of syntactical mode checking. The <b>'UNITED'</b> mode provides the required freedom for the mode of the value under test; moreover, that <b>'UNITED'</b> mode must contain the mode of each <b>specification</b> for, otherwise, the corresponding <b>case-part-of-CHOICE</b> could never be chosen.

<br>
Example:
<pre>
MODE BOY = STRUCT (INT age, REAL weight), 
MODE GIRL = STRUCT (INT age, REAL beauty);
PROC UNION (BOY, GIRL) newborn;
CASE newborn IN
   (BOY john): print (weight OF john), 
   (GIRL mary): print (beauty OF mary)
ESAC.
</pre>
}

<Div align=right> {The flowers that bloom in the spring, <br>
Tra la, <br>
Have nothing to do with the case.<br>
Mikado, W.S. Gilbert.}
</div>

<p>
<br>
{The hierarchy of <b>ranges</b> in <b>conditional-clauses</b> is illustrated by
<ul>
<pre>
------------IF------------
|  --THEN--    --ELSE--  |
|  |      |    |      |  |
|  --------    --------  |
------------FI------------
</pre>
</ul>
and similarly for the other kinds of choice. Thus the nest and the environ of the <b>enquiry-clause</b> remain valid over the <b>in-CHOICE-clause</b> and the <b>out-CHOICE-clause</b>. However, no transfer back from the <b>in-</b> or <b>out-CHOICE-clause</b> into the <b>enquiry-clause</b> is possible, since the latter can contain no <b>label-definitions</b> (except within a <b>closed-clause</b> contained within it).}

<h3>
<a name=341></a>3.4.1. Syntax
</h3>

<p>
<a name=341A></a>A) <b>CHOICE :: choice using boolean ; CASE.</b>
<br>
<a name=341B></a>B) <b>CASE :: choice using integral ; choice using UNITED.</b>
<br>
<a name=341a></a>a) <b>SOID NEST1 CHOICE clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>, <a href="report_5.html#A3411h">A341h</a>, <a href="report_5.html#A3491a">A349a</a>}  <b>: CHOICE STYLE start</b> {<a href="report_4.html#911a">91a</a>  , -}<b>, SOID NEST1 chooser CHOICE STYLE clause</b> {b}<b>, CHOICE STYLE finish</b> {<a href="report_4.html#911e">91e</a>  , -}<b>.</b>
<br>
<a name=341b></a>b) <b>SOID NEST1 chooser choice using MODE STYLE clause</b> {a, l}<b> : MODE NEST1 enquiry clause defining LAYER2</b> {c, -}<b>, SOID NEST1 LAYER2 alternate choice using MODE STYLE clause</b> {d}<b>.</b>
<br>
<a name=341c></a>c) <b>MODE NEST1 enquiry clause defining new DECSETY2</b> {b, <a href="report_2.html#351g">35g</a>}  <b>: meek MODE NEST1 new DECSETY2 series with DECSETY2</b> {<a href="report_2.html#321b">32b</a>}  <b>.</b>
<br>
<a name=341d></a>d) <b>SOID NEST2 alternate CHOICE STYLE clause</b> {b}<b> :  SOID NEST2 in CHOICE STYLE clause</b> {e}<b>; where SOID balances SOID1 and SOID2</b> {<a href="report_2.html#321e">32e</a>}  <b>, SOID1 NEST2 in CHOICE STYLE clause</b> {e}<b>, SOID2 NEST2 out CHOICE STYLE clause</b> {l}<b>.</b>
<br>
<a name=341e></a>e) <b>SOID NEST2 in CHOICE STYLE clause</b> {d}<b> : CHOICE STYLE in</b> {<a href="report_4.html#911b">91b</a>  , -}<b>, SOID NEST2 in part of CHOICE</b> {f, g, h}<b>.</b>
<br>
<a name=341f></a>f) <b>SOID NEST2 in part of choice using boolean</b> {e}<b> :  SOID NEST2 serial clause defining LAYER3</b> {<a href="report_2.html#321a">32a</a>}  <b>.</b>
<br>
<a name=341g></a>g) <b>SOID NEST2 in part of choice using integral</b> {e}<b>  : SOID NEST2 joined portrait</b> {<a href="report_2.html#331b">33b</a>}  <b>.</b>
<br>
<a name=341h></a>h) <b>SOID NEST2 in part of choice using UNITED</b> {e, h}<b>  : SOID NEST2 case part of choice using UNITED</b> {i}<b>; where SOID balances SOID1 and SOID2</b> {<a href="report_2.html#321e">32e</a>}  <b>, SOID1 NEST2 case part of choice using UNITED</b> {i}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, SOID2 NEST2 in part of choice using UNITED</b> {h}<b>.</b>
<br>
<a name=341i></a>i) <b>SOID NEST2 case part of choice using UNITED</b> {h}<b>  : MOID NEST2 LAYER3 specification defining LAYER3</b> {j, k, -}<b>, where MOID unites to UNITED</b> {<a href="report_3.html#641b">64b</a>}  <b>, SOID NEST2 LAYER3 unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
{Here<b>LAYER :: new MODE TAG ; new EMPTY.</b>}
<br>
<a name=341j></a>j) <b>MODE NEST3 specification defining new MODE TAG3</b> {i}<b> : NEST3 declarative defining new MODE TAG3</b> {<a href="report_2.html#5411e">541e</a>}  <b>brief pack, colon</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>
<br>
<a name=341k></a>k) <b>MOID NEST3 specification defining new EMPTY</b> {i}<b>  : formal MOID NEST3 declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>brief pack, colon</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>
<br>
<a name=341l></a>l) <b>SOID NEST2 out CHOICE STYLE clause</b> {d}<b> : CHOICE STYLE out</b> {<a href="report_4.html#911d">91d</a>  , -}<b>, SOID NEST2 serial clause defining LAYER3</b> {<a href="report_2.html#321a">32a</a>}  <b>; CHOICE STYLE again</b> {<a href="report_4.html#911c">91c</a>  , -}<b>, SOID NEST2 chooser CHOICE2 STYLE clause</b> {b}<b>, where CHOICE2 may follow CHOICE</b> {m}<b>.</b>
<br>
<a name=341m></a>m) <b>WHETHER choice using MODE2 may follow choice using MODE1 </b> {l}<b> : where (MODE1) is (MOOD), WHETHER (MODE2) is (MODE1) ; where (MODE1) begins with (union of), WHETHER (MODE2) begins with (union of).</b>
<br>
<a name=341n></a>n) <b>*SOME choice clause : SOME CHOICE clause {a}.</b>
<br>
<a name=341o></a>o) <b>*SOME conditional clause : SOME choice using boolean clause {a}.</b>
<br>
<a name=341p></a>p) <b>*SOME case clause : SOME choice using integral clause {a}.</b>
<br>
<a name=341q></a>q) <b>*SOME conformity clause : SOME choice using UNITED clause {a}.</b>

<p>
<pre>
{Examples:
a) (x > 0 | x | 0) &bull;
        CASE i IN princeton, grenoble OUT finish ESAC &bull;
        CASE uir IN (INT i): print (i), (REAL): print ("no") ESAC
b) x > 0 | x | 0
c) x > 0 &bull; i &bull; uir
d) | x &bull; |x | 0
e) | x &bull;
       IN princeton, grenoble &bull;
       IN (INT i): print (i), (REAL): print ("no")
f) x
g) princeton, grenoble
h) (INT i): print (i), (REAL): print ("no")
i) (INT i): print (i)
j) (INT i):
k) (REAL):
l) OUT finish &bull; |: x < 0 | -x | 0 }
</pre>

<DIV align=right> {I would to God they would either conform,<br>
or be more wise, and not be catched!<br> 
Diary. 7 Aug. 1664, Samuel Pepys.}
</div>

<p>
<a name=341bal></a>{Rule d illustrates why <b>'SORT MOID'</b>s should be "balanced". If an <b>alternate-CHOICE-clause</b> is, say, firm, then at least its <b>in-CHOICE-clause</b> or its <b>out-CHOICE-clause</b> must be firm, while the other may be strong. For example, in <tt> (p | x | SKIP) + (p | SKIP | y)</tt>, the <b>conditional-clause</b> <tt> (p | x | SKIP)</tt> is balanced by making <tt>| x</tt> firm and <tt>| SKIP</tt> strong whereas <tt> (p | SKIP | y)</tt> is balanced by making <tt>| SKIP</tt> strong and <tt>| y</tt> firm. The counterexample <tt> (p | SKIP | SKIP) + y</tt> illustrates that not both may be strong, for otherwise the <b>operator</b> <tt>+</tt> could not be identified.}

<h3>
<a name=342></a>3.4.2. Semantics
</h3>

<p>
<a name=342a></a>a) The yield <i>W</i>  of a <b>chooser-CHOICE-clause</b> <i>C</i>, in an environ <i>E1</i>, is determined as follows:
<br>
&bull;  let <i>E2</i> be the environ established {<a href="report_2.html#322b">3.2.2.b</a>} around <i>E1</i> according to the <b>enquiry-clause</b> of <i>C</i>;
<br>
&bull;  let <i>V</i> be the yield, in <i>E2</i>, of that <b>enquiry-clause</b>;
<br>
&bull;  <i>W</i> is the yield of the scene "chosen" {b} by <i>V</i> from <i>C</i> in <i>E2</i>; it is required that <i>W</i> be not newer in scope than <i>E1</i>.

<p>
<a name=342b></a>b) The scene <i>S</i> "chosen" by a value <i>V</i> from a <b>MOID-chooser-CHOICE-clause</b> <i>C</i>, in an environ <i>E2</i>, is determined as follows:
<p><a name=342cA></a>
Case A: <b>'CHOICE'</b> is <b>'choice using boolean'</b> and <i>V</i> is <tt>true</tt>:
<ul>
&bull;  <i>S</i> is the constituent <b>in-CHOICE-clause</b> of <i>C</i>, in <i>E2</i>;
</ul>
<a name=342cB></a>
Case B: <b>'CHOICE'</b> is <b>'choice using integral'</b> and 1 &le;V    &le;n, where <i>n</i> is the number of constituent <b>units</b> of the constituent <b>in-part-of-CHOICE</b> of <i>C</i>:
<ul>
&bull;  <i>S</i> is the <i>V</i>-th such <b>unit</b>, in <i>E2</i>;
</ul>
<a name=342cC></a>
Case C: <b>'CHOICE'</b> is some <b>'choice using UNITED'</b> and <i>V</i>    is acceptable to {<a href="report_1.html#2136d">2.1.3.6.d</a>} the <b>'MOID2'</b> of some constituent <b>MOID2-specification</b> <i>D</i>    of <i>C</i> {; if there exists more than one such constituent <b>specification</b>, it is not defined which one is chosen as <i>D</i>} ;
<ul>
&bull;  <i>S</i> is the <b>unit</b> following that <i>D</i>, in an environ established {nonlocally {<a href="report_2.html#322b">3.2.2.b</a>} } around <i>E2</i>, according to <i>D</i>, with <i>V</i>;
</ul>
Other Cases {when the <b>enquiry-clause</b> has been unsuccessful} :
<ul>
If <i>C</i> contains a constituent <b>out-CHOICE-clause</b> <i>O</i>, 
<br>
then <i>S</i> is <i>O</i> in <i>E2</i>;
<br>
otherwise, <i>S</i> is a <b>MOID-skip</b> in <i>E2</i>.
</ul>

<h3>
<a name=35></a>3.5. Loop clauses
</h3>

<p>
{<b>Loop-clauses</b> are used for repeating dynamically one same sequence of instructions. The number of repetitions is controlled by a finite sequence of equidistant integers, by a condition to be tested each time, or by both.
<br>
Example 1:
<pre>
INT fac := 1;
FOR i FROM n BY -1 TO 1
DO fac &times;:= i OD.
</pre>
Example 2:
<pre>
INT a, b; read ( (a, b)) PR ASSERT a &ge; 0 &amp; b &gt; 0 PR;
INT q := 0, r := a;
WHILE r &ge; b PR ASSERT a = b * q + r &amp; 0 &le; r PR
DO (q +:= 1, r -:= b) OD
PR ASSERT a = b &times; q + r &amp; 0 &le; r &amp; r &lt; b PR
</pre>
 (see <a href="report_4.html#92">9.2</a> for an explanation of the <b>pragmats</b>).

<p>
The controlled <b>identifier</b>, e.g., <i>i</i> in Example 1, is defined over the <b>repeating-part</b>. Definitions introduced in the <b>while-part</b>  are also valid over the <b>do-part</b>.
<br>
If the controlled <b>identifier</b> is not applied in the <b>repeating-part</b>, then the <b>for-part</b> may be omitted. A <b>from-part</b> <tt>FROM 1</tt> may be omitted; similarly, <tt>BY 1</tt> may be omitted. The <b>to-part</b> may be omitted if no test on the final value of the control-integer is required. A <b>while-part</b> <tt>WHILE TRUE</tt> may be omitted. For example, 
<pre>
FOR i FROM 1 BY 1 TO n WHILE TRUE DO print ("a") OD
</pre>
may be written
<pre>
TO n DO print ("a") OD
</pre>.

<p>
The hierarchy of <b>ranges</b> is illustrated by:
<ul>
<pre>
      ----
1 FOR |  | FROM BY TO
-------  ------------
|   2 -----WHILE--- |
|     |   3--DO-- | |
|     |    |    | | |
|     |    --OD-- | |
|     ------------- |
---------------------
</pre>
</ul>
<p>
}

<h3>
<a name=351></a>3.5.1. Syntax
</h3>

<p>
<a name=351A></a>A) <b>FROBYT :: from ; by  ; to.</b>
<br>
<a name=351a></a>a) <b>strong void NEST1 loop clause</b> {<a href="report_2.html#51D">5D</a> , <a href="report_2.html#5511a">551a</a>}  <b>: NEST1 STYLE for part defining new integral TAG2</b> {b}<b>, NEST1 STYLE intervals</b> {c}<b>, NEST1 STYLE repeating part with integral TAG2</b> {e}<b>.</b>
<br>
<a name=351b></a>b) <b>NEST1 STYLE for part defining new integral TAG2 {a} :  STYLE for</b> {<a href="report_4.html#941g">94g</a>  , -}<b> token, integral NEST1 new integral TAG2 defining identifier with TAG2</b> {<a href="report_2.html#481a">48a</a>}  <b>; where (TAG2) is (letter aleph), EMPTY.</b>
<br>
<a name=351c></a>c) <b>NEST1 STYLE intervals {a} : NEST1 STYLE from part</b> {d}<b> option, NEST1 STYLE by part</b> {d}<b> option, NEST1 STYLE to part</b> {d}<b> option.</b>
<br>
<a name=351d></a>d) <b>NEST1 STYLE FROBYT part</b> {c}<b> : STYLE FROBYT</b> {<a href="report_4.html#941g">94g</a>  , -}<b> token, meek integral NEST1 unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=351e></a>e) <b>NEST1 STYLE repeating part with DEC2 {a} : NEST1 new DEC2 STYLE while do part</b> {f}<b>; NEST1 new DEC2 STYLE do part</b> {h}<b>.</b>
<br>
<a name=351f></a>f) <b>NEST2 STYLE while do part</b> {e}<b> : NEST2 STYLE while part defining LAYER3</b> {g}<b>, NEST2 LAYER3 STYLE do part</b> {h}<b>.</b>
<br>
<a name=351g></a>g) <b>NEST2 STYLE while part defining LAYER3</b> {f}<b> :  STYLE while</b> {<a href="report_4.html#941g">94g</a>  , -}<b> token, boolean NEST2 enquiry clause defining LAYER3</b> {<a href="report_2.html#341c">34c</a>  , -}<b>.</b>
<br>
<a name=351h></a>h) <b>NEST3 STYLE do part</b> {e, f}<b> : STYLE do</b> {<a href="report_4.html#941g">94g</a>  , -}<b> token, strong void NEST3 serial clause defining LAYER4</b> {<a href="report_2.html#321a">32a</a>}  <b>, STYLE od</b> {<a href="report_4.html#941g">94g</a>  , -}<b> token.</b>
<p>
<pre>
{Examples:
a) FOR i WHILE i &lt; n DO task1 OD &bull; TO n DO task1; task2 OD
b) FOR i
c) FROM -5 TO +5
d) FROM -5
e) WHILE i &lt; n DO task1 OD &bull; DO task1; task2 OD
f) WHILE i &lt; n DO task 1; task2 OD
g) WHILE i &lt; n
h) DO task1; task2 OD }
</pre>

<h3>
<a name=352></a>3.5.2. Semantics
</h3>

<p>
A <b>loop-clause</b> <i>C</i>, in an environ <i>E1</i>, is elaborated in the following Steps:
<br>
<a name=352s1></a>
Step 1: All the constituent <b>FROBYT-parts</b>, if any, of <i>C</i> are elaborated collaterally in <i>E1</i>;
<ul>
&bull;  let <i>f</i> be the yield of the constituent <b>from-part</b>, if any, of <i>C</i>, and be 1 otherwise;
<br>
&bull;  let <i>b</i> be the yield of the constituent <b>by-part</b>, if any, of <i>C</i>, and be 1 otherwise;
<br>
&bull;  let <i>t</i> be the yield of the constituent <b>to-part</b>, if any, of <i>C</i>, and be <i>absent</i> otherwise;
<br>
&bull;  let <i>E2</i> be the environ established {nonlocally {<a href="report_2.html#322b">3.2.2.b</a>} } around <i>E1</i>, according to the <b>for-part-defining-new-integral-TAG2</b> of <i>C</i>, and with the integer <i>f</i>;
</ul>
<a name=352s2></a>
Step 2: Let <i>i</i> be the integer accessed {<a href="report_1.html#212c">2.1.2.c</a>} by <b>'integral TAG2'</b> inside the locale of <i>E2</i>;
<ul>
If <i>t</i> is not <i>absent</i>, 
<br>
then
<ul>
If b &gt; 0 and i &gt; t or if b &lt; 0 and i &lt; t, 
<br>
then <i>C</i> in <i>E1</i> {is completed and} yields <tt>empty</tt>;
</ul>
{otherwise, Step 3 is taken; }
</ul>
<a name=352s3></a>
Step 3: Let an environ <i>E3</i> and a truth value <i>w</i> be determined as follows:
<ul>
<a name=352cA></a>
Case A: <i>C</i> does not contain a constituent <b>while-part</b>:
<ul>
&bull;  <i>E3</i> is <i>E2</i>;
<br>
&bull;  <i>w</i> is <tt>true</tt>;
</ul>
<a name=352cB></a>
Case B: <i>C</i> contains a constituent <b>while-part</b> <i>P</i>:
<ul>
&bull;  <i>E3</i> is established {perhaps nonlocally {<a href="report_2.html#322b">3.2.2.b</a>} } around <i>E2</i> according to the <b>enquiry-clause</b> of <i>P</i>;
<br>
&bull;  <i>w</i> is the yield in <i>E3</i> of that <b>enquiry-clause</b>;
</ul>
</ul>
<a name=352s4></a>
Step 4: If <i>w</i> is <tt>true</tt>, then
<ul>
&bull;  the constituent <b>do-part</b> of <i>C</i> is elaborated in <i>E3</i>;
<br>
&bull;  <b>'integral TAG2'</b> is made to access <i>i + b</i> inside the locale of <i>E2</i>;
<br>
&nbsp;&nbsp;<var>[[Note the possibility of overflow even in case TAG2 and intervals are empty]]</var>
<br>
&bull;  Step 2 is taken again; otherwise, 
<br>
&bull;  <i>C</i> in <i>E1</i> {is completed and} yields <tt>empty</tt>.
</ul>

<p>
{The <b>loop-clause</b>
<pre>
FOR i FROM u1 BY u2 TO u3 WHILE condition DO action OD
</pre>
is thus equivalent to the following <b>void-closed-clause</b>:
<pre>
BEGIN INT f:= u1, INT b = u2, t = u3;
   step2:
      IF (b &gt; 0 &amp; f &le; t) OR (b &lt; 0 &amp; f &ge; t) OR b = 0
      THEN INT i = f;
         IF condition
         THEN action; f +:= b; GO TO step2
         FI
      FI
END
</pre>.

<p>
This equivalence might not hold, of course, if the <b>loop-clause</b> contains <b>local-generators</b>, or if some of the <b>operators</b> above do not identify those in the standard environment {<a href="report_5.html#A">10</a>}.}

<h3>
<a name=4></a>4. Declarations, declarers and indicators
</h3>

<p>
{Declarations serve
<ul>
<li> to announce new <b>indicators</b>, e.g., <b>identifiers</b>, 
<li> to define their modes or priorities, and
<li> to ascribe values to those <b>indicators</b> and to initialize <b>variables</b>.}
</ul>

<h3>
<a name=41></a>4.1. Declarations
</h3>

<h3>
<a name=411></a>4.1.1. Syntax
</h3>

<p>
<a name=411A></a>A) <b>COMMON :: mode ;  priority ; MODINE identity ; reference to MODINE variable ; MODINE operation ;  PARAMETER ; MODE FIELDS.</b> {<b>MODINE :: MODE ; routine.</b>}
<br>
<a name=411a></a>a) <b>NEST declaration of DECS</b> {a, <a href="report_2.html#321b">32b</a>}  <b>: NEST COMMON declaration of DECS</b> {<a href="report_2.html#421a">42a</a> , <a href="report_2.html#431a">43a</a>, <a href="report_2.html#441a">44a, e</a>, <a href="report_2.html#451a">45a</a>, -}<b>;  where (DECS) is (DECS1 DECS2), NEST COMMON declaration of DECS1</b> {<a href="report_2.html#421a">42a</a> , <a href="report_2.html#431a">43a</a>, <a href="report_2.html#441a">44a, e</a>, <a href="report_2.html#451a">45a</a>, -}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST declaration of DECS2 {a}.</b>
<br>
<a name=411b></a>b) <b>NEST COMMON joined definition of PROPS PROP </b> {b, <a href="report_2.html#421a">42a</a> , <a href="report_2.html#431a">43a</a>, <a href="report_2.html#441a">44a, e</a>, <a href="report_2.html#451a">45a</a>, <a href="report_2.html#461e">46e</a>, <a href="report_2.html#5411e">541e</a>}  <b>: NEST COMMON joined definition of PROPS</b> {b, c}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST COMMON joined definition of PROP</b> {c}<b>.</b>
<br>
<a name=411c></a>c) <b>NEST COMMON joined definition of PROP </b> {b, <a href="report_2.html#421a">42a</a> , <a href="report_2.html#431a">43a</a>, <a href="report_2.html#441a">44a, e</a>, <a href="report_2.html#451a">45a</a>, <a href="report_2.html#461e">46e</a>, <a href="report_2.html#5411e">541e</a>}  <b>: NEST COMMON definition of PROP</b> {<a href="report_2.html#421b">42b</a> , <a href="report_2.html#431b">43b</a>, <a href="report_2.html#441c">44c, f</a>, <a href="report_2.html#451c">45c</a>, <a href="report_2.html#461f">46f</a>, <a href="report_2.html#5411f">541f</a>, -}<b>.</b>
<br>
<a name=411d></a>d) <b>*definition of PROP : NEST COMMON definition of PROP </b> {<a href="report_2.html#421b">42b</a> , <a href="report_2.html#431b">43b</a>, <a href="report_2.html#441c">44c, f</a>, <a href="report_2.html#451c">45c</a>, <a href="report_2.html#461f">46f</a>, <a href="report_2.html#5411f">541f</a>}  <b>; NEST label definition of PROP</b> {<a href="report_2.html#321c">32c</a>}  <b>.</b>

<p>
<pre>
{Examples:
a) MODE R = REF REAL, S = CHAR &bull; PRIO OR = 2, AND = 3 &bull; INT m =4096 &bull;
      REAL x, y &bull;
      OP OR = (BOOL a, b) BOOL : (a | TRUE | b)
b) R = REF REAL, S = CHAR &bull; OR = 2, AND = 3 &bull; m = 4096 &bull; x, y &bull; OR = (BOOL a, b) BOOL : (a | TRUE | b)
c) R = REF REAL &bull; OR = 2 &bull; m = 4096 &bull; x &bull; OR = (BOOL a, b) BOOL : (a | TRUE | b) }
</pre>

<h3>
<a name=412></a>4.1.2. Semantics
</h3>

<p>
The elaboration of a <b>declaration</b>  consists of the collateral elaboration of its <b>COMMON-declaration</b> and of its <b>declaration</b>, if any. {Thus, all the <b>COMMON-declarations</b>  separated by <b>and-also-tokens</b> are elaborated collaterally.}

<h3>
<a name=42></a>4.2. Mode declarations
</h3>

<p>
{<b>Mode-declarations</b> provide the <b>defining-mode-indications</b>, which act as abbreviations for <b>declarers</b> constructed from the more primitive ones, or from other <b>declarers</b>, or even from themselves.
<br>
for example, 
<br>
<tt>MODE ARRAY = [m, n] REAL</tt>, and
<br>
<tt>MODE BOOK = STRUCT (STRING text, REF BOOK next)</tt>
<br>
In the latter example, the <b>applied-mode-indication</b>  <tt>BOOK</tt> is not only a convenient abbreviation, but is essential to the <b>declaration</b>.}

<h3>
<a name=421></a>4.2.1. Syntax
</h3>

<p>
<a name=421a></a>a) <b>NEST mode declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>: mode</b> {<a href="report_4.html#941d">94d</a>}  <b>token, NEST mode joined definition of DECS</b> {<a href="report_2.html#411b">41b, c</a>}  <b>.</b>
<br>
<a name=421b></a>b) <b>NEST mode definition of MOID TALLY TAB</b> {<a href="report_2.html#411c">41c</a>}  <b>: where (TAB) is (bold TAG) or (NEST) is (new LAYER), MOID TALLY NEST defining mode indication with TAB</b> {<a href="report_2.html#481a">48a</a>}  <b>, is defined as</b> {<a href="report_4.html#941d">94d</a>}  <b>token, actual MOID TALLY NEST declarer</b> {c}<b>.</b>
<br>
<a name=421c></a>c) <b>actual MOID TALLY1 NEST declarer</b> {b}<b> : where (TALLY1) is (i), actual MOID NEST declarator</b> {<a href="report_2.html#461c">46c, d, g, h, o, s</a>  , -}<b>; where (TALLY1) is (TALLY2 i), MOID TALLY2 NEST applied mode indication with TAB2 </b> {<a href="report_2.html#481b">48b</a>}  <b>.</b>

<p>
<pre>
{Examples:
a) MODE R = REF REAL, S = CHAR
b) R = REF REAL
c) REF REAL &bull; CHAR }
</pre>

<p>
{The use of <b>'TALLY'</b>  excludes circular chains of <b>mode-definitions</b> such as <tt>MODE A = B, B =  A</tt>.

<p>
<b>Defining-mode-indications-with-SIZETY-STANDARD</b> may be declared only in the <b>standard-prelude</b>, where the nest is of the form "<b>new LAYER</b>"  {<a href="report_5.html#A11b">10.1.1.b</a>}.}

<h3>
<a name=422></a>4.2.2. Semantics
</h3>

<p>
The elaboration of a <b>mode-declaration</b> {involves no action, yields no value and} is completed.

<h3>
<a name=43></a>4.3. Priority declarations
</h3>

<p>
{<b>Priority-declarations</b>  are used to specify the priority of <b>operators</b>. Priorities from 1 to 9 are available.
<br>
Since <b>monadic-operators</b> have effectively only one priority-level, which is higher than that of all <b>dyadic-operators</b>,  <b>monadic-operators</b> do not require <b>priority-declarations</b>.}

<h3>
<a name=431></a>4.3.1. Syntax
</h3>

<p>
<a name=431a></a>a) <b>NEST priority declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>: priority</b> {<a href="report_4.html#941d">94d</a>}  <b>token, NEST priority joined definition of DECS</b> {<a href="report_2.html#411b">41b, c</a>}  <b>.</b>
<br>
<a name=431b></a>b) <b>NEST priority definition of priority PRIO TAD</b> {<a href="report_2.html#411c">41c</a>}  <b>: priority PRIO NEST defining operator with TAD</b> {<a href="report_2.html#481a">48a</a>}  <b>, is defined as</b> {<a href="report_4.html#941d">94d</a>}  <b>token, DIGIT</b> {<a href="report_4.html#941b">94b</a>}  <b>token, where DIGIT counts PRIO</b> {c, d}<b>.</b>
<br>
<a name=431c></a>c) <b>WHETHER DIGIT1 counts PRIO i</b> {b, c}<b> : WHETHER DIGIT2 counts PRIO</b> {c, d}<b>, where (digit one digit two digit three digit four digit five digit six digit seven digit eight digit nine) contains (DIGIT2 DIGIT1).</b>
<br>
<a name=431d></a>d) <b>WHETHER digit one counts i</b> {b, c}<b> : WHETHER true.</b>

<p>
<pre>
{Examples:
a) PRIO OR 2, AND = 3
b) OR = 2 }
</pre>

<h3>
<a name=432></a>4.3.2. Semantics
</h3>

<p>
The elaboration of a <b>priority-declaration</b> {involves no action, yields no value and} is completed.

<h3>
<a name=44></a>4.4. Identifier declarations
</h3>

<p>
{<b>Identifier-declarations</b> provide <b>MODE-defining-identifiers</b>, by means of either <b>identity-definitions</b>  or <b>variable-definitions</b>.

<p>
Examples:
<br>
<tt>REAL pi = 3.1416 &bull; REAL scan := 0.05</tt> .
<br>
The latter example, which is a <b>variable-declaration</b>, may be considered as an equivalent form of the <b>identity-declaration</b>
<br>
<tt>REF REAL scan = LOC REAL := 0.05</tt>.
<br>
The elaboration of <b>identifier-declarations</b> causes values to be ascribed to their <b>identifiers</b>; in the examples given above, 3.1416 is ascribed to <tt>pi</tt> and a new local name which refers to 0.05 is ascribed to <tt>scan</tt>.}

<h3>
<a name=441></a>4.4.1. Syntax
</h3>

<p>
<a name=441A></a>A) <b>MODINE :: MODE ;  routine.</b>
<br>
<a name=441B></a>B) <b>LEAP :: local ; heap ; primal.</b>
<br>
<a name=441a></a>a) <b>NEST MODINE identity declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>: formal MODINE NEST declarer</b> {b, <a href="report_2.html#461b">46b</a>}  <b>, NEST MODINE identity joined definition of DECS</b> {<a href="report_2.html#411b">41b, c</a>}  <b>.</b>
<br>
<a name=441b></a>b) <b>VICTAL routine NEST declarer</b> {a, <a href="report_2.html#5231b">523b</a>}  <b>: procedure</b> {<a href="report_4.html#941d">94d</a>}  <b>token.</b>
<br>
<a name=441c></a>c) <b>NEST MODINE identity definition of MODE TAG</b> {<a href="report_2.html#411c">41c</a>}  <b>: MODE NEST defining identifier with TAG</b> {<a href="report_2.html#481a">48a</a>}  <b>, is defined as</b> {<a href="report_4.html#941d">94d</a>}  <b>token, MODE NEST source for MODINE</b> {d}<b>.</b>
<br>
<a name=441d></a>d) <b>MODE NEST source for MODINE</b> {c, f, <a href="report_2.html#451c">45c</a>}  <b>: where (MODINE) is (MODE), MODE NEST source</b> {<a href="report_2.html#5211c">521c</a>}  <b>; where (MODINE) is (routine), MODE NEST routine text</b> {<a href="report_2.html#5411a">541a, b</a>  , -}<b>.</b>
<br>
<a name=441e></a>e) <b>NEST reference to MODINE variable declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>: reference to MODINE NEST LEAP sample generator</b> {<a href="report_2.html#5231b">523b</a>}  <b>, NEST reference to MODINE variable joined definition of DECS</b> {<a href="report_2.html#411b">41b, c</a>}  <b>.</b>
<br>
<a name=441f></a>f) <b>NEST reference to MODINE variable definition of reference to MODE TAG</b> {<a href="report_2.html#411c">41c</a>}  <b>: reference to MODE NEST defining identifier with TAG</b> {<a href="report_2.html#481a">48a</a>}  <b>, becomes</b> {<a href="report_4.html#941c">94c</a>}  <b>token, MODE NEST source for MODINE</b> {d}<b>; where (MODINE) is (MODE), reference to MODE NEST defining identifier with TAG</b> {<a href="report_2.html#481a">48a</a>}  <b>.</b>
<br>
<a name=441g></a>g) <b>*identifier declaration : NEST MODINE identity declaration of DECS {a}; NEST reference to MODINE variable declaration of DECS</b> {e}<b>.</b>

<p>
<pre>
{Examples:
a) INT m = 4096 &bull; PROC r10 = REAL: random &times; 10
b) PROC
c) m = 4096
d) 4096 &bull; REAL: random &times; 10
e) REAL x, y</tt> &bull; PROC pp := REAL: random &times; 10
f) pp := REAL: random &times; 10 &bull; x }
</pre>

<h3>
<a name=442></a>4.4.2. Semantics
</h3>

<p>
<a name=442a></a>a) An <b>identity-declaration</b> <i>D</i> is elaborated as follows:
<br>
&bull;  the constituent <b>sources-for-MODINE</b> of <i>D</i> are elaborated collaterally;
<br>
For each constituent <b>identity-definition</b> <i>D1</i> of <i>D</i>, 
<ul>
<li>the yield <i>V</i> of the <b>source-for-MODINE</b> of <i>D1</i> is ascribed {<a href="report_2.html#482a">4.8.2.a</a>} to the <b>defining-identifier</b> of <i>D1</i>.
</ul>

<p>
<a name=442b></a>b) A <b>variable-declaration</b> <i>D</i> is elaborated as follows:

<p>
&bull;  the <b>sample-generator</b> {<a href="report_2.html#5231b">5.2.3.1.b</a>} <i>G</i> of <i>D</i> and all the <b>sources-for-MODINE</b>, if any, of the constituent <b>variable-definitions</b> of <i>D</i> are elaborated collaterally;
<br>
For each constituent <b>variable-definition-of-reference-to-MODE-TAG</b>    <i>D1</i> of <i>D</i>, 
<ul>
&bull;  let <i>W1</i> be a "variant" {c}, for <b>'MODE'</b>, of the value referred to by the yield <i>N</i> of <i>G</i>;
<br>
&bull;  let <i>N1</i> be a newly created name equal in scope to <i>N</i> and referring to <i>W1</i>;
<br>
&bull;  if <i>N1</i> is a stowed name {<a href="report_1.html#2132b">2.1.3.2.b</a>}, then <i>N1</i> is endowed with subnames {<a href="report_1.html#2133e">2.1.3.3.e</a>    , <a href="report_1.html#2134g">2.1.3.4.g</a>};
<br>
&bull;  <i>N1</i> is ascribed {<a href="report_2.html#482a">4.8.2.a</a>} to the <b>defining-identifier</b> of <i>D1</i>;
<br>
&bull;  the yield of the <b>source-for-MODINE</b>, if any, of <i>D1</i> is assigned {<a href="report_2.html#5212b">5.2.1.2.b</a>} to <i>N1</i>.
</ul>

<p>
{An <b>actual-declarer</b> which is common to a number of <b>variable-definitions</b> is elaborated only once. For example, the elaboration of
<br>
<tt>INT m := 10; [1 : m +:= 1] INT p, q; print (m)</tt>
<br>
causes <i>11</i> to be printed, and not <i>12</i>; moreover, two new local names referring to multiple values with descriptor ( (1, 11)), and undefined elements, are ascribed to <tt>p</tt> and to <tt>q</tt>.}

<p>
<a name=442c></a>c) A "variant" of a value <i>V</i>, for a mode <i>M</i>, is a value <i>W</i> acceptable to {<a href="report_1.html#2136d">2.1.3.6.d</a>} <i>M</i>, and determined as follows:
<br>
Case A: <i>M</i> is some <b>'structured with FIELDS mode'</b>:
<ul>
For each <b>'MODE field TAG'</b> enveloped by <b>'FIELDS'</b>, 
<ul>
<li>the field selected by <b>'TAG'</b> in <i>W</i> is a variant, for <b>'MODE'</b>, of the field selected by <b>'TAG'</b> in <i>V</i>;
</ul>
</ul>
Case B: <i>M</i> is some <b>'FLEXETY ROWS of MODE1'</b>:
<ul>
<li>the descriptor of <i>W</i> is that of <i>V</i>;
<li>each element of <i>W</i> is a variant, for <b>'MODE1'</b>, of some element of <i>V</i>;
</ul>
Other Cases:
<ul>
<li><i>W</i> is any value acceptable to <i>M</i>.
</ul>

<p>
<a name=442d></a>d) The yield of an <b>actual-routine-declarer</b> is some routine {whose mode is of no relevance}.

<h3>
<a name=45></a>4.5. Operation declarations
</h3>

<p>
{<b>Operation-declarations</b>  provide <b>defining-operators</b>.
<br>
Example:
<br>
<tt>OP MC = (REAL a, b) REAL: (3 &times; a &lt; b | a | b )</tt>.
<br>
Unlike the case with, e.g., <b>identifier-declarations</b>, more than one <b>operation-declaration</b> involving the same <b>TAO-token</b> may occur in the same reach; e.g., the previous example may very well be in the same reach as
<br>
<tt>OP MC = (COMPL carthy, john) COMPL: (random &lt; .5 | carthy |  john);</tt>
<br>
the <b>operator</b> <tt>MC</tt> is then said to be "overloaded".}

<h3>
<a name=451></a>4.5.1. Syntax
</h3>

<p>
<a name=451A></a>A) <b>PRAM :: DUO ;  MONO.</b>
<br>
<a name=451B></a>B) <b>TAO :: TAD ; TAM.</b>
<br>
<a name=451a></a>a) <b>NEST MODINE operation declaration of DECS</b> {<a href="report_2.html#411a">41a</a>}  <b>: operator</b> {<a href="report_4.html#941d">94d</a>}  <b>token, formal MODINE NEST plan</b> {b, <a href="report_2.html#461p">46p</a>, -}<b>, NEST MODINE operation joined definition of DECS</b> {<a href="report_2.html#411b">41b, c</a>}  <b>.</b>
<br>
<a name=451b></a>b) <b>formal routine NEST plan {a} : EMPTY.</b>
<br>
<a name=451c></a>c) <b>NEST MODINE operation definition of PRAM TAO</b> {<a href="report_2.html#411c">41c</a>}  <b>: PRAM NEST defining operator with TAO</b> {<a href="report_2.html#481a">48a</a>}  <b>, is defined as</b> {<a href="report_4.html#941d">94d</a>}  <b>token, PRAM NEST source for MODINE</b> {<a href="report_2.html#441d">44d</a>}  <b>.</b>

<p>
<pre>
{Examples:
a) OP OR = (BOOL a, b) BOOL: (a | TRUE | b)
c) OR = (BOOL a, b) BOOL: (a | TRUE | b) }
</pre>

<h3>
<a name=452></a>4.5.2. Semantics
</h3>

<p>
<a name=452a></a>a) The elaboration of an <b>operation-declaration</b> consists of the collateral elaboration of its constituent <b>operation-definitions</b>.

<p>
<a name=452b></a>b) An <b>operation-definition</b> is elaborated by ascribing {<a href="report_2.html#482a">4.8.2.a</a>} the routine yielded by its <b>source-for-MODINE</b> to its <b>defining-operator</b>.

<h3>
<a name=46></a>4.6. Declarers
</h3>

<p>
{<b>Declarers</b> specify modes. A <b>declarer</b> is either a <b>declarator</b>, which explicitly constructs a mode, or an <b>applied-mode-indication</b>, which stands for some <b>declarator</b> by way of a <b>mode-declaration</b>. Declarators are built from <tt>VOID</tt>, <tt>INT</tt>, <tt>REAL</tt>, <tt>BOOL</tt> and <tt>CHAR</tt>  {<a href="report_5.html#A22">10.2.2</a>}, with the assistance of other <b>symbols</b> such as <tt>REF</tt>,  <tt>STRUCT</tt>, <tt>[ ]</tt>, <tt>PROC</tt>, and <tt>UNION</tt>. For example,  <tt>PROC (REAL)BOOL</tt> specifies the mode <b>'procedure with real parameter yielding boolean'</b>.

<p>
<b>Actual-declarers</b>, used typically in <b>generators</b>, require the presence of bounds. <b>Formal-declarers</b>, used typically in <b>formal-parameters</b> and <b>casts</b>, are without bounds. The <b>declarer</b> following a <tt>ref</tt> is always <b>'virtual'</b>; it may then specify a <b>'flexible ROWS of MODE'</b>, because flexibility is a property of names. Since <b>actual-declarers</b> follow an implicit <b>'reference to'</b> in <b>generators</b>, they may also specify <b>'flexible ROWS of MODE'</b>.}

<h3>
<a name=461></a>4.6.1. Syntax
</h3>


<p>
<a name=461A></a>A) <b>VICTAL :: VIRACT ;  formal.</b>
<br>
<a name=461B></a>B) <b>VIRACT :: virtual ; actual.</b>
<br>
<a name=461C></a>C) <b>MOIDS :: MOID ; MOIDS MOID.</b>
<br>
<a name=461a></a>a) <b>VIRACT MOID NEST declarer</b> {c, e, g, h, <a href="report_2.html#5231a">523a, b</a>} <b>: VIRACT MOID NEST declarator</b> {c, d, g, h, o, s, -}<b>; MOID TALLY NEST applied mode indication with TAB</b> {<a href="report_2.html#481b">48b</a>  , -}<b>.</b>
<br>
<a name=461b></a>b) <b>formal MOID NEST declarer</b> {e, h, p, r, u, <a href="report_2.html#341k">34k</a> , <a href="report_2.html#441a">44a</a>, <a href="report_2.html#5411a">541a, b, e</a>, <a href="report_2.html#5511a">551a</a>}  <b>: where MOID deflexes to MOID</b> {<a href="report_2.html#471a">47a, b, c</a>  , -}<b>, formal MOID NEST declarator</b> {c, d, h, o, s, -}<b>; MOID1 TALLY NEST applied mode indication with TAB</b> {<a href="report_2.html#481b">48b</a>  , -}<b>, where MOID1 deflexes to MOID</b> {<a href="report_2.html#471a">47a, b, c</a>  , -}<b>.</b>
<br>
<a name=461c></a>c) <b>VICTAL reference to MODE NEST declarator</b> {a, b, <a href="report_2.html#421c">42c</a>}  <b>: reference to</b> {<a href="report_4.html#941d">94d</a>}  <b>token, virtual MODE NEST declarer {a}.</b>
<br>
<a name=461d></a>d) <b>VICTAL structured with FIELDS mode NEST declarator</b> {a, b, <a href="report_2.html#421c">42c</a>}  <b>: structure</b> {<a href="report_4.html#941d">94d</a>}  <b>token, VICTAL FIELDS NEST portrayer of FIELDS</b> {e}<b> brief pack.</b>
<br>
<a name=461e></a>e) <b>VICTAL FIELDS NEST portrayer of FIELDS1</b> {d, e}<b> :  VICTAL MODE NEST declarer</b> {a, b}<b>, NEST MODE FIELDS joined definition of FIELDS1</b> {<a href="report_2.html#411b">41b, c</a>}  <b>; where (FIELDS1) is (FIELDS2 FIELDS3), VICTAL MODE NEST declarer</b> {a, b}<b>, NEST MODE FIELDS joined definition of FIELDS2</b> {<a href="report_2.html#411b">41b, c</a>}  <b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, VICTAL FIELDS NEST portrayer of FIELDS3</b> {e}<b>.</b>
<br>
<a name=461f></a>f) <b>NEST MODE FIELDS definition of MODE field TAG</b> {<a href="report_2.html#411c">41c</a>}  <b>: MODE field FIELDS defining field selector with TAG</b> {<a href="report_2.html#481c">48c</a>}  <b>.</b>
<br>
<a name=461g></a>g) <b>VIRACT flexible ROWS of MODE NEST declarator</b> {a, <a href="report_2.html#421c">42c</a>}  <b>: flexible</b> {<a href="report_4.html#941d">94d</a>}  <b>token, VIRACT ROWS of MODE NEST declarer {a}.</b>
<br>
<a name=461h></a>h) <b>VICTAL ROWS of MODE NEST declarator</b> {a, b, <a href="report_2.html#421c">42c</a>}  <b>: VICTAL ROWS NEST rower</b> {i, j, k, l}<b> STYLE bracket, VICTAL MODE NEST declarer</b> {a, b}<b>.</b>
<br>
<a name=461i></a>i) <b>VICTAL row ROWS NEST rower</b> {h, i}<b> : VICTAL row NEST rower</b> {j, k, l}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, VICTAL ROWS NEST rower</b> {i, j, k, l}<b>.</b>
<br>
<a name=461j></a>j) <b>actual row NEST rower</b> {h, i}<b> : NEST lower bound</b> {m}<b>, up to</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST upper bound</b> {n}<b>; NEST upper bound</b> {n}<b>.</b>
<br>
<a name=461k></a>k) <b>virtual row NEST rower</b> {h, i}<b> : up to</b> {<a href="report_4.html#941f">94f</a>}  <b>token option.</b>
<br>
<a name=461l></a>l) <b>formal row NEST rower</b> {h, i}<b> : up to</b> {<a href="report_4.html#941f">94f</a>}  <b>token option.</b>
<br>
<a name=461m></a>m) <b>NEST lower bound</b> {j, <a href="report_2.html#5321f">532f, g</a>} <b>: meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=461n></a>n) <b>NEST upper bound</b> {j, <a href="report_2.html#5321f">532f</a>}  <b>: meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=461o></a>o) <b>VICTAL PROCEDURE NEST declarator</b> {a, b, <a href="report_2.html#421c">42c</a>}  <b>: procedure</b> {<a href="report_4.html#941d">94d</a>}  <b>token, formal PROCEDURE NEST plan</b> {p}<b>.</b>
<br>
<a name=461p></a>p) <b>formal procedure PARAMETY yielding MOID NEST plan</b> {o, <a href="report_2.html#451a">45a</a>}  <b>: where (PARAMETY) is (EMPTY), formal MOID NEST declarer</b> {b}<b>; where (PARAMETY) is (with PARAMETERS), PARAMETERS NEST joined declarer</b> {q, r}<b>  brief pack, formal MOID NEST declarer</b> {b}<b>.</b>
<br>
<a name=461q></a>q) <b>PARAMETERS PARAMETER NEST joined declarer</b> {p, q}<b>  : PARAMETERS NEST joined declarer</b> {q, r}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, PARAMETER NEST joined declarer</b> {r}<b>.</b>
<br>
<a name=461r></a>r) <b>MODE parameter NEST joined declarer</b> {p, q}<b> :  formal MODE NEST declarer</b> {b}<b>.</b>
<br>
<a name=461s></a>s) <b>VICTAL union of MOODS1 MOOD1 mode NEST declarator</b> {a, b, <a href="report_2.html#421c">42c</a>}  <b>: unless EMPTY with MOODS1 MOOD1 incestuous</b> {<a href="report_2.html#471f">47f</a>}  <b>, union of</b> {<a href="report_4.html#941d">94d</a>}  <b>token, MOIDS NEST joined declarer</b> {t, u}<b> brief pack, where MOIDS ravels to MOODS2</b> {<a href="report_2.html#471g">47g</a>}  <b>and safe MOODS1 MOOD1 subset of safe MOODS2</b> {<a href="report_3.html#731l">73l</a>}  <b>and safe MOODS2 subset of safe MOODS1 MOOD1</b> {<a href="report_3.html#731l">73l, m</a>}  <b>.</b>
<br>
<a name=461t></a>t) <b>MOIDS MOID NEST joined declarer</b> {s, t}<b> : MOIDS NEST joined declarer</b> {t, u}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, MOID NEST joined declarer</b> {u}<b>.</b>
<br>
<a name=461u></a>u) <b>MOID NEST joined declarer</b> {s, t}<b> : formal MOID NEST declarer</b> {b}<b>.</b>

<P>
<pre>
{Examples:
a) [1 : n] REAL &bull; PERSON 
b) [ &nbsp; ] REAL &bull; STRING
c) REF REAL
d) STRUCT (INT age, REF PERSON father, son)
e) REF PERSON father, son &bull; INT age, REF PERSON father, son
f) age 
g) FLEX [1 : n] REAL
h) [1 : m, 1 : n] REAL 
i) 1 : m, 1 : n
j) 1 : n 
k) :
l) :                                      
m) 1
n) n 
o) PROC (BOOL, BOOL) BOOL
p) (BOOL, BOOL) BOOL q) BOOL, BOOL
r) BOOL s) UNION (INT, CHAR)
t) INT, CHAR u) INT }
</pre>

<p>
{For <b>actual-MOID-TALLY-declarers</b>, see <a href="report_2.html#421c">4.2.1.c</a>  ; for <b>actual-routine-declarers</b>, see <a href="report_2.html#441b">4.4.1.b</a>  .
<br>
There are no <b>declarers</b> specifying modes such as <b>'union of integral union of integral real mode mode'</b> or <b>'union of integral real integral mode'</b>. The <b>declarers</b> <tt>UNION (INT, UNION (INT, REAL))</tt> and <tt>UNION (INT, REAL, INT)</tt> may indeed be written, but in both cases the mode specified is <b>'union of integral real mode'</b> (which can as well be spelled <b>'union of real integral mode'</b>).}

<h3>
<a name=462></a>4.6.2. Semantics
</h3>

<p>
<a name=462a></a>a) The yield <i>W</i>  of an <b>actual-MODE-declarer</b> <i>D</i>, in an environ <i>E</i>, is determined as follows:
<br>
If <b>'MODE'</b> is some <b>'STOWED'</b>, 
<br>
then
<ul>
<li> let <i>D1</i> in <i>E1</i> be "developed" {c} from <i>D</i> in <i>E</i>;
<li> <i>W</i> is the yield of {the <b>declarator</b>} <i>D1</i> in an environ established {locally, see <a href="report_2.html#322b">3.2.2.b</a>} upon <i>E</i> and around <i>E1</i>;
</ul>
otherwise, 
<ul>
<li><i>W</i> is any value {acceptable to <b>'MODE'</b>} .
</ul>

<p>
<a name=462b></a>b) The yield <i>W</i> of an <b>actual-STOWED-declarator</b>  <i>D</i> is determined as follows:
<br>
<a name=462cA></a>
Case A: <b>'STOWED'</b> is some <b>'structured with FIELDS mode'</b>:
<ul>
<li> the constituent <b>declarers</b> of <i>D</i> are elaborated collaterally;
<li> each field of <i>W</i> is a variant {<a href="report_2.html#442c">4.4.2.c</a>}
</ul>
<ol type=i>
<li> of the yield of the last constituent <b>MODE-declarer</b> of <i>D</i>  occurring before the constituent <b>defining-field-selector</b> of <i>D</i>  selecting {<a href="report_1.html#215g">2.1.5.g</a>} that field, 
<li> for that <b>'MODE'</b>;
</ol>
<br>
<a name=462cB></a>
Case B: <b>'STOWED'</b> is some <b>'ROWS of MODE'</b>:
<ul>
<li> all the constituent <b>lower-bounds</b> and <b>upper-bounds</b> of <i>D</i> and the <b>declarer</b> <i>D1</i> of <i>D</i> are elaborated collaterally;
<br>
For i = 1 ... n, where <i>n</i> is the number of <b>'row'</b>s contained in <b>'ROWS'</b>, 
<ul>
<li> let <i>l<sub>i</sub></i> be the yield of the <b>lower-bound</b>, if any, of the <i>i</i>-th constituent <b>row-rower</b> of <i>D</i>, and be 1 otherwise;
<li> let <i>u<sub>i</sub></i> be the yield of the <b>upper-bound</b> of that <b>row-rower</b>;
</ul>
<li> <i>W</i> is composed of
</ul>
<ol type=i>
<li> a descriptor ( (l<sub>1</sub>, u<sub>1</sub>), ...,  (l<sub>n</sub>, u<sub>n</sub>)), 
<li> variants of the yield of <i>D1</i>, for <b>'MODE'</b>;
</ol>
<br>
<a name=462cC></a>
Case C: <b>'STOWED'</b> is some <b>'flexible ROWS of MODE'</b>:
<ul>
<li> <i>W</i> is the yield of the <b>declarer</b> of <i>D</i>.
</ul>

<p>
<a name=462c></a>c) The scene <i>S</i> "developed from" an <b>actual-STOWED-declarer</b> <i>D</i> in an environ <i>E</i> is determined as follows:
<br>
If the visible direct descendent <i>D1</i> of <i>D</i> is a <b>mode-indication</b>, 
<br>
then
<ul>
<li> <i>S</i> is the scene developed from that yielded by <i>D1</i> in <i>E</i>;
</ul>
otherwise {D1 is a <b>declarator</b>} , 
<ul>
<li> <i>S</i> is composed of <i>D1</i> and <i>E</i>.
</ul>

<p>
<a name=462d></a>d) A given <b>MOID-declarer</b> "specifies" the mode <b>'MOID'</b>.

<h3>
<a name=47></a>4.7. Relationships between modes
</h3>

<p>
{Some modes must be deflexed because the mode of a value may not be flexible {<a href="report_1.html#2136b">2.1.3.6.b</a>}. Incestuous unions must be prevented in order to avoid ambiguities. A set of <b>'UNITED'</b>s and <b>'MOODS'</b>s may be ravelled by replacing all those <b>'UNITED'</b>s by their component <b>'MOODS'</b>s.}

<h3>
<a name=471></a>4.7.1. Syntax
</h3>

<p>
<a name=471A></a>A) <b>NONSTOWED :: PLAIN ;  REF to MODE ; PROCEDURE ; UNITED ; void.</b>
<br>
<a name=471B></a>B) <b>MOODSETY :: MOODS ; EMPTY.</b>
<br>
<a name=471C></a>C) <b>MOIDSETY :: MOIDS ; EMPTY.</b>
<br>
<a name=471a></a>a) <b>WHETHER NONSTOWED deflexes to NONSTOWED </b> {b, e, <a href="report_2.html#461b">46b</a> , <a href="report_2.html#5211c">521c</a>, <a href="report_3.html#621a">62a</a>, <a href="report_3.html#711n">71n</a>}  <b>: WHETHER true.</b>
<br>
<a name=471b></a>b) <b>WHETHER FLEXETY ROWS of MODE1 deflexes to ROWS of MODE2</b> {b, e, <a href="report_2.html#461b">46b</a> , <a href="report_2.html#5211c">521c</a>, <a href="report_3.html#621a">62a</a>, <a href="report_3.html#711n">71n</a>}  <b>: WHETHER MODE1 deflexes to MODE2</b> {a, b, c, -}<b>.</b>
<br>
<a name=471c></a>c) <b>WHETHER structured with FIELDS1 mode deflexes to structured with FIELDS2 mode</b> {b, e, <a href="report_2.html#461b">46b</a> , <a href="report_2.html#5211c">521c</a>, <a href="report_3.html#621a">62a</a>, <a href="report_3.html#711n">71n</a>}  <b>: WHETHER FIELDS1 deflexes to FIELDS2</b> {d, e, -}<b>.</b>
<br>
<a name=471d></a>d) <b>WHETHER FIELDS1 FIELD1 deflexes to FIELDS2 FIELD2</b> {c, d}<b> : WHETHER FIELDS1 deflexes to FIELDS2</b> {d, e, -}<b> and FIELD1 deflexes to FIELD2</b> {e, -}<b>.</b>
<br>
<a name=471e></a>e) <b>WHETHER MODE1 field TAG deflexes to MODE2 field TAG</b> {c, d}<b> : WHETHER MODE1 deflexes to MODE2</b> {a, b, c, -}<b>.</b>
<br>
<a name=471f></a>f) <b>WHETHER MOODSETY1 with MOODSETY2 incestuous</b> {f, <a href="report_2.html#461s">46s</a>}  <b>: where (MOODSETY2) is (MOOD MOODSETY3), WHETHER MOODSETY1 MOOD with MOODSETY3 incestuous</b> {f}<b> or MOOD is firm union of MOODSETY1 MOODSETY3 mode </b> {<a href="report_3.html#711m">71m</a>}  <b>; where (MOODSETY2) is (EMPTY), WHETHER false.</b>
<br>
<a name=471g></a>g) <b>WHETHER MOIDS ravels to MOODS</b> {g, <a href="report_2.html#461s">46s</a>}  <b>: where (MOIDS) is (MOODS), WHETHER true ; where (MOIDS) is (MOODSETY union of MOODS1 mode MOIDSETY), WHETHER MOODSETY MOODS1 MOIDSETY ravels to MOODS</b> {g}<b>.</b>

<p>
{A component mode of a union may not be firmly coerced to one of the other component modes or to the union of those others (rule f) for, otherwise, ambiguities could arise. For example, 
<pre>
UNION (REF INT, INT) (LOC INT)
</pre>
is ambiguous in that dereferencing may or may not occur before the uniting. Similarly, 
<pre>
MODE SZP = UNION (SZEREDI, PETER);
UNION (REF SZP, SZP) (LOC SZP)
</pre>
is ambiguous. Note that, because of ravelling (rule g), the mode specified by the <b>declarer</b> of the <b>cast</b> is more closely suggested by <tt>UNION (REF SZP, SZEREDI, PETER</tt>).}

<h3>
<a name=48></a>4.8. Indicators and field selectors
</h3>

<h3>
<a name=481></a>4.8.1. Syntax
</h3>

<p>
<a name=481A></a>A) <b>INDICATOR ::  identifier ; mode indication ; operator.</b>
<br>
<a name=481B></a>B) <b>DEFIED :: defining ; applied.</b>
<br>
<a name=481C></a>C) <b>PROPSETY :: PROPS ; EMPTY.</b>
<br>
<a name=481D></a>D) <b>PROPS :: PROP ; PROPS PROP.</b>
<br>
<a name=481E></a>E) <b>PROP :: DEC ; LAB ; FIELD.</b>
<br>
<a name=481F></a>F) <b>QUALITY :: MODE ; MOID TALLY ; DYADIC ; label ; MODE field.</b>
<br>
<a name=481G></a>G) <b>TAX :: TAG ; TAB ; TAD ; TAM.</b>
<br>
<a name=481a></a>a) <b>QUALITY NEST new PROPSETY1 QUALITY TAX PROPSETY2 defining INDICATOR with TAX </b> {<a href="report_2.html#321c">32c</a> , <a href="report_2.html#351b">35b</a>, <a href="report_2.html#421b">42b</a>, <a href="report_2.html#431b">43b</a>, <a href="report_2.html#441c">44c, f</a>, <a href="report_2.html#451c">45c</a>, <a href="report_2.html#5411f">541f</a>}  <b>: where QUALITY TAX independent PROPSETY1 PROPSETY2 </b> {<a href="report_3.html#711a">71a, b, c</a>} <b>, TAX</b> {<a href="report_4.html#9421A">942A, D, F, K</a>} <b>token.</b>
<br>
<a name=481b></a>b) <b>QUALITY NEST applied INDICATOR with TAX </b> {<a href="report_2.html#421c">42c</a> , <a href="report_2.html#461a">46a, b</a>, <a href="report_2.html#51D">5D</a>, <a href="report_2.html#5421a">542a, b</a>, <a href="report_2.html#5441a">544a</a>}  <b>: where QUALITY TAX identified in NEST</b> {<a href="report_3.html#721a">72a</a>}  <b>, TAX</b> {<a href="report_4.html#9421A">942A, D, F, K</a>} <b>token.</b>
<br>
<a name=481c></a>c) <b>MODE field PROPSETY1 MODE field TAG PROPSETY2 defining field selector with TAG</b> {<a href="report_2.html#461f">46f</a>}  <b>: where MODE field TAG independent PROPSETY1 PROPSETY2</b> {<a href="report_3.html#711a">71a, b, c</a>} <b>, TAG </b> {<a href="report_4.html#9421A">942A</a>}  <b>token.</b>
<br>
<a name=481d></a>d) <b>MODE field FIELDS applied field selector with TAG</b> {<a href="report_2.html#5311a">531a</a>}  <b>: where MODE field TAG resides in FIELDS</b> {<a href="report_3.html#721b">72b, c</a>  , -}<b>, TAG</b> {<a href="report_4.html#9421A">942A</a>}  <b>token.</b>
<br>
<a name=481e></a>e) <b>*QUALITY NEST DEFIED indicator with TAX : QUALITY NEST DEFIED INDICATOR with TAX</b> {a, b}<b>.</b>
<br>
<a name=481f></a>f) <b>*MODE DEFIED field selector with TAG : MODE field FIELDS DEFIED field selector with TAG</b> {c, d}<b>.</b>

<p>
<pre>
{Examples:
a) x (in REAL x, y)
b) x (in x + y)
c) next (see <a href="report_1.html#112">1.1.2</a>)
d) next (in next OF draft) }
</pre>

<h3>
<a name=482></a>4.8.2. Semantics
</h3>

<p>
<a name=482a></a>a) When a value or a scene <i>V</i> is "ascribed" to a <b>QUALITY-defining-indicator-with-TAX</b>, in an environ <i>E</i>, then <b>'QUALITY TAX'</b> is made to access <i>V</i> inside the locale of <i>E</i> {<a href="report_1.html#212c">2.1.2.c</a>}.

<p>
<a name=482b></a>b) The yield <i>W</i> of a <b>QUALITY-applied-indicator-with-TAX</b> <i>I</i> in an environ <i>E</i>  composed of an environ <i>E1</i> and a locale <i>L</i> is determined as follows:   <DL compact>
<br>
If <i>L</i> corresponds to a <b>'DECSETY LABSETY'</b> which envelops {<a href="report_1.html#1141c">1.1.4.1.c</a>} that <b>'QUALITY TAX'</b>, 
<br>
then
<ul>
<i>W</i> is the value or scene, if any, accessed inside <i>L</i> by <b>'QUALITY TAX'</b> and, otherwise, is undefined;
</ul>
otherwise, <i>W</i> is the yield of <i>I</i> in <i>E1</i>.

<p>
{Consider the following <b>closed-clause</b>, which contains another one:
<pre>
BEGIN CO range 1 CO
   INT i = 421, INT a := 5, PROC p = VOID: print (a);
   BEGIN CO range 2 CO
      REAL a; a := i; p
   END
END.
</pre>
By the time <tt>a := i</tt> is encountered during the elaboration, two new environs have been created, one for each <b>range</b>. The <b>defining-identifier</b> <tt>i</tt> is first sought in the newer one,  <i>E2</i>, is not found there, and then is sought and found in the older one,  <i>E1</i>. The locale of <i>E1</i> corresponds to <b>'integral letter i reference to integral letter a procedure yielding void letter p'</b>. The yield of the <b>applied-identifier</b> <tt>i</tt> is therefore the value 421 which has been ascribed {a} to <b>'integral letter i'</b> inside the locale of <i>E1</i>. The yield of <tt>a</tt>, in <tt>a := i</tt>, however, is found from the locale of <i>E2</i>.

<p>
When <tt>p</tt> is called {<a href="report_2.html#5432b">5.4.3.2.b</a>}, its <b>unit</b> is elaborated in an environ <i>E3</i> established around <i>E1</i> but upon <i>E2</i> {<a href="report_2.html#322b">3.2.2.b</a>}. This means that, for scope purposes, <i>E3</i> is newer than <i>E2</i>, but the component environ of <i>E3</i> is <i>E1</i>. When <tt>a</tt> comes to be printed, it is the yield 5 of the <b>reference-to-integral-identifier</b> a declared in the outer <b>range</b> that is obtained.

<p>
Thus, the meaning of an <b>indicator</b> applied but not defined within a routine is determined by the context in which the routine was created, rather than that in which it is called.}

<h3>
<a name=5></a>5. Units
</h3>

<p>
{<b>Units</b> are used to program the more primitive actions or to put into one single piece the larger constructs of Chapter 3.
<br>
<b>NOTION-coercees</b> are the results of coercion (Chapter 6), but <b>hips</b> are not; in the case of <b>ENCLOSED-clauses</b>, any coercions needed are performed inside them.
<br>
The syntax below implies, for example, that <tt>text OF draft + "the end"</tt> is parsed as <tt> (text OF draft) + "the end"</tt> since a <b>selection</b> is a <b>'SECONDARY'</b> whereas a <b>formula</b> is a <b>'TERTIARY'</b>.}

<h3>
<a name=51></a>5.1. Syntax
</h3>

<p>
<a name=51A></a>A) <b>UNIT</b> {<a href="report_2.html#321d">32d</a>}  <b>:: assignation</b> {<a href="report_2.html#5211a">521a</a>}  <b>coercee ; identity relation</b> {<a href="report_2.html#5221a">522a</a>}  <b>coercee ; routine text</b> {<a href="report_2.html#5411a">541a, b</a>} <b>coercee ; jump</b> {<a href="report_2.html#5441a">544a</a>}  <b>; skip</b> {<a href="report_2.html#5521a">552a</a>}  <b>; TERTIARY</b> {B}<b>.</b>
<br>
<a name=51B></a>B) <b>TERTIARY</b> {A, <a href="report_2.html#5211b">521b</a>  , <a href="report_2.html#5221a">522a</a>}  <b>:: ADIC formula</b> {<a href="report_2.html#5421a">542a, b</a>} <b>coercee ; nihil</b> {<a href="report_2.html#5241a">524a</a>}  <b>; SECONDARY</b> {C}<b>.</b>
<br>
<a name=51C></a>C) <b>SECONDARY</b> {B, <a href="report_2.html#5311a">531a</a>  , <a href="report_2.html#5421c">542c</a>}  <b>:: LEAP generator</b> {<a href="report_2.html#5231a">523a</a>}  <b>coercee ; selection</b> {<a href="report_2.html#5311a">531a</a>}  <b>coercee ; PRIMARY</b> {D}<b>.</b>
<br>
<a name=51D></a>D) <b>PRIMARY</b> {C, <a href="report_2.html#5321a">532a</a>  , <a href="report_2.html#5431a">543a</a>}  <b>:: slice</b> {<a href="report_2.html#5321a">532a</a>}  <b>coercee ; call</b> {<a href="report_2.html#5431a">543a</a>}  <b>coercee ; cast</b> {<a href="report_2.html#5511a">551a</a>}  <b>coercee ; denoter</b> {<a href="report_4.html#801a">80a</a>}  <b>coercee ; format text</b> {<a href="report_5.html#A3411a">A341a</a>} <b>coercee ; applied identifier with TAG</b> {<a href="report_2.html#481b">48b</a>}  <b>coercee ; ENCLOSED clause</b> {<a href="report_2.html#311a">31a</a> , <a href="report_2.html#331a">33a, c, d, e</a>, <a href="report_2.html#341a">34a</a>, <a href="report_2.html#351a">35a</a>}  <b>.</b>

<p>
{The hyper-rules for <b>'SORT MOID FORM coercee'</b> are given in <a href="report_3.html#611a">6.1.1.a, b, c, d</a>  and e, the entry rules of the coercion syntax. When the coercion syntax is invoked for some <b>'SORT MOID FORM coercee'</b>, it will eventually return to a rule in this chapter for some <b>'MOID1 FORM'</b> (blind alleys apart). It is the cross-reference to that rule that is given in the metaproduction rules above. No other visible descendent has been produced in the meantime; the coercion syntax merely transforms <b>'MOID'</b> into <b>'MOID1'</b> for semantical purposes.}

<p>
<a name=51a></a>a) <b>*SOME hip : SOME jump</b> {<a href="report_2.html#5441a">544a</a>}  <b>; SOME skip</b> {<a href="report_2.html#5521a">552a</a>}  <b>; SOME nihil</b> {<a href="report_2.html#5241a">524a</a>}  <b>.</b> {The mode of a <b>hip</b> is always that required, a posteriori, by its context, and its yield is acceptable to that mode. Since any mode is so easily accommodated, no coercion is permitted.}

<h3>
<a name=52></a>5.2. Units associated with names
</h3>

<p>
{Names may be assigned to {<a href="report_2.html#521">5.2.1</a>}, compared with other names {<a href="report_2.html#522">5.2.2</a>}  and created {<a href="report_2.html#523">5.2.3</a>}.}

<h3>
<a name=521></a>5.2.1. Assignations
</h3>

<p>
{In <b>assignations</b>, a value is  "assigned", to a name. <i>E</i>.g., in <tt>x := 3.14</tt>, the real number yielded by the <b>source</b> <tt>3.14</tt> is assigned to the name yielded by the <b>destination</b> <tt>x</tt>.}

<h3>
<a name=5211></a>5.2.1.1. Syntax
</h3>


<p>
<a name=5211a></a>a) <b>REF to MODE NEST assignation</b> {<a href="report_2.html#51A">5A</a>} <b>:  REF to MODE NEST destination</b> {b}<b>, becomes</b> {<a href="report_4.html#941c">94c</a>}  <b>token, MODE NEST source</b> {c}<b>.</b>
<br>
<a name=5211b></a>b) <b>REF to MODE NEST destination {a} : soft REF to MODE NEST TERTIARY</b> {<a href="report_2.html#51B">5B</a>}  <b>.</b>
<br>
<a name=5211c></a>c) <b>MODE1 NEST source</b> {a, <a href="report_2.html#441d">44d</a>}  <b>: strong MODE2 NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>, where MODE1 deflexes to MODE2</b> {<a href="report_2.html#471a">47a, b, c</a>, -}<b>.</b>

<p>
<pre>
{Examples:
a) x := 3.14
b) x
c) 3.14 }
</pre>

<h3>
<a name=5212></a>5.2.1.2. Semantics
</h3>

<p>
<a name=5212a></a>a) An <b>assignation</b> <i>A</i> is elaborated as follows:
<ul>
<li> let <i>N</i> and <i>W</i> be the {collateral} yields {a name and another value} of the <b>destination</b> and <b>source</b> of <i>A</i>;
<li> <i>W</i> is assigned to {b}<i>N</i>;
<li> the yield of <i>A</i> is <i>N</i>.
</ul>

<p>
<a name=5212b></a>b) A value <i>W</i> is "assigned to" a name <i>N</i>, whose mode is some <b>'REF to MODE'</b>, as follows:
<br>
It is required that
<ul>
<li> <i>N</i> be not nil, and that
<li> <i>W</i> be not newer in scope than <i>N</i>;
</ul>
<a name=5212cA></a>
Case A: <b>'MODE'</b> is some <b>'structured with FIELDS mode'</b>:
<ul>
For each <b>'TAG'</b> selecting a field in <i>W</i>, 
<li> that field is assigned to the subname selected by <b>'TAG'</b> in <i>N</i>;
</ul>
<a name=5212cB></a>
Case B: <b>'MODE'</b> is some <b>'ROWS of MODE1'</b>:
<ul>
<li> let <i>V</i> be the {old} value referred to by <i>N</i>;
<li> it is required that the descriptors of <i>W</i> and <i>V</i> be identical;
</ul>
<ul>
For each index <i>I</i> selecting an element in <i>W</i>, 
<li> that element is assigned to the subname selected by <i>I</i> in <i>N</i>;
</ul>
<a name=5212cC></a>
Case C: <b>'MODE'</b> is some <b>'flexible ROWS of MODE1'</b>:
<ul>
<li> let <i>V</i> be the {old} value referred to by <i>N</i>;
<li> <i>N</i> is made to refer to a multiple value composed of
</ul>
<ol type=i>
<li> the descriptor of <i>W</i>, 
<li> variants {<a href="report_2.html#442c">4.4.2.c</a>} of some element {possibly a ghost element} of <i>V</i>;
</ol>
<ul>
<li> <i>N</i> is endowed with subnames {<a href="report_1.html#2134g">2.1.3.4.g</a>};
</ul>
For each index <i>I</i> selecting an element in <i>W</i>, 
<ul>
<li> that element is assigned to the subname selected by <i>I</i> in <i>N</i>;
</ul>
Other Cases {e.g., where <b>'MODE'</b> is some <b>'PLAIN'</b> or some <b>'UNITED'</b>} :
<ul>
<li> <i>N</i> is made to refer {<a href="report_1.html#2132a">2.1.3.2.a</a>} to <i>W</i>.
</ul>

<p>
{Observe how, given <tt>FLEX [1: 0] [1: 3] INT flexfix</tt>, the presence of the ghost element {<a href="report_1.html#2134c">2.1.3.4.c</a>} ensures that the meaning of <tt>flexfix := LOC [1: 1] [1: 3] INT</tt> is well defined, but that of <tt>flexfix := LOC [1: 1] [1: 4] INT</tt> is not, since the bound pairs of the second dimension are different.}

<h3>
<a name=522></a>5.2.2. Identity relations
</h3>

<p>
{<b>Identity-relations</b> may be used to ask whether two names of the same mode are the same.
<br>
E.g., after the <b>assignation</b> <tt>draft := ("abc", NIL)</tt>, the <b>identity-relation</b> <tt>next OF draft :=: REF BOOK (NIL)</tt> yields <tt>true</tt>. However, <tt>next OF draft :=: NIL</tt> yields <tt>false</tt>  because it is equivalent to <tt>next OF draft :=: REF REF BOOK (NIL)</tt>; the yield of <tt>next OF draft</tt>, without any coercion, is the name referring to the second field of the structured value referred to by the value of <tt>draft</tt> and, hence, is not nil.}

<h3>
<a name=5221></a>5.2.2.1. Syntax
</h3>

<p>
<a name=5221a></a>a) <b>boolean NEST identity relation</b> {<a href="report_2.html#51A">5A</a>} <b>:  where soft balances SORT1 and SORT2</b> {<a href="report_2.html#321f">32f</a>}  <b>, SORT1 reference to MODE NEST TERTIARY1</b> {<a href="report_2.html#51B">5B</a>} <b>, identity relator</b> {b}<b>, SORT2 reference to MODE NEST TERTIARY2</b> {<a href="report_2.html#51B">5B</a>}  <b>.</b>
<br>
<a name=5221b></a>b) <b>identity relator {a} : is</b> {<a href="report_4.html#941f">94f</a>}  <b>token ; is not</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>

<p>
<pre>
{Examples:
a) next OF draft:=: REF BOOK (NIL)
b) :=: &bull; :&ne;: }
</pre>

<p>
{Observe that <tt>a1 [i] :=: a1  [j]</tt> is not produced by this syntax. The comparison, by an <b>identity-relation</b>, of transient names {<a href="report_1.html#2136c">2.1.3.6.c</a>} is thus prevented.}

<h3>
<a name=5222></a>5.2.2.2. Semantics
</h3>

<p>
The yield <i>W</i> of an <b>identity-relation</b> <i>I</i> is determined as follows:
<ul>
<li> let <i>N1</i> and <i>N2</i> be the {collateral} yields of the <b>'TERTIARY'</b>s of <i>I</i>;
</ul>
<a name=5222cA></a>
Case A: The <b>token</b> of the <b>identity-relator</b> of <i>I</i> is an <b>is-token</b>:
<ul>
<li> <i>W</i> is <tt>true</tt> if {the name} <i>N1</i> is the same as <i>N2</i>, and is <tt>false</tt> otherwise;
</ul>
<a name=5222cB></a>
Case B: The <b>token</b> of the <b>identity-relator</b> of <i>I</i> is an <b>is-not-token</b>:
<ul>
<li> <i>W</i> is <tt>true</tt> if <i>N1</i> is not the same as <i>N2</i>, and is <tt>false</tt>, otherwise.
</ul>

<h3>
<a name=523></a>5.2.3. Generators
</h3>

<div align=right> {And as imagination bodies forth<br>
The forms of things unknown, the poet's pen<br>
Turns them to shapes, and gives to airy nothing<br>
A local habitation and a name.<br>
A Midsummer-night's Dream, William Shakespeare.}
</div>

<p>
{The elaboration of a <b>generator</b>, e.g., <tt>LOC REAL</tt> in <tt>xx := LOC REAL := 3.14</tt>, or of a <b>sample-generator</b>, e.g., <tt>[1 : n] CHAR</tt> in <tt>[1: n] CHAR u, v;</tt>, involves the creation of a name, i.e., the reservation of storage.
<br>
The use of a <b>local-generator</b> implies (with most implementations) the reservation of storage on a run-time stack, whereas <b>heap-generators</b> imply the reservation of storage in another region, termed the "heap", in which garbage-collection techniques may be used for storage retrieval. Since this is less efficient, <b>local-generators</b> are preferable; this is why only <tt>LOC</tt> may be omitted from <b>sample-generators</b> of <b>variable-declarations</b>.}

<h3>
<a name=5231></a>5.2.3.1. Syntax
</h3>

<p>
{<b>LEAP :: local ; heap primal.</b>}
<br>
<a name=5231a></a>a) <b>reference to MODE NEST LEAP generator</b> {<a href="report_2.html#51C">5C</a>} <b>:  LEAP</b> {<a href="report_4.html#941d">94d</a>  , -}<b> token, actual MODE NEST declarer</b> {<a href="report_2.html#461a">46a</a>}  <b>.</b>
<br>
<a name=5231b></a>b) <b>reference to MODINE NEST LEAP sample generator</b> {<a href="report_2.html#441e">44e</a>}  <b>: LEAP</b> {<a href="report_4.html#941d">94d</a>  , -}<b> token, actual MODINE NEST declarer</b> {<a href="report_2.html#441b">44b</a>, <a href="report_2.html#461a">46a</a>}  <b>; where (LEAP) is (local), actual MODINE NEST declarer</b> {<a href="report_2.html#441b">44b</a> , <a href="report_2.html#461a">46a</a>}  <b>.</b>

<p>
<pre>
{Examples:
a) LOC REAL
b) LOC REAL &bull; REAL }
</pre>
{There is no representation for the <b>primal-symbol</b> (see <a href="report_4.html#94a">9.4.a</a>).}

<h3>
<a name=5232></a>5.2.3.2. Semantics
</h3>

<p>
<a name=5232a></a>a) The yield <i>W</i> of a <b>LEAP-generator</b> or <b>LEAP-sample-generator</b> <i>G</i>, in an environ <i>E</i>, is determined as follows:
<ul>
<li> <i>W</i> is a newly created name which is made to refer {<a href="report_1.html#2132a">2.1.3.2.a</a>} to the yield in <i>E</i> of the <b>actual-declarer</b> {<a href="report_2.html#442d">4.4.2.d</a>  , <a href="report_2.html#462a">4.6.2.a</a>}  of <i>G</i>;
<li> <i>W</i> is equal in scope to the environ <i>E1</i> determined as follows:
<ul>
<a name=5232cA></a>
Case A: <b>'LEAP'</b> is <b>'local'</b>:
<ul>
<li> E1</i> is the "local environ" {b} accessible from <i>E</i>;
</ul>
<a name=5232cB></a>
Case B: <b>'LEAP'</b> is <b>'heap'</b>:
<ul>
<li> <i>E1</i> is {the first environ created during the elaboration of the <b>particular-program</b>, which is} such that
</ul>
<ol type=i>
<li> the primal environ {<a href="report_1.html#222a">2.2.2.a</a>} is the environ of the environ of the environ of the environ of <i>E1</i> {sic}, and
<li> <i>E1</i> is, or is older than, <i>E</i>;
</ol>
<a name=5232cC></a>
Case C: <b>'LEAP'</b> is <b>'primal'</b>:
<ul>
<li> <i>E1</i> is the primal environ;
</ul>
</ul>
<li> if <i>W</i> is a stowed name {<a href="report_1.html#2132b">2.1.3.2.b</a>}, then <i>W</i> is endowed with subnames {<a href="report_1.html#2133e">2.1.3.3.e</a>  , <a href="report_1.html#2134g">2.1.3.4.g</a>}.
</ul>

<p>
{The only examples of <b>primal-generators</b> occur in the <b>standard-</b>  and <b>system-preludes</b> {<a href="report_5.html#A311h">10.3.1.1.h</a>  , <a href="report_5.html#A314b">10.3.1.4.b, n, o</a> , <a href="report_5.html#A41a">10.4.1.a</a>}.
<br>
When <i>G</i> is a <b>reference-to-routine-sample-generator</b>, the mode of <i>W</i> is of no relevance.}

<p>
<a name=5232b></a>b) The "local environ" accessible from an environ <i>E</i>  is an environ <i>E1</i> determined as follows:
<ul>
If <i>E</i> is "nonlocal" {<a href="report_2.html#322b">3.2.2.b</a>}, 
<br>
then <i>E1</i> is the local environ accessible from the environ of <i>E</i>;
<br>
otherwise, <i>E1</i> is <i>E</i>.
</ul>

<p>
{An environ is nonlocal if it has been established according to a <b>serial-clause</b> or <b>enquiry-clause</b> which contains no constituent <b>mode-</b>,  <b>identifier-</b>, or <b>operation-declaration</b>, or according to a <b>for-part</b> {<a href="report_2.html#351b">3.5.1.b</a>} or a <b>specification</b> {<a href="report_2.html#341j">3.4.1.j, k</a>}.}

<h3>
<a name=524></a>5.2.4. Nihils
</h3>

<h3>
<a name=5241></a>5.2.4.1. Syntax
</h3>

<p>
<a name=5241a></a>a) <b>strong reference to MODE NEST nihil</b> {<a href="report_2.html#51B">5B</a>} <b>:  nil</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>

<p>
<pre>
{Example:
a) NIL }
</pre>

<h3>
<a name=5242></a>5.2.4.2. Semantics
</h3>

<p>
The yield of a <b>nihil</b> is a nil name.

<h3>
<a name=53></a>5.3. Units associated with stowed values
</h3>
<DIV align=right>
{In Flanders fields the poppies blow<br>
Between the crosses, row on row, ...<br>
In Flanders Fields, John McCrae.}
</div>

<p>
{The fields of structured values may be obtained by <b>selections</b> {<a href="report_2.html#531">5.3.1</a>}  and the elements of multiple values by <b>slices</b> {<a href="report_2.html#532">5.3.2</a>};  the corresponding effects on stowed names are defined also.}

<h3>
<a name=531></a>5.3.1. Selections
</h3>

<p>
{A <b>selection</b> selects a field from a structured value or (if it is a "multiple selection") it selects a multiple value from a multiple value whose elements are structured values. For example, <tt>re OF z</tt> selects the first real field (usually termed the real part) of the yield of <tt>z</tt>. If <tt>z</tt> yields a name, then <tt>re OF z</tt> also yields a name, but if <tt>g</tt> yields a complex value, then <tt>re OF g</tt> yields a real value, not a name referring to one.}

<h3>
<a name=5311></a>5.3.1.1. Syntax
</h3>

<p>
<a name=5311A></a>A) <b>REFETY :: REF to  ; EMPTY.</b>
<br>
<a name=5311B></a>B) <b>REFLEXETY :: REF to ; REF to flexible ; EMPTY.</b>  {<b>REF :: reference ; transient reference.</b>}
<br>
<a name=5311a></a>a) <b>REFETY MODE1 NEST selection</b> {<a href="report_2.html#51C">5C</a>} <b>:  MODE1 field FIELDS applied field selector with TAG</b> {<a href="report_2.html#481d">48d</a>}  <b>, of </b> {<a href="report_4.html#941f">94f</a>}  <b>token, weak REFETY structured with FIELDS mode NEST SECONDARY</b> {<a href="report_2.html#51C">5C</a>} <b>;  where (MODE1) is (ROWS of MODE2), MODE2 field FIELDS applied field selector with TAG</b> {<a href="report_2.html#481d">48d</a>}  <b>, of</b> {<a href="report_4.html#941f">94f</a>}  <b>token, weak REFLEXETY ROWS of structured with FIELDS mode NEST SECONDARY</b> {<a href="report_2.html#51C">5C</a>} <b>, where (REFETY) is derived from (REFLEXETY)</b> {b, c, -}<b>.</b>
<br>
<a name=5311b></a>b) <b>WHETHER (transient reference to) is derived from (REF to flexible)</b> {a, <a href="report_2.html#5321a">532a</a>  , <a href="report_3.html#661a">66a</a>}  <b>: WHETHER true.</b>
<br>
<a name=5311c></a>c) <b>WHETHER (REFETY) is derived from (REFETY)</b> {a, <a href="report_2.html#5321a">532a</a>  , <a href="report_3.html#661a">66a</a>}  <b>: WHETHER true.</b>

<p>
<pre>
{Examples:
re OF z &bull; re OF z1 }
</pre>

<p>
{The mode of <tt>re OF z</tt> begins with <b>'reference to'</b> because that of <tt>z</tt> does.
<br>
Example:
<pre>
INT age := 7; STRUCT (BOOL sex, INT age) jill;
age OF jill :=  age;
</pre>
Note that the <b>destination</b> <tt>age OF jill</tt> yields a name because <tt>jill</tt> yields one.
<br>
After the <b>identity-declaration</b>
<pre>
STRUCT (BOOL sex, INT age) jack = (TRUE, 9), 
</pre>
<tt>age OF jack</tt> cannot be assigned to since <tt>jack</tt> is not a <b>variable</b>.}

<h3>
<a name=5312></a>5.3.1.2. Semantics
</h3>

<p>
The yield <i>W</i> of a <b>selection</b> <i>S</i> is determined as follows:
<ul>
<li> let <i>V</i> be the yield of the <b>SECONDARY</b> of <i>S</i>;
<li> it is required that <i>V</i> {if it is a name} be not nil;
<li> <i>W</i> is the value selected in {<a href="report_1.html#2133a">2.1.3.3.a, e</a> , <a href="report_1.html#2134k">2.1.3.4.k</a>}  or the name generated from {<a href="report_1.html#2134l">2.1.3.4.l</a>} <i>V</i> by the <b>field-selector</b> of <i>S</i>.
</ul>

<p>
{A <b>selection</b> in a name referring to a structured value yields an existing subname {<a href="report_1.html#2133e">2.1.3.3.e</a>} of that name. The name generated from a name referring to a multiple value, by way of a selection with a <b>ROWS-of-MODE-SECONDARY</b> (as in <tt>re OF z1</tt>), is a name which may or may not be newly created for the purpose.}

<h3>
<a name=532></a>5.3.2. Slices
</h3>

<p>
{<b>Slices</b> are obtained by subscripting, e.g., <tt>x1[i]</tt>, by trimming, e.g., <tt>x1[2 : n]</tt> or by both, e.g., <tt>x2[j : n, j]</tt> or <tt>x2 [, k]</tt>. Subscripting and trimming may be done only to <b>PRIMARY</b>s, e.g., <tt>x1</tt> or <tt> (p | x1 |  y1)</tt> but not <tt>re OF z1</tt>. The value of a <b>slice</b> may be either one element of the yield of its <b>PRIMARY</b> or a subset of the elements;  e.g., <tt>x1[i]</tt> is a real number from the row of real numbers <tt>x1</tt>, <tt>x2[i, ]</tt> is the <tt>i</tt>-th row of the matrix <tt>x2</tt> and <tt>x2[, k]</tt> is its <tt>k</tt>-th column.}

<h3>


<p>
<a name=5321></a>5.3.2.1. Syntax
</h3>
<a name=5321A></a>A) <b>ROWSETY :: ROWS  ; EMPTY.</b>
<br>
<a name=5321a></a>a) <b>REFETY MODE1 NEST slice</b> {<a href="report_2.html#51D">5D</a>} <b>:  weak REFLEXETY ROWS1 of MODE1 NEST PRIMARY</b> {<a href="report_2.html#51D">5D</a>} <b>, ROWS1 leaving EMPTY NEST indexer</b> {b, c, -}<b> STYLE bracket, where (REFETY) is derived from (REFLEXETY)</b> {<a href="report_2.html#5311b">531b, c</a>  , -}<b>; where (MODE1) is (ROWS2 of MODE2), weak REFLEXETY ROWS1 of MODE2 NEST PRIMARY</b> {<a href="report_2.html#51D">5D</a>} <b>, ROWS1 leaving ROWS2 NEST indexer</b> {b, d, -}<b> STYLE bracket, where (REFETY) is derived from (REFLEXETY)</b> {<a href="report_2.html#5311b">531b, c</a>  , -}<b>.</b>
<br>
{<b>ROWS :: row ; ROWS row.</b>}
<br>
<a name=5321b></a>b) <b>row ROWS leaving ROWSETY1 ROWSETY2 NEST indexer</b> {a, b}<b> : row leaving ROWSETY1 NEST indexer</b> {c, d, -}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, ROWS leaving ROWSETY2 NEST indexer</b> {b, c, d, -}<b>.</b>
<br>
<a name=5321c></a>c) <b>row leaving EMPTY NEST indexer</b> {a, b}<b> : NEST subscript</b> {e}<b>.</b>
<br>
<a name=5321d></a>d) <b>row leaving row NEST indexer</b> {a, b}<b> : NEST trimmer</b> {f}<b>; NEST revised lower bound</b> {g}<b> option.</b>
<br>
<a name=5321e></a>e) <b>NEST subscript</b> {c}<b> : meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=5321f></a>f) <b>NEST trimmer</b> {d}<b> : NEST lower bound</b> {<a href="report_2.html#461m">46m</a>}  <b>option, up to</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST upper bound</b> {<a href="report_2.html#461n">46n</a>}  <b>option, NEST revised lower bound</b> {g}<b> option.</b>
<br>
<a name=5321g></a>g) <b>NEST revised lower bound</b> {d, f}<b> : at</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST lower bound</b> {<a href="report_2.html#461m">46m</a>}  <b>.</b>
<br>
<a name=5321h></a>h) <b>*trimscript : NEST subscript</b> {e}<b>; NEST trimmer</b> {f}<b>; NEST revised lower bound</b> {g}<b> option.</b>
<br>
<a name=5321i></a>i) <b>*indexer : ROWS leaving ROWSETY NEST indexer</b> {b, c, d}<b>.</b>
<br>
<a name=5321j></a>j) <b>*boundscript : NEST subscript</b> {e}<b>; NEST lower bound</b> {<a href="report_2.html#461m">46m</a>}  <b>; NEST upper bound</b> {<a href="report_2.html#461n">46n</a>}  <b>; NEST revised lower bound</b> {g}<b>.</b>

<p>
<pre>
{Examples:
a) x2[i, j] &bull; x2[, j]
b) 1 : 2, j (in x2[1 : 2, j] &bull; i, j (in x2[i, j])
c) j (in x2[1 : 2, j])
d) 1 : 2 &bull; @0 (in x1[@0])
e) j
f) 1 : 2 @0
g) @0 }
</pre>

<p>
{A <b>subscript</b> decreases the number of dimensions by one, but a <b>trimmer</b> leaves it unchanged. In rule a,  <b>'ROWS1'</b> reflects the number of <b>trimscripts</b> in the <b>slice</b>, and <b>'ROWS2'</b> the number of these which are <b>trimmers</b> or <b>revised-lower-bound-options</b>. If the value to be sliced is a name, then the yield of the <b>slice</b> is also a name. Moreover, if the mode of the former name is <b>'reference to flexible ROWS1 of MODE'</b>, then that yield is a transient name (see <a href="report_1.html#2136c">2.1.3.6.c</a>).}

<h3>
<a name=5322></a>5.3.2.2. Semantics
</h3>

<P>
<a name=5322a></a>a) The yield <i>W</i> of a <b>slice</b> <i>S</i> is determined as follows:
<ul>
<li> let <i>V</i> and (I<sub>1</sub>, ... , I<sub>n</sub>) be the {collateral}  yields of the <b>PRIMARY</b> of <i>S</i> and of the <b>indexer</b> {b} of <i>S</i>;
<li> it is required that <i>V</i> {if it is a name} be not nil;
<li> let ( (r<sub>1</sub>, s<sub>1</sub>), ..., (r<sub>n</sub>, s<sub>n</sub>))  be the descriptor of <i>V</i> or of the value referred to by <i>V</i>;
<br>
For i =  1, ..., n, 
<ul>
<a name=5322cA></a>
Case A: I<sub>i</sub> is an integer:
<ul>
<li> it is required that r<sub>i</sub> &le;I<sub>i</sub> &le; s<sub>i</sub>;
</ul>
<a name=5322cB></a>
Case B: I<sub>i</sub> is some triplet (l, u, l'):
<ul>
<li> let <i>L</i> be r<sub>i</sub>, if <i>l</i> is <i>absent</i>, and be <i>l</i> otherwise;
<li> let <i>U</i> be s<sub>i</sub>, if <i>u</i> is <i>absent</i>, and be <i>u</i> otherwise;
<li> it is required that r<sub>i</sub> &le;L and U &le;s<sub>i</sub>;
<li> let <i>D</i> be 0 if <i>l'</i> is <i>absent</i>, and be L - l&cent; otherwise;  {<i>D</i> is the amount to be subtracted from <i>L</i> in order to get the revised lower bound;}
<li> <i>I<sub>i</sub></i> is replaced by (L, U, D);
</ul>
<li> <i>W</i> is the value selected in {<a href="report_1.html#2134a">2.1.3.4.a, g, i</a>} or the name generated from {<a href="report_1.html#2134j">2.1.3.4.j</a>}  <i>V</i> by I<sub>1</sub>, ... , I<sub>n</sub>.
</ul>
</ul>

<p>
<a name=5322b></a>b) The yield of an <b>indexer</b> <i>I</i> of a <b>slice</b> <i>S</i> is a trim {<a href="report_1.html#2134h">2.1.3.4.h</a>} or an index {<a href="report_1.html#2134a">2.1.3.4.a</a>}  I<sub>1</sub>, ... , I<sub>n</sub> determined as follows:
&bull;  the constituent <b>boundscripts</b> of <i>S</i> are elaborated collaterally;
<br>
For i = 1 ... n, where <i>n</i> is the number of constituent <b>trimscripts</b> of <i>S</i>, 
<ul>
<a name=5322cA></a>
Case A: the <i>i</i>-th <b>trimscript</b> is a <b>subscript</b>:
<ul>
<li> <i>I<sub>i</sub></i> is {the integer which is} the yield of that <b>subscript</b>;
</ul>
<a name=5322cB></a>
Case B: the <i>i</i>-th <b>trimscript</b> is a <b>trimmer</b> <i>T</i>:
<ul>
<li> <i>I<sub>i</sub></i> is the triplet (l, u, l'), where
<ul>
<li> <i>l</i> is the yield of the constituent <b>lower-bound</b>, if any, of <i>T</i>, and is <i>absent</i>, otherwise, 
<li> <i>u</i> is the yield of the constituent <b>upper-bound</b>, if any, of <i>T</i>, and is <i>absent</i>, otherwise, 
<li> <i>l'</i> is the yield of the constituent <b>revised-lower-bound</b>, if any, of <i>T</i>, and is 1, otherwise;
</ul>
</ul>
<a name=5322cC></a>
Case C: the <i>i</i>-th <b>trimscript</b> is a <b>revised-lower-bound-option</b> <i>N</i>:
<ul>
<li> <i>I<sub>i</sub></i> is the triplet (absent, absent, l'), where
<li> <i>l'</i> is the yield of the <b>revised-lower-bound</b>, if any, of <i>N</i>, and is absent otherwise.
</ul>
</ul>

<p>
{Observe that, if (I<sub>1</sub>, ... , I<sub>n</sub>) contains no triplets, it is an index, and selects one element;  otherwise, it is a trim, and selects a subset of the elements.}

<p>
{A <b>slice</b> from a name referring to a multiple value yields an existing subname {<a href="report_1.html#2134j">2.1.3.4.j</a>} of that name if all the constituent <b>trimscripts</b> of that <b>slice</b>  are <b>subscripts</b>. Otherwise, it yields a generated name which may or may not be newly created for the purpose. Hence, the yield of <tt>x1[1 : 2] :=: x1 [1 : 2]</tt> is not defined, although <tt>x1[1] :=: x1[1]</tt> must always yield <tt>true</tt>.}

<p>
{The various possible bounds in the yield of a <b>slice</b> are illustrated by the following examples, for each of which the descriptor of the value referred to by the yield is shown:

<pre>
[0 : 9, 2 : 11] INT i3;
i3 [1, 3 : 10 @3] &cent; ( (3, 10)) &cent;;
i3 [1, 3 : 10] &cent; ( (1, 8)) &cent;;
i3 [1, 3 : ] &cent; ( (1, 9)) &cent;;
i3 [1, : ] &cent; ( (1, 10)) &cent;;
i3 [1, ] &cent; ( (2, 11)) &cent;;
i3 [, 2] &cent; ( (0, 9)) &cent; }
</pre>

<h3>
<a name=54></a>5.4. Units associated with routines
</h3>

<p>
{Routines are created from <b>routine-texts</b> {<a href="report_2.html#541">5.4.1</a>}  or from <b>jumps</b> {<a href="report_2.html#544">5.4.4</a>}, and they may be "called" by <b>calls</b> {<a href="report_2.html#543">5.4.3</a>},  <b>formulas</b> {<a href="report_2.html#542">5.4.2</a>}  or by deproceduring {<a href="report_3.html#63">6.3</a>}.}

<h3>
<a name=541></a>5.4.1. Routine texts
</h3>

<p>
{A <b>routine-text</b> always has a <b>formal-declarer</b>, specifying the mode of the result, and a <b>routine-token</b>, viz., a colon. To the right of this colon stands a <b>unit</b>, which prescribes the computations to be performed when the routine is called. If there are parameters, then to the left of the <b>formal-declarer</b> stands a <b>declarative</b> containing the various <b>formal-parameters</b> required.
<br>
Examples:
<pre>
VOID: print (x);
 (REF REAL a, REAL b) BOOL: (a &lt; b | a := b; TRUE | FALSE).
</pre>
}

<h3>
<a name=5411></a>5.4.1.1. Syntax
</h3>

<p>
<a name=5411a></a>a) <b>procedure yielding MOID NEST1 routine text</b> {<a href="report_2.html#441d">44d</a> , <a href="report_2.html#51A">5A</a>} <b>:  formal MOID NEST1 declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>, routine</b> {<a href="report_4.html#941f">94f</a>}  <b>token, strong MOID NEST1 unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=5411b></a>b) <b>procedure with PARAMETERS yielding MOID NEST1 routine text</b> {<a href="report_2.html#441d">44d</a> , <a href="report_2.html#51A">5A</a>} <b>:  NEST1 new DECS2 declarative defining new DECS2</b> {e}<b> brief pack, where DECS2 like PARAMETERS</b> {c, d, -}<b>, formal MOID NEST1 declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>, routine</b> {<a href="report_4.html#941f">94f</a>}  <b>token, strong MOID NEST1 new DECS2 unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>
<br>
<a name=5411c></a>c) <b>WHETHER DECS DEC like PARAMETERS PARAMETER</b> {b, c}<b> : WHETHER DECS like PARAMETERS</b> {c, d, -}<b> and DEC like PARAMETER</b> {d, -}<b>.</b> {<b>PARAMETER :: MODE parameter.</b>}
<br>
<a name=5411d></a>d) <b>WHETHER MODE TAG like MODE parameter</b> {b, c}<b> :  WHETHER true.</b>
<br>
<a name=5411e></a>e) <b>NEST2 declarative defining new DECS2</b> {b, e, <a href="report_2.html#341j">34j</a>}  <b>: formal MODE NEST2 declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>, NEST2 MODE parameter joined definition of DECS2</b> {<a href="report_2.html#411b">41b, c</a>}  <b>; where (DECS2) is (DECS3 DECS4), formal MODE NEST2 declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>, NEST2 MODE parameter joined definition of DECS3</b> {<a href="report_2.html#411b">41b, c</a>}  <b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST2 declarative defining new DECS4</b> {e}<b>.</b>
<br>
<a name=5411f></a>f) <b>NEST2 MODE parameter definition of MODE TAG2</b> {<a href="report_2.html#411c">41c</a>}  <b>: MODE NEST2 defining identifier with TAG2</b> {<a href="report_2.html#481a">48a</a>}  <b>.</b>
<br>
<a name=5411g></a>g) <b>*formal MODE parameter : NEST MODE parameter definition of MODE TAG</b> {f}<b>.</b>

<p>
<pre>
{Examples:
a) REAL: random &times 10
b) (BOOL a, b) BOOL: (a | b | FALSE)
e) BOOL a, b &bull; BOOL a, BOOL b
f) a }
</pre>

<h3>
<a name=5412></a>5.4.1.2. Semantics
</h3>

<p>
The yield of a <b>routine-text</b>  <i>T</i>, in an environ <i>E</i>, is the routine composed of
<ol type=i>
<li><i>T</i>, and
<li>the environ necessary for {<a href="report_3.html#722c">7.2.2.c</a>} <i>T</i> in <i>E</i>.
</ol>

<h3>
<a name=542></a>5.4.2. Formulas
</h3>

<p>
{<b>Formulas</b> are either dyadic or monadic: e.g., <tt>x + i</tt> or <tt>ABS x</tt>. The order of elaboration of a <b>formula</b> is determined by the priority of its <b>operators</b>; monadic <b>formulas</b> are elaborated first and then the dyadic ones from the highest to the lowest priority.}

<h3>
<a name=5421></a>5.4.2.1. Syntax
</h3>

<p>
<a name=5421A></a>A) <b>DYADIC ::  priority PRIO.</b>
<br>
<a name=5421B></a>B) <b>MONADIC :: priority iii iii iii i.</b>
<br>
<a name=5421C></a>C) <b>ADIC :: DYADIC ; MONADIC.</b>
<br>
<a name=5421D></a>D) <b>TALLETY :: TALLY ; EMPTY.</b>
<br>
<a name=5421a></a>a) <b>MOID NEST DYADIC formula</b> {c, <a href="report_2.html#51B">5B</a>} <b>:  MODE1 NEST DYADIC TALLETY operand</b> {c, -}<b>, procedure with MODE1 parameter MODE2 parameter yielding MOID NEST applied operator with TAD</b> {<a href="report_2.html#481b">48b</a>}  <b>, where DYADIC TAD identified in NEST</b> {<a href="report_3.html#721a">72a</a>}  <b>, MODE2 NEST DYADIC TALLY operand</b> {c, -}<b>.</b>
<br>
<a name=5421b></a>b) <b>MOID NEST MONADIC formula</b> {c, <a href="report_2.html#51B">5B</a>} <b>:  procedure with MODE parameter yielding MOID NEST applied operator with TAM </b> {<a href="report_2.html#481b">48b</a>}  <b>, MODE NEST MONADIC operand</b> {c}<b>.</b>
<br>
<a name=5421c></a>c) <b>MODE NEST ADIC operand</b> {a, b}<b> : firm MODE NEST ADIC formula</b> {a, b}<b> coercee</b> {<a href="report_3.html#611b">61b</a>}  <b>; where (ADIC) is (MONADIC), firm MODE NEST SECONDARY</b> {<a href="report_2.html#51C">5C</a>}  <b>.</b>
<br>
<a name=5421d></a>d) <b>*MOID formula : MOID NEST ADIC formula</b> {a, b}<b>.</b>
<br>
<a name=5421e></a>e) <b>*DUO dyadic operator with TAD : DUO NEST DEFIED operator with TAD</b> {<a href="report_2.html#481a">48a, b</a>}  <b>.</b>
<br>
<a name=5421f></a>f) <b>*MONO monadic operator with TAM : MONO NEST DEFIED operator with TAM</b> {<a href="report_2.html#481a">48a, b</a>}  <b>.</b>
<br>
<a name=5421g></a>g) <b>*MODE operand : MODE NEST ADIC operand</b> {c}<b>.</b>

<p>
<pre>
{Examples:
a) -x + 1
b) -x
c) -x &bull; 1 }
</pre>

<h3>
<a name=5422></a>5.4.2.2. Semantics
</h3>

<p>
The yield <i>W</i> of a <b>formula</b> <i>F</i>, in an environ <i>E</i>, is determined as follows:
<ul>
<li> let <i>R</i> be the routine yielded in <i>E</i> by the <b>operator</b> of <i>F</i>;
<li> let V<sub>1</sub>, ... , V<sub>n</sub> {n is 1 or 2} be the {collateral}  yields of the <b>operands</b> of <i>F</i>, in an environ <i>E1</i> established {locally, see <a href="report_2.html#322b">3.2.2.b</a>} around <i>E</i>;
<li> <i>W</i> is the yield of the calling {<a href="report_2.html#5432b">5.4.3.2.b</a>} of <i>R</i> in <i>E1</i>, with V<sub>1</sub>, ... , V<sub>n</sub>;
<li> it is required that <i>W</i> be not newer in scope than <i>E</i>.
</ul>

<p>
{Observe that <tt>a &uarr; b</tt> is not precisely the same as a<sup>b</sup> in the usual notation; indeed, the value of <tt> (- 1 &uarr; 2 + 4 = 5)</tt> and that of <tt> (4 - 1 &uarr; 2 = 3)</tt> both are <tt>true</tt>, since the first <b>minus-symbol</b> is a <b>monadic-operator</b>, whereas the second is a <b>dyadic-operator</b>.}

<h3>
<a name=543></a>5.4.3. Calls
</h3>

<p>
{<b>Calls</b> are used to command the elaboration of routines parametrized with <b>actual-parameters</b>.
<br>
Examples:
<pre>
sin (x) &bull; (p | sin | cos) (x). }
</pre>

<h3>
<a name=5431></a>5.4.3.1. Syntax
</h3>

<p>
<a name=5431a></a>a) <b>MOID NEST call</b> {<a href="report_2.html#51D">5D</a>} <b>:  meek procedure with PARAMETERS yielding MOID NEST PRIMARY</b> {<a href="report_2.html#51D">5D</a>} <b>, actual NEST PARAMETERS</b> {b, c}<b> brief pack.</b>
<br>
<a name=5431b></a>b) <b>actual NEST PARAMETERS PARAMETER</b> {a, b}<b> : actual NEST PARAMETERS</b> {b, c}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, actual NEST PARAMETER </b> {c}<b>.</b>
<br>
<a name=5431c></a>c) <b>actual NEST MODE parameter</b> {a, b}<b> : strong MODE NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b>

<p>
<pre>
{Examples:
a) put (stand out, x) (see <a href="report_5.html#A331a">10.3.3.1.a</a>)
b) stand out, x
c) x }
</pre>

<h3>
<a name=5432></a>5.4.3.2. Semantics
</h3>

<p>
<a name=5432a></a>a) The yield <i>W</i> of a <b>call</b> <i>C</i>, in an environ <i>E</i>, is determined as follows:
<ul>
<li> let <i>R</i> {a routine} and V<sub>1</sub>, ... , V<sub>n</sub> be the {collateral} yields of the <b>PRIMARY</b> of <i>C</i>, in <i>E</i>, and of the constituent <b>actual-parameters</b> of <i>C</i>, in an environ <i>E1</i>  established {locally, see <a href="report_2.html#322b">3.2.2.b</a>} around <i>E</i>;
<li> <i>W</i> is the yield of the calling {b} of <i>R</i> in <i>E1</i> with V<sub>1</sub>, ... , V<sub>n</sub>;
<li> it is required that <i>W</i> be not newer in scope than <i>E</i>.
</ul>

<p>
<a name=5432b></a>b) The yield <i>W</i> of the "calling", of a routine <i>R</i> in an environ <i>E1</i>, possibly with {parameter} values V<sub>1</sub>, ... , V<sub>n</sub>, is determined as follows:
<ul>
<li> let <i>E2</i> be the environ established {<a href="report_2.html#322b">3.2.2.b</a>} upon <i>E1</i>, around the environ of <i>R</i>, according to the <b>declarative</b> of the <b>declarative-pack</b>, if any, of the <b>routine-text</b> of <i>R</i>, with the values V<sub>1</sub>, ... , V<sub>n</sub>, if any;
<li> <i>W</i> is the yield in <i>E2</i> of the <b>unit</b> of the <b>routine-text</b> of <i>R</i>.
</ul>

<p>
{Consider the following <b>serial-clause</b>:
<pre>
PROC samelson = (INT n, PROC (INT) REAL f) REAL:
   BEGIN LONG REAL s := LONG 0;
      FOR i TO n DO s +:= LENG f (i) &uarr; 2 OD;
      SHORTEN long sqrt (s)
   END;
samelson (m, (INT j) REAL: x1[j]).
</pre>
In that context, the last <b>call</b> has the same effect as the following <b>cast</b>:
<pre>
REAL (
   INT n = m, PROC (INT) REAL f = (INT j) REAL: x1[j];
   BEGIN LONG REAL s := LONG 0;
      FOR i TO n DO s +:= LENG f (i) &uarr; 2 OD;
      SHORTEN long sqrt (s)
   END).
</pre>

<p>
The transmission of <b>actual-parameters</b> is thus similar to the elaboration of <b>identity-declarations</b> {<a href="report_2.html#442a">4.4.2.a</a>}; see also establishment {<a href="report_2.html#322b">3.2.2.b</a>} and ascription {<a href="report_2.html#482a">4.8.2.a</a>}.}

<h3>
<a name=544></a>5.4.4. Jumps
</h3>

<p>
{A <b>jump</b> may terminate the elaboration of a <b>series</b> and cause some other labelled <b>series</b> to be elaborated in its place.
<br>
Examples:
<pre>
y = IF x &ge; 0 THEN sqrt (x) ELSE GOTO princeton FI &bull;
GOTO st pierre de chartreuse.
</pre>

<p>
Alternatively, if the context expects the mode <b>'procedure yielding MOID'</b>, then a routine whose <b>unit</b> is that <b>jump</b> is yielded instead, as in <tt>PROC VOID m := GOTO north berwick</tt>.}

<h3>
<a name=5441></a>5.4.4.1. Syntax
</h3>

<p>
<a name=5441a></a>a) <b>strong MOID NEST jump</b> {<a href="report_2.html#51A">5A</a>} <b>:  go to</b> {b}<b> option, label NEST applied identifier with TAG</b> {<a href="report_2.html#481b">48b</a>}  <b>.</b>
<br>
<a name=5441b></a>b) <b>go to {a} : STYLE go to</b> {<a href="report_4.html#941f">94f</a>  , -}<b> token ; STYLE go</b> {<a href="report_4.html#941f">94f</a>  , -}<b> token, STYLE to symbol</b> {<a href="report_4.html#941g">94g</a>, -}<b>.</b>

<p>
<pre>
{Examples:
a) GOTO kootwijk &bull; GO TO warsaw &bull; zandvoort
b) GOTO &bull; GO TO }
</pre>

<h3>
<a name=5442></a>5.4.4.2. Semantics
</h3>

<p>
A <b>MOID-NEST-jump</b> <i>J</i>, in an environ <i>E</i>, is elaborated as follows:
&bull; let the scene yielded in <i>E</i> by the <b>label-identifier</b> of <i>J</i> be composed of a <b>series</b> <i>S2</i> and an environ <i>E1</i>;
<br>
<a name=5442cA></a>
Case A: <b>'MOID'</b> is not any <b>'procedure yielding MOID1'</b>:
<ul>
<li> let <i>S1</i> be the <b>series</b> of the smallest {<a href="report_1.html#1132g">1.1.3.2.g</a>} <b>serial-clause</b> containing <i>S2</i>;
<li> the elaboration of <i>S1</i> in <i>E1</i>, or of any <b>series</b> in <i>E1</i> elaborated in its place, is terminated {<a href="report_1.html#2143e">2.1.4.3.e</a>};
<li> <i>S2</i> in <i>E1</i> is elaborated "in place of" <i>S1</i> in <i>E1</i>;
</ul>
<a name=5442cB></a>
Case B: <b>'MOID'</b> is some <b>'procedure yielding MOID1'</b>:
<ul>
<li> <i>J</i> in <i>E</i> {is completed and} yields the routine composed of
</ul>
<ol type=i>
<li> a new <b>MOID-NEST-routine-text</b> whose <b>unit</b> is akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to <i>J</i>, 
<li> <i>E1</i>.
</ol>

<h3>
<a name=55></a>5.5. Units associated with values of any mode
</h3>

<h3>
<a name=551></a>5.5.1. Casts
</h3>

<p>
{<b>Casts</b> may be used to provide a strong position. For example, <tt>REF REAL (xx)</tt> in <tt>REF REAL (xx) :=  1</tt>, <tt>REF BOOK (NIL)</tt> in <tt>next OF draft :=: REF BOOK (NIL)</tt> and <tt>STRING (p | c | r)</tt> in <tt>s +:= STRING (p | c | r)</tt>.}

<h3>
<a name=5511></a>5.5.1.1. Syntax
</h3>

<p>
<a name=5511a></a>a) <b>MOID NEST cast</b> {<a href="report_2.html#51D">5D</a>} <b>:  formal MOID NEST declarer</b> {<a href="report_2.html#461b">46b</a>}  <b>, strong MOID NEST ENCLOSED clause</b> {<a href="report_2.html#311a">31a</a>, <a href="report_2.html#331a">33a, c, d, e</a>, <a href="report_2.html#341a">34a</a>, <a href="report_2.html#351a">35a</a>, -}<b>.</b>

<p>
<pre>
{Example:
a) REF BOOK (NIL) }
</pre>

<p>
{The yield of a <b>cast</b> is that of its <b>ENCLOSED-clause</b>, by way of pre-elaboration {<a href="report_1.html#2141c">2.1.4.1.c</a>}.}

<h3>
<a name=552></a>5.5.2. Skips
</h3>

<h3>
<a name=5521></a>5.5.2.1. Syntax
</h3>

<p>
<a name=5521a></a>a) <b>strong MOID NEST skip</b> {<a href="report_2.html#51A">5A</a>} <b>:  skip</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b>

<h3>
<a name=5522></a>5.5.2.2. Semantics
</h3>

<p>
The yield of a <b>skip</b> is some {undefined} value equal in scope to the primal environ.
<p>
{The mode of the yield of a <b>MOID-skip</b> is <b>'MOID'</b>. A <b>void-skip</b> serves as a dummy statement and may be used, for example, after a <b>label</b> which marks the end of a <b>serial-clause</b>.}

<!-- RRFooter -->
<p>
<div style="border: 1px solid red">
<table cellpadding=6>
<tr>
<td>
<p style="font-size: 8pt; font-color: black;">
Text from the <i>Revised Report on the Algorithmic
Language Algol 68</i> is reproduced under the condition specified in
that report: <i>Reproduction of the Report, for any purpose, but only
of the whole text, is explicitly permitted without formality</i>. The
appendix <i>Specification of partial parametrization proposal</i> is
not a part of the Algol 68 Revised Report, and is distributed with
Algol 68 Genie with kind permission of C.H. Lindsey.
<p style="font-size: 8pt; font-color: black;">
Copyright &copy; 2001-2008 J. Marcel van der Veer.<br>
Algol 68 Genie Mark 15.1 (January 2009)
</td>
</tr>
</table>
</div>
</body>
</html>


