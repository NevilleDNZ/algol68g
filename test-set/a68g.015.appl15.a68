# This program is part of the Revised Mathematisch Centrum Algol 68 Test Set
  by Dick Grune [1979].
 
  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.
 
  The complete test set is an open-access publication, 
  self-archived by Dick Grune and available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #
 
#appl15#
BEGIN # Mincer #
CO
This program operates in one of two modes:
     1.  garbage in, garbage out
     2.  data in, garbage out
The basic idea is to read in a program, scramble it, and punch the
scrambled program out. The scrambled program can be fed into a compiler
to see what it does. Experience shows that most compilers do not take
well to this test at all.
The program is broken up into syntactic units, where a syntactic unit
is an identifier, an unsigned int, a bold, a string, a sequence of
the characters +-*/=<>: , or a special.
Random numbers are taken from a rectangular distribution with mean
supplied by the user. Let 'n1' be the first such random number.
The first 'n1' syntactic units are considered to be the first chunk. The
next 'n2' syntactic units comprise the second chunk, etc. The chunks are
then put out in random order. If the chunks are big enough, the compiler
thinks it is getting reasonable stuff, makes some attempt at analyzing
the structure, building tables, etc. If the chunks are too small,
nothing much happens.
The program to be read in resides on the file "program", the scrambled
program on the file "result".
The values to be used as means for the random numbers are read from
'stand in'. The list is terminated by mean = 0. Values may be
preceded by a minus-sign, in which case the chunks in the corresponding
output are separated by newlines.
For instance, if the input-file contains:  100   -20   0  ,
two scrambled programs will be generated, the first having chunks of
about 100 syntactic units, the second with chunks of about 20 syntactic
units, separated.
CO
  INT line width = 72; # for 'program' and 'result' #
  FILE program; # contains the program #
  open(program, "program", standin channel);
  FILE result; # will contain the minced program #
  establish(result, "result", standout channel, 1, 10000, line width);
  STRING result sep = "######"; # for result #
  CHAR quote = """", dot = ".";
  PROC in item = STRING:
  (STRING st = in item or comment;
    comment(st) | skip comment(st); in item | st);
  PROC comment = (STRING s) BOOL:
  s = "#" OR s = "CO" OR s = "COMMENT";
  PROC skip comment = (STRING s) VOID:
  WHILE in item or comment /= s DO SKIP OD;
  PROC in item or comment = STRING:
  BEGIN more real input; CHAR ch = line[c pos];
    STRUCT(STRING item, INT new pos) res :=
    IF letter(ch)
    THEN INT p = last(letgit);
      (line[c pos: p], p + 1)
    ELIF ch = quote
    THEN INT p = last((CHAR c) BOOL: c /= quote);
      (line[c pos: p] + quote, p + 2)
    ELIF digit(ch)
    THEN INT p = last(digit);
      (line[c pos: p], p + 1)
    ELIF ch = dot
    THEN INT p = last(letgit);
      (line[c pos: p] + " ", p + 1)
    ELIF indicant (ch)
    THEN INT p = last(indicant);
      (line[c pos: p], p + 1)
    ELSE (line[c pos], c pos + 1)
    FI;
    c pos:= new pos OF res; item OF res
  END # in item or comment #;
  PROC last= (PROC (CHAR) BOOL cond) INT:
  (INT p:= c pos;
    FOR d FROM c pos + 1 TO UPB line WHILE cond(line[d])
    DO p:= d OD;
    p
  );
  PROC letter = (CHAR ch) BOOL: "a" <= ch AND ch <= "z"
      OR "A" <= ch AND ch <= "Z" # for UPPER-style #;
  PROC digit = (CHAR ch) BOOL: "0" <= ch AND ch <= "9";
  PROC letgit = (CHAR ch) BOOL: letter (ch) OR digit (ch);
  PROC indicant = (CHAR ch) BOOL:
    char in string (ch, LOC INT, "+-*/=<>:");
  PROC more real input = VOID:
  (skip:
    IF c pos>UPB line THEN newline(program); get line; skip FI;
    IF line [c pos] = " " THEN c pos +:= 1; skip FI
  );
  INT c pos:= 1, STRING line:= ""; # on 'program' #
  PROC get line = VOID:
  (get(program, line);
    IF UPB line > line width
    THEN line:= line [1: linewidth] FI;
    c pos:= 1
  );
  PROC out item = (STRING s) VOID:
  (IF char number (result) + UPB s > line width
    THEN newline (result) FI;
    put(result, s)
  );
  PROC range = (INT r)INT: # a random integer in the range [1:r] #
  ENTIER (random * r) + 1;
# Reading the program text #
  MODE TEXT = STRUCT (STRING string, REF TEXT next);
  REF TEXT no text = NIL;
  REF TEXT first text:= no text, last text:= no text;
  on logical file end (program, (REF FILE f) BOOL: run);
# Initialize # get line;
  DO # until end-of-file # STRING st = in item;
    last text:=
    (last text :=: no text| first text | next OF last text):=
    HEAP TEXT:= (st, no text)
  OD;
  run:
  WHILE INT descr = (INT i; read(i); i);
    INT mean = ABS descr, BOOL sep = descr < 0;
    0 < mean AND mean < 10000
  DO
    MODE CHUNK =
    STRUCT(STRUCT(INT length, REF TEXT text) chunk,
               REF CHUNK next);
    REF CHUNK no chunk = NIL;
    REF CHUNK first chunk:= no chunk, last chunk:= no chunk;
    INT n chunks:= 0; last text:= first text;
    WHILE last text :/=: no text
    DO INT cnt:= 0, REF TEXT p:= last text;
      TO range (2 * mean - 1)
      DO (p :/=: no text
           | p:= next OF p; cnt +:=1)
      OD # determine chunk #;
    # enter into chunk chain #
      last chunk:=
      (last chunk :=: no chunk
      | first chunk
      | next OF last chunk):=
      HEAP CHUNK:= ((cnt, last text), NIL);
      n chunks +:= 1; last text:= p
    OD # chunk chain ready #;
  # Tie full-circle #
    (last chunk :/=: no chunk | next OF last chunk:= first chunk);
  # Mix the chunks #
    FOR length FROM n chunks BY -1 TO 1
    DO
      TO range (length)
      DO first chunk:= next OF first chunk OD;
    # Random chunk found, now write it #
      REF TEXT p:= text OF chunk OF next OF first chunk;
      TO length OF chunk OF next OF first chunk
      DO out item (string OF p);
        p:= next OF p
      OD;
      IF sep THEN newline(result) FI;
    # Remove chunk #
      next OF first chunk:=
        next OF next OF first chunk
    OD;
    put(result, (newline, result sep, newline, newline));
    printf((
      $ "Produced" 4zd x, "chunks of mean length" 3zd ,
        b (", separated", "") l $,
      n chunks, mean, sep))
  OD
END
