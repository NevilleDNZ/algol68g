# This program is part of the
 
     Revised Mathematisch Centrum Algol 68 Test Set

  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.

  This test set is available from:

     http://www.dickgrune.com/CS/Algol68

  or from the Vrije Universiteit Amsterdam:

     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#appl06#

# Revised Report, 11.10. #
BEGIN # Formula manipulation #
      MODE FORM = UNION (REF CONST, REF VAR, REF TRIPLE, REF CALL),
            CONST = STRUCT (REAL value),
            VAR = STRUCT (STRING name, REAL value),
            TRIPLE = STRUCT (FORM left operand, INT operator, FORM right operand),
            FUNCTION = STRUCT (REF VAR bound var, FORM body),
            CALL = STRUCT (REF FUNCTION function name, FORM parameter);
      
      INT plus = 1, minus = 2, times = 3, by = 4, to = 5;
      
      HEAP CONST zero, one;
      
      value OF zero := 0;
      value OF one := 1;
      OP = = (FORM a, REF CONST b) BOOL:
         CASE a
         IN (REF CONST ec): ec :=: b
         OUT FALSE
         ESAC;
      
      OP + = (FORM a, b) FORM:
         (a = zero | b |: b = zero | a | HEAP TRIPLE := (a, plus, b));
      
      OP - = (FORM a, b) FORM:
         (b = zero | a | HEAP TRIPLE := (a, minus, b));
      
      OP * = (FORM a, b) FORM:
         (a = zero OR b = zero | zero |: a = one | b |: b = one | a | HEAP TRIPLE := (a, times, b));
      
      OP / = (FORM a, b) FORM:
         (a = zero AND NOT (b = zero) | zero |: b = one | a | HEAP TRIPLE := (a, by, b));
      
      OP ** = (FORM a, REF CONST b) FORM:
         (a = one OR (b :=: zero) | one |: b :=: one | a | HEAP TRIPLE := (a, to, b));
      
      PROC derivative of = (FORM e,  # with respect to # REF VAR x) FORM:
           CASE e
           IN (REF CONST): zero, (REF VAR ev): (ev :=: x | one | zero), (REF TRIPLE et): CASE FORM u = left operand OF et, v = right operand OF et;
                      
                      FORM udash = derivative of (u,  # with respect to # x), vdash = derivative of (v,  # with respect to # x);
                      
                      operator OF et
              IN udash + vdash, udash - vdash, u * vdash + udash * v, (udash - et * vdash) / v, (v | (REF CONST ec): v * u ** (HEAP CONST c;
                                                       
                                                       value OF c := value OF ec - 1;
                                                       c) * udash)
              ESAC, (REF CALL ef): BEGIN REF FUNCTION f = function name OF ef,
                                         FORM g = parameter OF ef;
                                         
                                         REF VAR y = bound var OF f;
                                         
                                         HEAP FUNCTION fdash := (y, derivative of (body OF f, y));
                                         
                                         (HEAP CALL := (fdash, g)) * derivative of (g, x)
              END
           ESAC # end derivative # ;
      
      PROC value of = (FORM e) REAL:
           CASE e
           IN (REF CONST ec): value OF ec, (REF VAR ev): value OF ev, (REF TRIPLE et): CASE REAL u = value of (left  operand OF et), v = value of (right operand OF et);
                    
                    operator OF et
              IN u + v, u - v, u * v, u / v, exp (v * ln (u))
              ESAC, (REF CALL ef): BEGIN REF FUNCTION f = function name OF ef;
                                         
                                         value OF bound var OF f := value of (parameter OF ef);
                                         value of (body OF f)
              END
           ESAC # value of # ;
      
      HEAP FORM f, g;
      
      HEAP VAR a := ("a", SKIP), b := ("b", SKIP), x := ("x", SKIP);
      
      #  start here: read ((value OF a, value OF b, value OF x));  #
      value OF a := 1;
      value OF b := 1;
      value OF x := 1;
      f := a + x / (b + x);
      g := (f + one) / (f - one);
      print ((value OF a,  #1# value OF b,  #1# value OF x,  #1# value of (derivative of (g,  # with respect to # x))
              #-2#
              ))
END