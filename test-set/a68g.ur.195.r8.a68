# This program is part of the Rennes Test Set, 
  automatically generated from the Algol 68 grammar 
  using a formalism of B. Houssais (University of Rennes, 1975).
 
  This test set is available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

# r8 #

# reads 2 cards #
(print (("denotations", newline));
 INT vf = 70;
 
 PRIO ?=:= = 1;
 
 #tests syntaxiques#
 
 # BOOL #
 ((FALSE;
   SKIP;
   FALSE;
   FALSE);
  (FALSE, SKIP, FALSE, FALSE);
  STRUCT (BOOL a, b, c, d) a = (FALSE, SKIP, FALSE, FALSE);
  
  [] BOOL b = (FALSE, SKIP, FALSE, FALSE);
  
  CASE 3
  IN FALSE, SKIP, FALSE, FALSE
  OUT FALSE
  ESAC;
  (UNION (REF BOOL, PROC BOOL) a := HEAP BOOL; a | (REF BOOL): FALSE);
  BOOL d = FALSE;
  
  BOOL v, vv := FALSE;
  
  v := FALSE;
  PROC pp = (BOOL a, b) BOOL: FALSE;
  
  pp (FALSE, FALSE);
  OP ?=:= = (BOOL a, b) BOOL: b,
      ?=:= = (BOOL a) BOOL: a;
  
  ?=:=FALSE ?=:= ?=:=?=:=FALSE ?=:= FALSE);
 # INT #
 ((2147483647;
   SKIP;
   2147483647;
   2147483647);
  (2147483647, SKIP, 2147483647, 2147483647);
  STRUCT (INT a, b, c, d) a = (2147483647, SKIP, 2147483647, 2147483647);
  
  [] INT b = (2147483647, SKIP, 2147483647, 2147483647);
  
  CASE 3
  IN 2147483647, SKIP, 2147483647, 2147483647
  OUT 2147483647
  ESAC;
  (UNION (REF INT, PROC INT) a := HEAP INT; a | (REF INT): 2147483647);
  INT d = 2147483647;
  
  INT v, vv := 2147483647;
  
  v := 2147483647;
  PROC pp = (INT a, b) INT: 2147483647;
  
  pp (2147483647, 2147483647);
  OP ?=:= = (INT a, b) INT: b,
      ?=:= = (INT a) INT: a;
  
  ?=:=2147483647 ?=:= ?=:=?=:=2147483647 ?=:= 2147483647);
 # REAL #
 ((-1e-00000;
   SKIP;
   -1e-00000;
   -1e-00000);
  (-1e-00000, SKIP, -1e-00000, -1e-00000);
  STRUCT (REAL a, b, c, d) a = (-1e-00000, SKIP, -1e-00000, -1e-00000);
  
  [] REAL b = (-1e-00000, SKIP, -1e-00000, -1e-00000);
  
  CASE 3
  IN -1e-00000, SKIP, -1e-00000, -1e-00000
  OUT -1e-00000
  ESAC;
  (UNION (REF REAL, PROC REAL) a := HEAP REAL; a | (REF REAL): -1e-00000);
  REAL d = -1e-00000;
  
  REAL v, vv := -1e-00000;
  
  v := -1e-00000;
  PROC pp = (REAL a, b) REAL: -1e-00000;
  
  pp (-1e-00000, -1e-00000);
  OP ?=:= = (REAL a, b) REAL: b,
      ?=:= = (REAL a) REAL: a;
  
  ?=:=-1e-00000 ?=:= ?=:=?=:=-1e-00000 ?=:= -1e-00000);
 # CHAR #
 (("""";
   SKIP;
   """";
   """");
  ("""", SKIP, """", """");
  STRUCT (CHAR a, b, c, d) a = ("""", SKIP, """", """");
  
  [] CHAR b = ("""", SKIP, """", """");
  
  CASE 3
  IN """", SKIP, """", """"
  OUT """"
  ESAC;
  (UNION (REF CHAR, PROC CHAR) a := HEAP CHAR; a | (REF CHAR): """");
  CHAR d = """";
  
  CHAR v, vv := """";
  
  v := """";
  PROC pp = (CHAR a, b) CHAR: """";
  
  pp ("""", """");
  OP ?=:= = (CHAR a, b) CHAR: b,
      ?=:= = (CHAR a) CHAR: a;
  
  ?=:="""" ?=:= ?=:=?=:="""" ?=:= """");
 # COMPL #
 ((001 I -02;
   SKIP;
   001 I -02;
   001 I -02);
  (001 I -02, SKIP, 001 I -02, 001 I -02);
  STRUCT (COMPL a, b, c, d) a = (001 I -02,
                                 SKIP,
                                 001 I -02,
                                 001 I -02);
  
  [] COMPL b = (001 I -02,
                SKIP,
                001 I -02,
                001 I -02);
  
  CASE 3
  IN 001 I -02, SKIP, 001 I -02, 001 I -02
  OUT 001 I -02
  ESAC;
  (UNION (REF COMPL, PROC COMPL) a := HEAP COMPL; a | (REF COMPL): 001 I -02);
  COMPL d = 001 I -02;
  
  COMPL v, vv := 001 I -02;
  
  v := 001 I -02;
  PROC pp = (COMPL a, b) COMPL: 001 I -02;
  
  pp (001 I -02, 001 I -02);
  OP ?=:= = (COMPL a, b) COMPL: b,
      ?=:= = (COMPL a) COMPL: a;
  
  ?=:=(001 I -02) ?=:= ?=:=?=:=(001 I -02) ?=:= (001 I -02));
 # BITS #
 ((8r7054;
   SKIP;
   8r7054;
   8r7054);
  (8r7054, SKIP, 8r7054, 8r7054);
  STRUCT (BITS a, b, c, d) a = (8r7054, SKIP, 8r7054, 8r7054);
  
  [] BITS b = (8r7054, SKIP, 8r7054, 8r7054);
  
  CASE 3
  IN 8r7054, SKIP, 8r7054, 8r7054
  OUT 8r7054
  ESAC;
  (UNION (REF BITS, PROC BITS) a := HEAP BITS; a | (REF BITS): 8r7054);
  BITS d = 8r7054;
  
  BITS v, vv := 8r7054;
  
  v := 8r7054;
  PROC pp = (BITS a, b) BITS: 8r7054;
  
  pp (8r7054, 8r7054);
  OP ?=:= = (BITS a, b) BITS: b,
      ?=:= = (BITS a) BITS: a;
  
  ?=:=8r7054 ?=:= ?=:=?=:=8r7054 ?=:= 8r7054);
 # STRING #
 (("#("" END #";
   SKIP;
   "#("" END #";
   "#("" END #");
  ("#("" END #", SKIP, "#("" END #", "#("" END #");
  STRUCT (STRING a, b, c, d) a = ("#("" END #",
                                  SKIP,
                                  "#("" END #",
                                  "#("" END #");
  
  [] STRING b = ("#("" END #",
                 SKIP,
                 "#("" END #",
                 "#("" END #");
  
  CASE 3
  IN "#("" END #", SKIP, "#("" END #", "#("" END #"
  OUT "#("" END #"
  ESAC;
  (UNION (REF STRING, PROC STRING) a := HEAP STRING; a | (REF STRING): "#("" END #");
  STRING d = "#("" END #";
  
  STRING v, vv := "#("" END #";
  
  v := "#("" END #";
  PROC pp = (STRING a, b) STRING: "#("" END #";
  
  pp ("#("" END #", "#("" END #");
  OP ?=:= = (STRING a, b) STRING: b,
      ?=:= = (STRING a) STRING: a;
  
  ?=:="#("" END #" ?=:= ?=:=?=:="#("" END #" ?=:= "#("" END #");
 #tests semantiques# INT ctr := 0;
 
 print ((" BOOL  denotations", newline));
 ctr +:= ABS TRUE + 1 - ABS FALSE;
 print (("true : ", TRUE, "  false : ", FALSE, newline));
 print ((" INT  denotations", newline));
 print ((" REAL  denotations", newline));
 print ((" CHAR  denotations", newline));
 [] CHAR k = ("#", "@", ",", "?", "$", "*", ".", "<", "-", "+", "a", " ", "z", ")", "e", "[", "r", "t", "|", "y", "1", "u", "2", "i", "3", "o", "&", "p", "0", "/", "q", ">", "s", ":", "d", ";", "f", "^", "g", "'", "h", "4", "j", "5", "k", "6", "l", "w", "?", "x", """", "c", "=", "v", "]", "b", "(", "n", "7", "m", "8", "9", " ");
 
 [1 : UPB k] CHAR l;
 
 FOR i TO UPB k 
 DO l[i] := k[i];
    (k[i] = l[i] | ctr +:= 1 | print ("err.char"))
 OD;
 print ((" COMPL  denotations", newline));
 (ABS (-2 * re OF COMPL (-00001, 002) - IM COMPL (-000001, 0000000000000000000002)) > 0.001 | print ("err.compl") | ctr +:= 1);
 print ((" BITS  denotations", newline));
 (2r101010111100110111101111 /= 16rabcdef | print ("err.bits") |: 8r3377337733 /= 4r123333123233123 | ctr +:= 1 | print ("err.bits"));
 print ((" STRING  denotations", newline));
 STRING s := "string";
 
 (s = "string" | ctr +:= 1 | print ("err.string"));
 s := "gnirts";
 (s = "gnirts" | ctr +:= 1 | print ("err.string"));
 print ((newline, "void denotation", newline));
 (UNION (BYTES, VOID) u := EMPTY; u | (VOID): ctr +:= 1 | print ("err.void"));
 print ((ctr, " tests ", (ctr = vf | "ok" | "error"))))