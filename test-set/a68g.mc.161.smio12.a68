# This program is part of the Revised Mathematisch Centrum Algol 68 Test Set
  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.'

  These test sets are available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#smio12#
BEGIN # Test 'fixed' #
      PROC fixed 1 = (REAL v, INT width, after) STRING:
           BEGIN PROC subfixed = 
                      #
                            This procedure attempts a machine-independent conversion from
                            REAL to []CHAR. The conversion will be exact if 'b' is
                            given a value such that the following conditions hold:
                            b is integer, x is real
                            1 < b < maxint OVER 10
                            if x < 0      then -x > 0
                            if x < 0      then --x = x
                            if x >= 1     then x / b * b = x
                            if 0 < x < 1  then x * b / b = x
                            if 0 <= x < b then 0 <= entier(x) < b
                            if 0 <= x < b then x - entier(x) < 1
                            if 0 <= x < b then x - entier(x) + entier(x) = x
                            if x > 1      then "ln(x)" * .9 < ln(x) < "ln(x)" * 1.1
                                          where "ln(x)" is the mathematical log nat of x
                            Here the arithmetic operators are meant as implemented, the
                            relational operators are meant in an absolute sense. The text
                            contains tests for these conditions, where, of course, the
                            relational operators are implemented by their ALGOL 68 counter-
                            parts. Discrepancies caused by tests which do not test what they
                            should test may cause the message "Sloppy arithmetic".
                            This procedure is not as inefficient as it might have been.
                          #
                      (REAL v, INT after, REF INT point, REF BOOL neg, BOOL floating) STRING:
                      BEGIN INT b = 16
                            # replace by suitable value #
                            ;
                            
                            # Reports on arithmetic troubles #
                            PROC warning = (UNION (REAL, INT, CHAR, STRING) l, oper, r, res, ch) VOID:
                                 print (("Warning: ", l, oper, r, " is ", res, ", should be ", ch, " .", new line));
                            
                            PROC sloppy = (REAL x, STRING s, INT lim) VOID:
                                 print (("Sloppy arithmetic: ", x, " is still ", s, " after", lim, " iterations.", newline));
                            
                            # Determining accuracy #
                            
                            # Each decimal operation may cause a loss of at most 1 unit in
                                      the last decimal. If we now make pessimistic guesses at the
                                      number of operations, we can calculate the number of extra
                                      digits needed.
                                    #
                            PRIO LN = 9;
                            
                            OP LN = (INT a, REAL b) INT:
                               (b < 1 | 0 | ENTIER (ln (b) / ln (a))) + 1;
                            
                            INT max exp = b LN max real, max mant = b LN (1 / small real) + 1;
                            
                            # Floating decimal arithmetic #
                            MODE DEC = STRUCT (REF [] INT d, INT p);
                            
                            # The value is <d> * 10 ** p, where <d> is d considered as
                                      a decimal fraction with the point in the (non-existent)
                                      position 0
                                    #
                            PROC zero = (INT size) DEC:
                                 BEGIN HEAP [size] INT d;
                                       
                                       FOR i TO UPB d 
                                       DO d[i] := 0
                                       OD;
                                       (d, 0)
                                 END;
                            
                            OP +:= = (REF DEC dc, INT a) VOID:
                               BEGIN REF [] INT d = d OF dc,
                                     REF INT p = p OF dc;
                                     
                                     INT upb = UPB d;
                                     
                                     INT carry := a, i := p;
                                     
                                     WHILE carry > 0
                                     DO WHILE i <= 0
                                        DO d[2 : ] := d[1 : upb - 1];
                                           d[1] := 0;
                                           p +:= 1;
                                           i +:= 1
                                        OD;
                                        IF i > upb
                                        THEN carry OVERAB 10
                                        ELSE REF INT di = d[i];
                                             
                                             INT val = di + carry;
                                             
                                             (di := val MOD 10, carry := val OVER 10)
                                        FI;
                                        i -:= 1
                                     OD
                               END;
                            
                            OP *:= = (REF DEC dc, INT a) VOID:
                               BEGIN REF [] INT d = d OF dc,
                                     REF INT p = p OF dc;
                                     
                                     INT upb = UPB d;
                                     
                                     INT carry := 0, i := upb;
                                     
                                     WHILE i > 0 OR carry > 0
                                     DO WHILE i <= 0
                                        DO d[2 : ] := d[1 : upb - 1];
                                           d[1] := 0;
                                           p +:= 1;
                                           i +:= 1
                                        OD;
                                        REF INT di = d[i];
                                        
                                        INT val = di * a + carry;
                                        
                                        (di := val MOD 10, carry := val OVER 10);
                                        i -:= 1
                                     OD
                               END;
                            
                            OP /:= = (REF DEC dc, INT a) VOID:
                               BEGIN REF [] INT d = d OF dc,
                                     REF INT p = p OF dc;
                                     
                                     INT upb = UPB d;
                                     
                                     INT carry := 0, i := 1;
                                     
                                     WHILE (i <= upb | TRUE | carry > 0 AND d[1] = 0)
                                     DO WHILE i > upb
                                        DO d[1 : upb - 1] := d[2 : ];
                                           d[upb] := 0;
                                           p -:= 1;
                                           i -:= 1
                                        OD;
                                        REF INT di = d[i];
                                        
                                        INT val = di + carry * 10;
                                        
                                        (di := val OVER a, carry := val MOD a);
                                        i +:= 1
                                     OD
                               END;
                            
                            # Actual subfixed # neg := v < 0;
                            REAL x := IF neg
                            THEN REAL x = -v;
                                 
                                 IF -x /= v
                                 THEN warning ("", "-", x, -x, v)
                                 FI;
                                 x
                            ELSE v
                            FI,
                            INT exp := 0;
                            
                            DEC dc := zero ((INT m = 10 LN x + after + 1; m > real width | m | real width) + 10 LN REAL (max exp * 1 + max mant * 2) + 1);
                            
                            # We keep the following invariant:
                                        |v| = (x + |dc|) * b ** exp
                                    #
                            
                            # First we make 'x' zero #
                            IF x > 0
                            THEN TO max exp 
                                 WHILE x < 1
                                 DO REAL y = x * b;
                                    
                                    exp -:= 1;
                                    IF y / b /= x
                                    THEN warning (y, "/", b, y / b, x)
                                    FI;
                                    x := y
                                 OD;
                                 IF x < 1
                                 THEN sloppy (x, "< 1", max exp)
                                 FI;
                                 TO max exp 
                                 WHILE NOT (x < 1)
                                 DO REAL y = x / b;
                                    
                                    exp +:= 1;
                                    IF y * b /= x
                                    THEN warning (y, "*", b, y * b, x)
                                    FI;
                                    x := y
                                 OD;
                                 IF NOT (x < 1)
                                 THEN sloppy (x, ">= 1", max exp)
                                 FI;
                                 # Now 1/b <= x < 1 #
                                 TO max mant 
                                 WHILE x > 0
                                 DO (x := x * b, dc *:= b, exp -:= 1);
                                    INT dig = ENTIER x;
                                    
                                    IF dig < 0
                                    THEN warning ("", "ENTIER", x, dig, ">= 0")
                                    FI;
                                    IF dig >= b
                                    THEN warning ("", "ENTIER", x, dig, "< b")
                                    FI;
                                    REAL y = x - dig;
                                    
                                    dc +:= dig;
                                    IF y >= 1
                                    THEN warning (x, "-", dig, y, "< 1")
                                    FI;
                                    IF y + dig /= x
                                    THEN warning (y, "+", dig, y + dig, x)
                                    FI;
                                    x := y
                                 OD;
                                 IF x > 0
                                 THEN sloppy (x, "> 0", max mant)
                                 FI
                            FI;
                            # Now x = 0, and consequently  |v| = |dc| * b ** exp #
                            
                            # Second we make 'exp' 0 #
                            WHILE exp > 0
                            DO (dc *:= b, exp -:= 1)
                            OD;
                            WHILE exp < 0
                            DO (dc /:= b, exp +:= 1)
                            OD;
                            # Now  |v| = |dc|, i.e. 'v' has been converted to decimal #
                            
                            # We shall now fill 's' from 'dc' in the required format #
                            OP ELEM = (INT i, REF [] INT d) CHAR:
                               "0123456789"[(i < 1 | 0 |: i > UPB d | 0 | d[i]) + 1];
                            
                            IF floating
                            THEN print ((newline, "Floating version not implemented", newline));
                                 SKIP
                            ELSE REF [] INT d = d OF dc,
                                 INT p = p OF dc;
                                 
                                 [UPB d] CHAR s;
                                 
                                 INT i := 0;
                                 
                                 FOR k TO p 
                                 DO CHAR ch = k ELEM d;
                                    
                                    IF i = 0 AND ch = "0"
                                    THEN SKIP
                                    ELSE s[i +:= 1] := ch
                                    FI
                                 OD;
                                 point := i;
                                 FOR k FROM p + 1 TO p + after + 1 
                                 DO s[i +:= 1] := k ELEM d
                                 OD;
                                 s[1 : point + after + 1]
                            FI
                      END # subfixed # ;
                 
                 PROC round = (INT k, REF STRING s) BOOL:
                      IF BOOL carry := char dig (s[k + 1]) >= 5;
                         
                         s := s[ : k];
                         carry
                      THEN FOR j FROM k BY -1 TO 1 
                           WHILE carry
                           DO INT d = char dig (s[j]) + 1;
                              
                              carry := d = 10;
                              s[j] := (carry | "0" | "0123456789"[d + 1])
                           OD;
                           (carry | "1" PLUSTO s);
                           carry
                      ELSE FALSE
                      FI;
                 
                 PROC char dig = (CHAR c) INT:
                      (INT i;
                       
                       char in string (c, i, "0123456789");
                       i - 1);
                 
                 # Actual fixed #
                 IF # no value can be converted legally with these parameters: #
                    after < 0 OR width < 0 AND after > -width - 1 OR width > 0 AND after > width - 2
                 THEN (width = 0 | 1 | ABS width) * error char
                 ELIF INT point,
                      BOOL neg;
                      
                      STRING s := subfixed (v, after, point, neg, FALSE);
                      
                      STRING sign = (neg | "-" |: width > 0 | "+" | "");
                      
                      width = 0
                 THEN (round (UPB s - 1, s) | point +:= 1);
                      (UPB s = 0 | s := "0"; point := 1);
                      sign + (point = UPB s | s | s[ : point] + "." + s[point + 1 : ])
                 ELSE INT w = ABS width - UPB sign;
                      
                      INT tail = (INT lim = w - point - 1 + (w = point AND point > 0 | 1 | 0);
                                  
                                  (lim < after | lim | after));
                      
                      IF tail < 0
                      THEN ABS width * error char
                      ELSE s := s[ : point + tail + 1];
                           (round (UPB s - 1, s) | point +:= 1);
                           (UPB s = 0 | s := "0"; point := 1);
                           INT space = w - UPB s - (point = UPB s | 0 | 1);
                           
                           IF space < 0 AND tail = 0
                           THEN ABS width * error char
                           ELSE IF space < 0
                                THEN s := s[ : UPB s - 1]
                                ELIF space >= 1 AND point = 0
                                THEN "0" PLUSTO s;
                                     point +:= 1
                                FI;
                                s := sign + (point = UPB s | s | s[ : point] + "." + s[point + 1 : ]);
                                (ABS width - UPB s) * " " + s
                           FI
                      FI
                 FI
           END # fixed 1 # ;
      
      # Testing equipment #
      PROC t0 = VOID:
           BEGIN FOR v TO UPB vals 
                 DO REAL value = vals[v];
                    
                    t1 (value);
                    IF value > 0
                    THEN t1 (DOWN value);
                         t1 (UP value)
                    FI
                 OD;
                 TO 20 
                 DO t4 (wild real)
                 OD;
                 t4 (max real)
           END;
      
      PROC t1 = (REAL v) VOID:
           FOR width FROM -4 TO 9 
           DO t2 (-v, -width);
              t2 (v, -width)
           OD;
      
      PROC t2 = (REAL v, INT width) VOID:
           BEGIN FOR after FROM -1 TO 4 
                 DO t3 (v, width, after)
                 OD;
                 IF width = 0
                 THEN t4 (v)
                 FI
           END;
      
      PROC t3 = (REAL v, INT width, after) VOID:
           IF STRING s1 = fixed (v, width, after), s2 = fixed 1 (v, width, after);
              
              s1 /= s2
           THEN print ((v, whole (width, -4), whole (after, -4), ", is """, s1, """, must be """, s2, """", newline))
           FI;
      
      PROC t4 = (REAL v) VOID:
           t3 (v, 0, real width + 1);
      
      OP DOWN = (REAL x) REAL:
         (REAL y := x;
          
          FOR i 
          WHILE x = y
          DO y := x * (1 - i * small real)
          OD;
          y);
      
      OP UP = (REAL x) REAL:
         (REAL y := x;
          
          FOR i 
          WHILE x = y
          DO y := x * (1 + i * small real)
          OD;
          y);
      
      PROC wild real = REAL:
           exp (random * real width + ln (10));
      
      [] REAL vals = (0.0, 0.01, 0.0449, 0.4449, 0.9945, 9.945, 99.45, 100);
      
      t0
END