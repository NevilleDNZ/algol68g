COMMENT Example input for this nano-LISP interpreter
1 b 3 d
evaluate append (+ 1 2) (a b)
(+ 1 2)
* 2 (+ 1 (^ 2 3))
quit
COMMENT

PR echo "[3] Nano-LISP interpreter" PR
   
# Data structure to represent a list #

MODE VALUE  = UNION (ATOM, LIST),
     ATOM   = STRING, 
     LIST   = REF NODE,
     NODE   = STRUCT (VALUE head, tail);

LIST no list = NIL;

OP NOLIST = (VALUE v) BOOL: 
  (v | (LIST l): l IS no list | FALSE);

OP HEAD = (VALUE v) VALUE:
  (v | (LIST l): (NOLIST l | no list | head OF l) | no list);

OP TAIL = (VALUE v) VALUE:
  (v | (LIST l): (NOLIST l | no list | tail OF l) | no list);

OP NUMBER = (VALUE v) INT:
  CASE v
  IN (ATOM a): 
       BEGIN # use transput library for conversion # 
         FILE g, INT n;
         associate (g, NEW ATOM := a);
         get (g, n);
         close (g);
         n
       END,
     (LIST l): 
       (NOLIST l | SKIP | NUMBER HEAD l)
  ESAC;

OP NUMBER = (INT n) ATOM: whole (n, 0);

OP CONS = (VALUE v, w) VALUE: NEW NODE := (v, w);

PRIO CONS = 9;

OP + = (VALUE v, w) VALUE:
   CASE v
   IN (ATOM a): v CONS (w | (ATOM): w, (LIST): HEAD w),
      (LIST k): 
        IF NOLIST k
        THEN w
        ELSE HEAD k CONS IF NOLIST TAIL k
                         THEN (w | (ATOM): w, (LIST): HEAD w)
                         ELSE TAIL k + w
                         FI
        FI
   ESAC;

PROC print value = (VALUE v) VOID:
  CASE v
  IN (ATOM a): print (a),
     (LIST l): 
       IF NOLIST l 
       THEN print ("nil") 
       ELSE PROC print list = (LIST l) VOID:
              CASE print value (HEAD l);
                TAIL l
              IN (ATOM a): (print (blank); print value (a)),
              (LIST k): (~ NOLIST k | print (blank); print list (k))
              ESAC;
            print ("("); print list (l); print (")")
       FI
  ESAC;

OP EVAL = (VALUE v) VALUE:
  CASE v
  IN (ATOM a): a,
     (LIST k): IF NOLIST k
               THEN no list
               ELSE CASE HEAD k
                    IN (ATOM a): interpreter (a, TAIL k),
                       (LIST l): EVAL HEAD k CONS EVAL TAIL k
                    ESAC
               FI
  ESAC;

PROC interpreter = (ATOM cmd, VALUE arg) VALUE:
  IF BOOL found := FALSE, VALUE v;
    [] STRUCT (STRING cmd, PROC (VALUE) VALUE action) table =
      (("'", (VALUE arg) VALUE: HEAD arg), 
       ("+", (VALUE arg) VALUE: NUMBER (NUMBER EVAL HEAD arg + NUMBER EVAL TAIL arg)),
       ("-", (VALUE arg) VALUE: NUMBER (NUMBER EVAL HEAD arg - NUMBER EVAL TAIL arg)),
       ("*", (VALUE arg) VALUE: NUMBER (NUMBER EVAL HEAD arg * NUMBER EVAL TAIL arg)),
       ("/", (VALUE arg) VALUE: NUMBER (NUMBER EVAL HEAD arg OVER NUMBER EVAL TAIL arg)),
       ("^", (VALUE arg) VALUE: NUMBER (NUMBER EVAL HEAD arg ** NUMBER EVAL TAIL arg)),
       ("append", (VALUE arg) VALUE: EVAL HEAD arg + EVAL TAIL arg),
       ("evaluate", (VALUE arg) VALUE: EVAL arg),
       ("quit", (VALUE arg) VALUE: stop)
      );
    FOR k TO UPB table WHILE ~found
    DO (found := cmd = cmd OF table[k] | v := (action OF table[k]) (arg))
    OD;
    found
  THEN v
  ELSE cmd CONS arg
  FI;

# Driver program executes commands at top of file #

FILE f;
VOID (open (f, program idf, standin channel));
get (f, new line);
DO STRING s, INT i;
   get (f, (s, new line));
   i := LWB s;

   PROC to rpn = VALUE:
     IF WHILE i <= UPB s 
        THEF is space (s[i])
        DO i +:= 1
        OD;
        i > UPB s
     THEN no list
     ELIF s[i] = ")"
     THEN i +:= 1;
          no list
     ELIF s[i] = "("
     THEN i +:= 1;
          VALUE lhs := to rpn;
          VALUE rhs := to rpn;
          lhs CONS rhs
     ELSE STRING arg := s[i];
          i +:= 1;
          WHILE i <= UPB s 
          THEF is alnum (s[i])
          DO arg +:= s[i];
             i +:= 1
          OD;
          VALUE lhs := NEW VALUE := arg;
          VALUE rhs := to rpn;
          lhs CONS rhs
     FI;

   VALUE l := to rpn;
   print value (l);
   new line (stand out);
   print value (EVAL l);
   new line (stand out)
OD
