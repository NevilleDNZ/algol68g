# This program is part of the Revised Mathematisch Centrum Algol 68 Test Set
  by Dick Grune [1979].
 
  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.
 
  The complete test set is an open-access publication, 
  self-archived by Dick Grune and available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #
 
#numr05#
BEGIN # JKok, 730620, test least squares procedures,
          740919, tested on Control Data A68 Compiler, results OK #
      MODE TOLS = STRUCT (REAL prec, max),
      OP * = ([] REAL a, b) REAL:
         (REAL s := 0;
          
          FOR i TO UPB a 
          DO s +:= a[i] * b[i]
          OD;
          s),
      OP * = (REAL a, [] REAL b) [] REAL:
         ([1 : UPB b] REAL c;
          
          FOR i TO UPB b 
          DO c[i] := a * b[i]
          OD;
          c),
      OP +:= = (REF [] REAL a, [] REAL b) REF [] REAL:
         (FOR i TO UPB a 
          DO a[i] +:= b[i]
          OD;
          a);
      
      PROC lsqdec = (REF [, ] REAL a, REF TOLS aux, REF [] REAL aid, REF [] INT ci) INT:
           IF INT n = 1 UPB a, m = 2 UPB a;
              
              UPB aid /= m OR UPB ci /= m
           THEN -1
           ELSE INT r := 0, minmn := (m < n | m | n), pk := 1,
                REAL w, eps, sigma := 0, aidk, beta,
                [1 : m] REAL sum;
                
                FOR k TO m 
                DO IF (w := sum[k] := a[, k] * a[, k]) > sigma
                   THEN sigma := w;
                        pk := k
                   FI
                OD;
                w := max OF aux := sqrt (sigma);
                eps := (prec OF aux) * w;
                FOR k TO minmn 
                WHILE w > eps
                DO REAL akk = a[k, pk];
                   
                   r := k;
                   ci[k] := pk;
                   IF pk /= k
                   THEN [] REAL h = a[, k];
                        
                        a[, k] := a[, pk];
                        a[, pk] := h;
                        sum[pk] := sum[k]
                   FI;
                   aidk := aid[k] := (akk < 0 | w | -w);
                   a[k, k] := akk - aidk;
                   beta := -1 / (sigma - akk * aidk);
                   pk := k;
                   sigma := 0;
                   FOR j FROM k + 1 TO m 
                   DO a[k : , j] +:= beta * (a[k : , k] * a[k : , j]) * a[k : , k];
                      IF (w := sum[j] -:= a[k, j] ** 2) > sigma
                      THEN pk := j;
                           sigma := w
                      FI
                   OD;
                   w := sqrt (sigma)
                OD;
                r
           FI
      # end of householder triangularization #
      ,
      PROC lsqsol = ([, ] REAL a, [] REAL aid, [] INT ci, [] REAL b) [] REAL:
           BEGIN INT n = 1 UPB a, m = 2 UPB a,
                 INT cik;
                 
                 [1 : n] REAL bb := b;
                 
                 IF m <= n
                 THEN FOR k TO m 
                      DO bb[k : ] +:= a[k : , k] * bb[k : ] / (aid[k] * a[k, k]) * a[k : , k]
                      OD;
                      FOR k FROM m BY -1 TO 1 
                      DO bb[k] := (bb[k] - a[k, k + 1 : ] * bb[k + 1 : m]) / aid[k]
                      OD;
                      FOR k FROM m - 1 BY -1 TO 1 
                      DO IF cik := ci[k];
                            cik /= k
                         THEN REAL w = bb[k];
                              
                              bb[k] := bb[cik];
                              bb[cik] := w
                         FI
                      OD
                 FI;
                 bb
           END
      # of computation of least squares solution #
      ;
      
      FOR n FROM 4 TO 6 
      DO FOR m TO n 
         DO [1 : n, 1 : m] REAL a,
            [1 : n] REAL b,
            [1 : m] REAL aid,
            [1 : m] INT piv,
            TOLS aux;
            
            FOR i TO n 
            DO FOR j TO m 
               DO a[i, j] := i ** (j - 1)
               OD
            OD;
            FOR i TO n 
            DO b[i] := i ** (n - 1)
            OD;
            prec OF aux := 1e-10;
            print (newline);
            print ("n =");
            print (n);
            print (newline);
            print ("m =");
            print (m);
            print (new line);
            IF lsqdec (a, aux, aid, piv) < m
            THEN print (" rank < number of columns")
            ELSE [1 : n] REAL sol := lsqsol (a, aid, piv, b);
                 
                 print (" solution :");
                 FOR k TO m 
                 DO print ((fixed (sol[k], 0, 4), blank))
                 OD;
                 print (newline);
                 print (" residue : ");
                 print (fixed (sol[m + 1 : ] * sol[m + 1 : ], 0, 4));
                 print (newline);
                 print (newline)
            FI
         # Output approximately:
         sol: 25.0  res: 2390.0
         sol:  -27.0  20.8  res:  226.8
         sol:  10.5  -16.7  7.5  res:  1.8
         sol:  0.0  0.0  0.0  1.0  res:  0.0
         sol:  195.8  res:  271290.8
         sol:  -250.6  148.8  res:  49876.4
         sol:  158.4  -201.77  58.43  res:  2081.83
         sol:  -43.2  81.43  -49.57  12.0  res:  8.23
         sol:  0.0  0.0  0.0  0.0  1.0  res:  0.0
         sol:  2033.5  res:  46529717.5
         sol:  -2860.0  1398.14  res:  12320657.14
         sol:  2250.0  -2434.36  547.5  res:  1129757.14
         sol:  -1040.0  1704.25  -823.3  130.56  res:  25257.14
         sol:  220.0  -465.75  344.17  -114.44  17.50  res:  57.14
         sol:  0.0  0.0  0.0  0.0  0.0  1.0  res:  0.0    #
         OD
      OD
END