<!-- RRHeader -->
<html>
<head>
<title>Revised Report on the Algorithmic Language Algol 68 - Algol 68 Genie</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: arial, sans-serif;}
u {font-size: 10pt; font-family: arial, sans-serif;}
dd {font-size: 10pt; font-family: arial, sans-serif;}
h1 {font-size: 14pt; font-family: arial, sans-serif;}
h2 {font-size: 12pt; font-family: arial, sans-serif;}
h3 {font-size: 10pt; font-family: arial, sans-serif;}
h4 {font-size: 10pt; font-family: arial, sans-serif;}
td {font-size: 10pt; font-family: arial, sans-serif;}
ul {font-size: 10pt; font-family: arial, sans-serif;}
body {font-size: 10pt; font-family: arial, sans-serif;}
tt {font-size: 10pt; font-family: "courier new", monospace;}
code {font-size: 10pt; font-family: "courier new", monospace;}
var {font-size: 10pt; font-weight: normal; font-style: normal; font-family: "courier new", monospace; color: darkred;}
pre {font-size: 10pt; font-family: "courier new", monospace;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>
<b>Revised Report on the Algorithmic Language Algol 68</b>
</small>
</td>
</table>


<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>
Algol 68 Revised Report
</h2>
<h3>
PART III - Context Dependence
</h3>
</td>
<td width="30%" bgcolor="white" valign=top align=center>
<img src="algol68.gif" align=center>
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<p>
<a href="algol.html"><small><b>A68G Home</b></small></a>
<p>
<a href="report_contents.html"><small><b>Revised Report</b></small></a>
<p>
<a href="algol.html#obtaining"><small><b>Downloads</b></small></a>
</td>
</tr>
</table>
<!-- End navigation bar -->
</td>
</table>

<p>
{This Part deals with those rules which do not alter the underlying syntactical structure:

<ul>
<li> the transformations of modes implicitly defined by the context, with their accompanying actions;
<li> the syntax needed for the equivalence of modes and for the safe application of the properties kept in the nests.}
</ul>

<h3>
<a name=6></a>6. Coercion
</h3>

<p>
{The coercions produce a <b>coercend</b> from a <b>coercee</b> according to three criteria: the a priori mode of the <b>coercend</b> before the application of any coercion, the a posteriori mode of the <b>coercee</b> required after those coercions, and the syntactic position or  "sort" of the <b>coercee</b>. Coercions may be cascaded.

<p>
There are six possible coercions, termed "deproceduring", "dereferencing",  "uniting", "widening", "rowing" and "voiding". Each coercion, except "uniting", prescribes a corresponding dynamic effect on the associated values. Hence, a number of primitive actions can be programmed implicitly by coercions.}

<h3>
<a name=61></a>6.1. Coercees
</h3>

<p>
{A <b>coercee</b> is a construct whose production tree may begin a sequence of coercions ending in a <b>coercend</b>. The order of (completion of) the elaboration of the coercions is therefore from the <b>coercend</b> to the <b>coercee</b> (hence the choice of these paranotions). For example, <tt>i</tt> in <tt>REAL (i)</tt> is a <b>coercee</b>  whose production tree involves <b>'widened to'</b> and <b>'dereferenced to'</b>, in that order, in passing from the <b>coercee</b> to the <b>coercend</b>. Note that the dereferencing must be completed before the widening takes place.

<p>
The relevant production tree (with elision of <b>'NEST'</b>, <b>'applied'</b>  and <b>'with TAG'</b>, and with invisible subtrees omitted) is:
<pre>
                            <b>'strong real identifier coercee'</b>
                             |
                             | <a href="report_3.html#611a">6.1.1.a</a>
                             |
 --------------------------><b>'widened to real identifier'</b>
 |                           |
widening coercion            | <a href="report_3.html#651a">6.5.1.a</a>
 |                           |
 |--------------------------<b>'dereferenced to integral identifier'</b>
 |                           |
dereferencing coercion       | <a href="report_3.html#621a">6.2.1.a</a>
 |                           |
 ---------------------------<b>'unchanged from reference to integral identifier'</b>
                             |
                             | <a href="report_3.html#611f">6.1.1.f</a>
                             |
                            <b>'reference to integral identifier' (coercend)</b>
                             |
                             | <a href="report_2.html#481b">4.8.1.b</a>
                             |
                            <b>'letter i symbol'</b>. }
</pre>
<p>
}

<h3>
<a name=611></a>6.1.1. Syntax
</h3>

<p>
<a name=611A></a>A) <b>STRONG</b> {a, <a href="report_3.html#661a">66a</a> } <b>:: FIRM</b> {B}<b>; widened to</b> {<a href="report_3.html#651a">65a, b, c, d</a>} <b>; rowed to</b> {<a href="report_3.html#661a">66a</a>} <b>; voided to</b> {<a href="report_3.html#671a">67a, b</a> } <b>.</b>
<br>
<a name=611B></a>B) <b>FIRM</b> {A, b}<b> :: MEEK</b> {c}<b>; united to</b> {<a href="report_3.html#641a">64a</a> } <b>.</b>
<br>
<a name=611C></a>C) <b>MEEK</b> {B, c, d, <a href="report_3.html#621a">62a</a> , <a href="report_3.html#631a">63a</a>, <a href="report_3.html#641a">64a</a>, <a href="report_3.html#651a">65a, b, c, d</a>} <b>:: unchanged from</b> {f}<b>; dereferenced to</b> {<a href="report_3.html#621a">62a</a> } <b>; deprocedured to</b> {<a href="report_3.html#631a">63a</a> } <b>.</b>
<br>
<a name=611D></a>D) <b>SOFT</b> {e, <a href="report_3.html#631b">63b</a> } <b>:: unchanged from</b> {f}<b>; softly deprocedured to</b> {<a href="report_3.html#631b">63b</a> } <b>.</b>
<br>
<a name=611E></a>E) <b>FORM :: MORF ; COMORF.</b>
<br>
<a name=611F></a>F) <b>MORF :: NEST selection ; NEST slice ; NEST routine text ; NEST ADIC formula ; NEST call ; NEST applied identifier with TAG.</b>
<br>
<a name=611G></a>G) <b>COMORF :: NEST assignation ; NEST identity relation ;  NEST LEAP generator ; NEST cast ; NEST denoter ; NEST format text.</b>
<br>
<a name=611a></a>a) <b>strong MOID FORM coercee</b> {<a href="report_2.html#51A">5A, B, C, D</a>  , <a href="report_5.html#A3411i">A341i</a>} <b>: where (FORM) is (MORF), STRONG 
{A} MOID MORF ; where (FORM) is (COMORF), STRONG {A} MOID COMORF, unless (STRONG MOID) is (deprocedured to void).</b>
<br>
<a name=611b></a>b) <b>firm MODE FORM coercee</b> {<a href="report_2.html#51A">5A, B, C, D</a>  , <a href="report_2.html#5421c">542c</a>} <b>: FIRM</b> {B}<b> MODE FORM.</b>
<br>
<a name=611c></a>c) <b>meek MOID FORM coercee</b> {<a href="report_2.html#51A">5A, B, C, D</a>} <b>: MEEK</b> {C}<b> MOID FORM.</b>
<br>
<a name=611d></a>d) <b>weak REFETY STOWED FORM coercee</b> {<a href="report_2.html#51A">5A, B, C, D</a>} <b>: MEEK</b> {C}<b> REFETY STOWED FORM, unless (MEEK) is (dereferenced to) and (REFETY) is (EMPTY).</b>
<br>
<a name=611e></a>e) <b>soft MODE FORM coercee</b> {<a href="report_2.html#51A">5A, B, C, D</a>} <b>: SOFT</b> {D}<b> MODE FORM.</b>
<br>
<a name=611f></a>f) <b>unchanged from MOID FORM</b> {C, D, <a href="report_3.html#671a">67a, b</a> } <b>: MOID FORM.</b>
<br>
<a name=611g></a>g) <b>*SORT MOID coercee : SORT MOID FORM coercee</b> {a, b, c, d, e}<b>.</b>
<br>
<a name=611h></a>h) <b>*MOID coercend : MOID FORM.</b>

<p>
<pre>
{Examples:
a) 3.14 (in x := 3.14)
b) 3.14 (in x + 3.14)
c) sin (in sin (x))
d) x1 (in x1[2] := 3.14)
e) x (in x := 3.14) }
</pre>

<p>
{For <b>'MOID FORM'</b>  (rule f), see the cross-references inserted in sections <a href="report_2.html#51A">5.1.A, B, C, D</a> before "<b>coercee</b>". Note, however, that a <b>'MOID FORM'</b> may be a blind alley. Blind alleys within this chapter are not indicated.}

<p>
{There are five sorts of syntactic position. They are:
<ul>
<li> "strong" positions, i.e., <b>actual-parameters</b>, e.g., <tt>x</tt> in <tt>sin (x)</tt>, <b>sources</b>, e.g., <tt>x</tt> in <tt>y := x</tt>, the <b>ENCLOSED-clause</b> of a <b>cast</b>, e.g., <tt> (NIL)</tt> in <tt>REF BOOK (NIL)</tt>, and statements, e.g., <tt>y := x</tt> in <tt> (y := x; x :=  0)</tt>;
<li> "firm" positions, i.e., <b>operands</b>, e.g., <tt>x</tt> in <tt>x +  y</tt>;
<li> "meek" positions, i.e., <b>enquiry-clauses</b>, e.g., <tt>x &gt; 0</tt> in <tt> (x &gt; 0 | x | 0)</tt>, <b>boundscripts</b>, e.g., <tt>i</tt> in <tt>x1  [i]</tt>, and the <b>PRIMARY</b> of a <b>call</b>, e.g., <tt>sin</tt> in <tt>sin (x)</tt>;
<li> "weak" positions, i.e., the <b>SECONDARY</b> of a <b>selection</b> and the <b>PRIMARY</b> of a <b>slice</b>, e.g., <tt>x1</tt> in <tt>x1 [i]</tt>;
<li> "soft" positions, i.e., <b>destinations</b>, e.g., <tt>x</tt> in <tt>x :=  y</tt> and one of the <b>TERTIARY</b>s of an <b>identity-relation</b>, e.g.,  <tt>x</tt> in <tt>xx :=: x</tt>.
</ul>

<p>
Strong positions also arise in balancing {<a href="report_2.html#321e">3.2.1.e</a>}.

<p>
In strong positions, all six coercions may occur; in firm positions, rowing, widening and voiding are forbidden; in meek and weak positions, uniting is forbidden also, and in soft positions only deproceduring is allowed. However, a <b>dereferenced-to-STOWED-FORM</b> may not be directly descended from a <b>weak-STOWED-FORM-coercee</b> (rule d) for, otherwise, <tt>x := x1 [i]</tt>  would be syntactically ambiguous (although, in this case, not semantically). Also, a <b>deprocedured-to-void-COMORF</b> may not be directly descended from a <b>strong-void-COMORF-coercee</b> (rule a) for, otherwise,
<pre> (PROC VOID engelfriet; PROC VOID rijpens = SKIP; engelfriet := rijpens; SKIP)</pre>
would be ambiguous.}

<h3>
<a name=62></a>6.2. Dereferencing
</h3>

<p>
{Dereferencing serves to obtain the value referred to by a name, as in <tt>x := y</tt>, where <tt>y</tt> yields a name referring to a real number and it is this number which is assigned to the name yielded by <tt>x</tt>. The a priori mode of <tt>y, </tt> regarded as a <b>coercend</b>, is <b>'reference to real'</b> and its a posteriori mode, when <tt>y</tt> is regarded as a <b>coercee</b>, is <b>'real'</b>.}

<h3>
<a name=621></a>6.2.1. Syntax
</h3>

<p>
<a name=621a></a>a) <b>dereferenced to</b> {<a href="report_3.html#611C">61C</a> } <b>MODE1 FORM : MEEK</b> {<a href="report_3.html#611C">61C</a>} <b>REF to MODE2 FORM, where MODE2 deflexes to MODE1</b> {<a href="report_2.html#471a">47a, b, c</a>  , -}<b>.</b>

<p>
<pre>
{Example:
a) x (in REAL (x)) }
</pre>

<h3>
<a name=622></a>6.2.2. Semantics
</h3>

<p>
The yield <i>W</i> of a <b>dereferenced-to-MODE-FORM</b> <i>F</i> is determined as follows:
<ul>
<li> let {the name} <i>N</i> be the yield of the <b>MEEK-FORM</b> of <i>F</i>;
<li> it is required that <i>N</i> be not nil;
<li> <i>W</i> is the value referred to by <i>N</i>.
</ul>

<h3>
<a name=63></a>6.3. Deproceduring
</h3>

<p>
{Deproceduring is used when a routine without parameters is to be called. E.g., in <tt>x := random</tt>, the routine yielded by <tt>random</tt> is called and the real number yielded is assigned;  the a posteriori mode of <tt>random</tt> is <b>'real'</b>. Syntactically, an initial <b>'procedure yielding'</b> is removed from the a priori mode.}

<h3>
<a name=631></a>6.3.1. Syntax
</h3>

<p>
<a name=631a></a>a) <b>deprocedured to</b> {<a href="report_3.html#611C">61C</a> , <a href="report_3.html#671a">67a</a>} <b>MOID FORM : MEEK</b> {<a href="report_3.html#611C">61C</a> } <b>procedure yielding MOID FORM.</b>
<br>
<a name=631b></a>b) <b>softly deprocedured to</b> {<a href="report_3.html#611D">61D</a> } <b>MODE FORM : SOFT</b> {<a href="report_3.html#611D">61D</a> } <b>procedure yielding MODE FORM.</b>

<p>
<pre>
{Examples:
a) random (in REAL (random))
b) x or y (in x or y := 3.14, see <a href="report_1.html#112">1.1.2</a>) }
</pre>

<h3>
<a name=632></a>6.3.2. Semantics
</h3>

<p>
The yield <i>W</i> of a <b>deprocedured-to-MOID-FORM</b> or <b>softly-deprocedured-to-MOID-FORM</b>  <i>F</i>, in an environ <i>E</i>, is determined as follows:
<ul>
<li> let {the routine} <i>R</i> be the yield in <i>E</i> of the direct descendent of <i>F</i>;
<li> <i>W</i> is the yield of the calling {<a href="report_2.html#5432b">5.4.3.2.b</a>} of <i>R</i> in <i>E</i>;
<li> it is required that <i>W</i> be not newer in scope than <i>E</i>.
</ul>

<h3>
<a name=64></a>6.4. Uniting
</h3>

<p>
{Uniting does not change the mode of the run-time value yielded by a construct, but simply gives more freedom to it. That value must be acceptable to not just that one mode, but rather to the whole of a given set of modes. However, after uniting, that value may be subject to a primitive action only after being dynamically tested in a <b>conformity-clause</b> {<a href="report_2.html#341q">3.4.1.q</a>}; indeed, no primitive action can be programmed with a construct of a <b>'UNITED'</b> mode (except to assign it to a <b>UNITED-variable</b>, of course).
<br>
Example:
<pre>
UNION (BOOL, CHAR) t, v;
t := "a"; t := TRUE; v := t. }
</pre>

<h3>
<a name=641></a>6.4.1. Syntax
</h3>

<p>
<a name=641a></a>a) <b>united to</b> {<a href="report_3.html#611B">61B</a> } <b>UNITED FORM : MEEK</b> {<a href="report_3.html#611C">61C</a>} <b>MOID FORM, where MOID unites to UNITED</b> {b}<b>.</b>
<br>
<a name=641b></a>b) <b>WHETHER MOID1 unites to MOID2</b> {a, <a href="report_2.html#341i">34i</a> , <a href="report_3.html#711m">71m</a>} <b>: where MOID1 equivalent MOID2</b> {<a href="report_3.html#731a">73a</a> } <b>, WHETHER false ; unless MOID1 equivalent MOID2</b> {<a href="report_3.html#731a">73a</a> } <b>, WHETHER safe MOODS1 subset of safe MOODS2</b> {<a href="report_3.html#731l">73l, m, n</a>} <b>, where (MOODS1) is (MOID1) or (union of MOODS1 mode) is (MOID1), where (MOODS2) is (MOID2) or (union of MOODS2 mode) is (MOID2).</b>

<p>
<pre>
{Examples:
a) x (in uir := x) &bull;
      u (in UNION (CHAR, INT, VOID) (u), in a reach containing UNION (INT, VOID) u := EMPTY) }
</pre>

<h3>
<a name=65></a>6.5. Widening
</h3>

<p>
{Widening transforms integers to real numbers, real numbers to complex numbers (in both cases, with the same size), a value of mode <b>'BITS'</b> to an unpacked vector of truth values, or a value of mode <b>'BYTES'</b> to an unpacked vector of characters.
<br>
For example, in <tt>z := 1</tt>, the yield of <tt>1</tt> is widened to the real number 1.0 and then to the complex number (1.0, 0.0); syntactically, the a priori mode specified by <tt>INT</tt> is changed to that specified by <tt>REAL</tt> and then to that specified by <tt>COMPL</tt>.}

<h3>
<a name=651></a>6.5.1. Syntax
</h3>

<p>
<a name=651A></a>A) <b>BITS :: structured with row of boolean field SITHETY letter aleph mode.</b>
<br>
<a name=651B></a>B) <b>BYTES :: structured with row of character field SITHETY letter aleph mode.</b>
<br>
<a name=651C></a>C) <b>SITHETY :: LENGTH LENGTHETY ; SHORTH SHORTHETY ;  EMPTY.</b>
<br>
<a name=651D></a>D) <b>LENGTH :: letter l letter o letter n letter g.</b>
<br>
<a name=651E></a>E) <b>SHORTH :: letter s letter h letter o letter r letter t.</b>
<br>
<a name=651F></a>F) <b>LENGTHETY :: LENGTH LENGTHETY ; EMPTY.</b>
<br>
<a name=651G></a>G) <b>SHORTHETY :: SHORTH SHORTHETY ; EMPTY.</b>
<br>
<a name=651a></a>a) <b>widened to</b> {b, <a href="report_3.html#611A">61A</a> } <b>SIZETY real FORM : MEEK</b> {<a href="report_3.html#611C">61C</a> } <b>SIZETY integral FORM.</b>
<br>
{<b>SIZETY :: long LONGSETY ; short SHORTSETY ; EMPTY.</b>}
<br>
<a name=651b></a>b) <b>widened to</b> {<a href="report_3.html#611A">61A</a> } <b>structured with SIZETY real field letter r letter e SIZETY real field letter i letter m mode FORM : MEEK</b> {<a href="report_3.html#611C">61C</a> } <b>SIZETY real FORM ; widened to {a} SIZETY real FORM.</b>
<br>
<a name=651c></a>c) <b>widened to</b> {<a href="report_3.html#611A">61A</a> } <b>row of boolean FORM : MEEK</b> {<a href="report_3.html#611C">61C</a> } <b>BITS FORM.</b>
<br>
<a name=651d></a>d) <b>widened to</b> {<a href="report_3.html#611A">61A</a> } <b>row of character FORM : MEEK</b> {<a href="report_3.html#611C">61C</a> } <b>BYTES FORM.</b>

<p>
<pre>
{Examples:
a) 1 (in x := 1)
b) 1.0 (in z := 1.0) &bull; 1 (in z := 1)
c) 2r101 (in [ &nbsp; ] BOOL (2r101))
d) r (in [ &nbsp; ] CHAR (r), see <A href="report_1.html#112">1.1.2</a>)
</pre>

<h3>
<a name=652></a>6.5.2. Semantics
</h3>

<p>
The yield <i>W</i> of a <b>widened-to-MODE-FORM</b> <i>F</i> is determined as follows:
<br>
&bull; let <i>V</i> be the yield of the direct descendent of <i>F</i>;
<br>
<a name=652cA></a>
Case A: <b>'MODE'</b> is some <b>'SIZETY real'</b>:
<ul>
<li> <i>W</i> is the real number widenable from {<a href="report_1.html#2131e">2.1.3.1.e</a>} <i>V</i>;
</ul>
<a name=652cB></a>
Case B: <b>'MODE'</b> is some <b>'structured with SIZETY real letter r letter e SIZETY real letter i letter m mode'</b>:
<ul>
<li> <i>W</i> is {the complex number which is} a structured value whose fields are respectively <i>V</i> and the real number 0 of the same size {<a href="report_1.html#2131b">2.1.3.1.b</a>} as <i>V</i>;
</ul>
<a name=652cC></a>
Case C: <b>'MODE'</b> is <b>'row of boolean'</b> or <b>'row of character'</b>:
<ul>
<li> <i>W</i> is the {only} field of <i>V</i>.
</ul>

<h3>
<a name=66></a>6.6. Rowing
</h3>

<p>
{Rowing permits the building of a multiple value from a single element. If the latter is a name then the result of rowing may also be a name referring to that multiple value.
<br>
Example:
<pre>
[1 : 1] REAL b1 := 4.13 }
</pre>

<h3>
<a name=661></a>6.6.1. Syntax
</h3>

<p>
<a name=661a></a>a) <b>rowed to</b> {<a href="report_3.html#611A">61A</a> } <b>REFETY ROWS1 of MODE FORM : where (ROWS1) is (row), STRONG</b> {<a href="report_3.html#611A">61A</a> } <b>REFLEXETY MODE FORM, where (REFETY) is derived from (REFLEXETY)</b> {<a href="report_2.html#5311b">531b, c</a>  , -}<b>; where (ROWS1) is (row ROWS2), STRONG</b> {<a href="report_3.html#611A">61A</a> } <b>REFLEXETY ROWS2 of MODE FORM, where (REFETY) is derived from (REFLEXETY)</b> {<a href="report_2.html#5311b">531b, c</a>  , -}<b>.</b>

<p>
<pre>
{Examples:
a) 4.13 (in [1 : 1] REAL b1 := 4.13) &bull; x1 (in [1 : 1, 1 : n] REAL b2 := x1) }
</pre>

<h3>
<a name=662></a>6.6.2. Semantics
</h3>

<p>
<a name=662a></a>a) The yield <i>W</i>  of a <b>rowed-to-REFETY-ROWS1-of-MODE-FORM</b> <i>F</i> is determined as follows:
<br>
&bull;  let <i>V</i> be the yield of the <b>STRONG-FORM</b> of <i>F</i>;
<br>
<a name=662cA></a>
Case A: <b>'REFETY'</b> is <b>'EMPTY'</b>:
<ul>
<li> <i>W</i> is the multiple value "built" {b} from <i>V</i> for <b>'ROWS1'</b>;
</ul>
<a name=662cB></a>
Case B: <b>'REFETY'</b> is <b>'REF to'</b>:
<ul>
If <i>V</i> is nil,
<br>
then <i>W</i> is a nil name;
<br>
otherwise, <i>W</i> is the name "built" {c} from <i>V</i> for <b>'ROWS1'</b>.
</ul>

<p>
<a name=662b></a>b) The multiple value <i>W</i> "built" from a value <i>V</i>, for some <b>'ROWS1'</b>, is determined as follows:
<br>
<a name=662cA></a>
Case A: <b>'ROWS1'</b> is <b>'row'</b>:
<ul>
<li> <i>W</i> is composed of
</ul>
<ol type=i>
<li> a descriptor ( (1, 1)),
<li> {one element} <i>V</i>;
</ol>
</ul>
<a name=662cB></a>
Case B: <b>'ROWS1'</b> is some <b>'row ROWS2'</b>:
<ul>
<li> let the descriptor of <i>V</i> be ( (l<sub>1</sub>, u<sub>1</sub>), ...,  (l<sub>n</sub>, u<sub>n</sub>));
<li> <i>W</i> is composed of
<ol type=i>
<li> a descriptor ( (1, 1), (l<sub>1</sub>, u<sub>1</sub>), ...,  (l<sub>n</sub>, u<sub>n</sub>)),
<li> the elements of <i>V</i>:
</ol>
<li> the element selected by an index (i<sub>1</sub>, ... , i<sub>n</sub>)  in <i>V</i> is that selected by (1, i<sub>1</sub>, ... , i<sub>n</sub>) in <i>W</i>.
</ul>

<p>
<a name=662c></a>c) The name <i>N1</i> "built" from a name <i>N</i>, for some <b>'ROWS1'</b>, is determined as follows:
<br>
&bull;  <i>N1</i> is a name {not necessarily newly created}, equal in scope to <i>N</i> and referring to the multiple value built {b}, for <b>'ROWS1'</b>, from the value referred to by <i>N</i>;
<br>
<a name=662cA></a>
Case A: <b>'ROWS1'</b> is <b>'row'</b>:
<ul>
<li> the {only} subname of <i>N1</i> is <i>N</i>;
</ul>
<a name=662cB></a>
Case B: <b>'ROWS1'</b> is some <b>'row ROWS2'</b>:
<ul>
<li> the subname of <i>N1</i> selected by (1, i<sub>1</sub>, ... , i<sub>n</sub>) is the subname of N selected by (i<sub>1</sub>, ... , i<sub>n</sub>).
</ul>

<h3>
<a name=67></a>6.7. Voiding
</h3>

<p>
{Voiding is used to discard the yield of some <b>unit</b> whose primary purpose is to cause its side-effects; the a posteriori mode is then simply <b>'void'</b>. For example, in <tt>x:=1; y:=1;</tt>, the <b>assignation</b> <tt>y:=1</tt> is voided, and in <tt>PROC t = INT:  ENTIER (random &times 100); t;</tt>, the <b>applied-identifier</b> <tt>t</tt> is voided after a deproceduring, which prescribes the calling of a routine.
<br>
<b>Assignations</b> and other <b>COMORF</b>s are voided without any deproceduring so that, in <tt>PROC VOID p: p := finish</tt>, the <b>assignation</b> <tt>p := finish</tt> does not prescribe an unexpected calling of the routine <tt>finish</tt>.}

<h3>
<a name=671></a>6.7.1. Syntax
</h3>

<p>
<a name=671A></a>A) <b>NONPROC :: PLAIN ;  STOWED ; REF to NONPROC ; procedure with PARAMETERS yielding MOID ; UNITED.</b>
<br>
<a name=671a></a>a) <b>voided to</b> {<a href="report_3.html#611A">61A</a> } <b>void MORF : deprocedured to</b> {<a href="report_3.html#631a">63a</a> } <b>NONPROC MORF ; unchanged from</b> {<a href="report_3.html#611f">61f</a>} <b>NONPROC MORF.</b>
<br>
<a name=671b></a>b) <b>voided to</b> {<a href="report_3.html#611A">61A</a> } <b>void COMORF : unchanged from</b> {<a href="report_3.html#611f">61f</a> } <b>MODE COMORF.</b>

<p>
<pre>
{Examples:
a) random (in SKIP; random;) &bull;
      next random (last random)
      (in SKIP; next random (last random);)
b) PROC VOID (pp) (in PROC PROC VOID pp = PROC VOID: (print (1);
      VOID: print (2)); PROC VOID (pp);) }
</pre>

<h3>
<a name=672></a>6.7.2. Semantics
</h3>

<p>
The elaboration of a <b>voided-to-void-FORM</b> consists of that of its direct descendent, and yields <tt>empty</tt>.

<h3>
<a name=7></a>7. Modes and nests
</h3>

<p>
{The identification of a property in a nest is the static counterpart of the dynamic determination (<a href="report_2.html#482b">4.8.2.b</a>) of a value in an environ: the search is conducted from the newest (youngest) level towards the previous (older) ones.

<p>
Modes are composed from the primitive modes, such as <b>'boolean'</b>, with the aid of <b>'HEAD'</b>s, such as <b>'structured with'</b>, and they may be recursive. Recursive modes spelled in different ways may nevertheless be equivalent. The syntax tests the equivalence of such modes by proving that it is impossible to find any discrepancy between their respective structures or component modes.

<p>
A number of unsafe uses of properties are prevented. An <b>identifier</b> or <b>mode-indication</b> is not declared more than once in each reach. The modes of the <b>operands</b> of a <b>formula</b> do not determine more than one operation. Recursions in modes do not cause the creation of dynamic objects of unlimited size and do not allow ambiguous coercions.}

<h3>
<a name=71></a>7.1. Independence of properties
</h3>

<p>
{The following syntax determines whether two properties (i.e., two <b>'PROP'</b>s), such as those corresponding to <tt>REAL x</tt> and <tt>INT x</tt>, may or may not be enveloped by the same <b>'LAYER'</b>.}

<h3>
<a name=711></a>7.1.1. Syntax
</h3>

<p>
<a name=711A></a>A) <b>PREF :: procedure yielding ; REF to.</b>
<br>
<a name=711B></a>B) <b>NONPREF :: PLAIN ; STOWED ; procedure with PARAMETERS yielding MOID ; UNITED ; void.</b>
<br>
<a name=711C></a>C) <b>*PREFSETY :: PREF PREFSETY ; EMPTY.</b>
<br>
{<b>PROP :: DEC ; LAB ; FIELD.</b>
<br>
<b>QUALITY :: MODE ; MOID TALLY ; DYADIC ; label ; MODE field.</b>
<br>
<b>TAX :: TAG ; TAB ; TAD ; TAM.</b>
<br>
<b>TAO :: TAD ; TAM.</b>}
<br>
<a name=711a></a>a) <b>WHETHER PROP1 independent PROPS2 PROP2</b> {a, <a href="report_2.html#481a">48a, c</a>  , <a href="report_3.html#721a">72a</a>} <b>: WHETHER PROP1 independent PROPS2</b> {a, c}<b> and PROP1 independent PROP2</b> {c}<b>.</b>
<br>
<a name=711b></a>b) <b>WHETHER PROP independent EMPTY</b> {<a href="report_2.html#481a">48a, c</a>  , <a href="report_3.html#721a">72a</a>} <b>: WHETHER true.</b>
<br>
<a name=711c></a>c) <b>WHETHER QUALITY1 TAX1 independent QUALITY2 TAX2</b> {a, <a href="report_2.html#481a">48a, c</a>  , <a href="report_3.html#721a">72a</a>} <b>: unless (TAX1) is (TAX2), WHETHER true ; where (TAX1) is (TAX2) and (TAX1)  is (TAO), WHETHER QUALITY1 independent QUALITY2</b> {d}<b>.</b>
<br>
<a name=711d></a>d) <b>WHETHER QUALITY1 independent QUALITY2</b> {c}<b> :  where QUALITY1 related QUALITY2</b> {e, f, g, h, i, j, -}<b>, WHETHER false ; unless QUALITY1 related QUALITY2</b> {e, f, g, h, i, j, -}<b>, WHETHER true.</b>
<br>
<a name=711e></a>e) <b>WHETHER MONO related DUO</b> {d}<b> : WHETHER false.</b>
<br>
<a name=711f></a>f) <b>WHETHER DUO related MONO</b> {d}<b> : WHETHER false.</b>
<br>
<a name=711g></a>g) <b>WHETHER PRAM related DYADIC</b> {d}<b> : WHETHER false.</b>
<br>
<a name=711h></a>h) <b>WHETHER DYADIC related PRAM</b> {d}<b> : WHETHER false.</b>
<br>
<a name=711i></a>i) <b>WHETHER procedure with MODE1 parameter MODE2 parameter yielding MOID1 related procedure with MODE3 parameter MODE4 parameter yielding MOID2</b> {d}<b> : WHETHER MODE1 firmly related MODE3</b> {k}<b> and MODE2 firmly related MODE4</b> {k}<b>.</b>
<br>
<a name=711j></a>j) <b>WHETHER procedure with MODE1 parameter yielding MOID1 related procedure with MODE2 parameter yielding MOID2</b> {d}<b> : WHETHER MODE1 firmly related MODE2</b> {k}<b>.</b>
<br>
<a name=711k></a>k) <b>WHETHER MOID1 firmly related MOID2</b> {i, j}<b> :  WHETHER MOODS1 is firm MOID2</b> {l, m}<b> or MOODS2 is firm MOID1</b> {l, m}<b>, where (MOODS1) is (MOID1) or (union of MOODS1 mode) is (MOID1), where (MOODS2)  is (MOID2) or (union of MOODS2 mode) is (MOID2).</b>
<br>
<a name=711l></a>l) <b>WHETHER MOODS MOOD is firm MOID</b> {k, l}<b> : WHETHER MOODS is firm MOID</b> {l, m}<b> or MOOD is firm MOID</b> {m}<b>.</b>
<br>
<a name=711m></a>m) <b>WHETHER MOID1 is firm MOID2</b> {k, l, n, <a href="report_2.html#471f">47f</a> } <b>: WHETHER MOID1 equivalent MOID2</b> {<a href="report_3.html#731a">73a</a> } <b>or MOID1 unites to MOID2</b> {<a href="report_3.html#641b">64b</a> } <b>or MOID1 deprefs to firm MOID2</b> {n}<b>.</b>
<br>
<a name=711n></a>n) <b>WHETHER MOID1 deprefs to firm MOID2</b> {m}<b> : where (MOID1) is (PREF MOID3), WHETHER MOID5 is firm MOID2</b> {m}<b>, where MOID3 deflexes to MOID5</b> {<a href="report_2.html#471a">47a, b, c</a>} <b>; where (MOID1) is (NONPREF), WHETHER false.</b>

<p>
{To prevent the ambiguous application of <b>indicators</b>, as in <tt>REAL x, INT x; x:=0</tt>, certain restrictions are imposed on <b>defining-indicators</b> contained in a given reach. These are enforced by the syntactic test for "independence" of properties enveloped by a given <b>'LAYER'</b> (rules a, b, c). A sufficient condition, not satisfied in the example above, for the independence of a pair of properties, each being some <b>'QUALITY TAX'</b>, is that the <b>'TAX'</b>s differ (rule c). For <b>'TAX'</b>s which are not some <b>'TAO'</b>, this condition is also necessary, so that even <tt>REAL x, INT x; SKIP</tt> is not a <b>serial-clause</b>.

<p>
For two properties <b>'QUALITY1 TAO'</b> and <b>'QUALITY2 TAO'</b> the test for independence is more complicated, as is exemplified by the <b>serial-clause</b>
<pre>
OP + = (INT i) BOOL: TRUE, OP + = (INT i , j) INT: 1, OP + = (INT i, BOOL j) INT: 2,
   PRIO + = 6;
   0 + + 0 &cent; = 2 &cent;.
</pre>
Ambiguities would be present in
<pre>
PRIO + = 6, + = 7; 1 + 2 * 3 &cent; 7 or 9 ? &cent;,
</pre>
in
<pre>
OP Z = (INT i) INT: 1, MODE Z = INT;
   Z i &cent; formula or declaration? &cent;; SKIP,
</pre>
and in
<pre>
OP ? = (UNION (REF REAL, CHAR) a) INT: 1, OP ? = (REAL a) INT: 2;
   ? LOC REAL  &cent; 1 or 2 ? &cent;.
</pre>

<p>
In such cases a test is made that the two <b>'QUALITY'</b>s are independent (rules c, d). A <b>'MOID TALLY'</b> is never independent of any <b>'QUALITY'</b>  (rule d). A <b>'MONO'</b> is always independent of a <b>'DUO'</b> (rules d, e, f) and both are independent of a <b>'DYADIC'</b> (i.e., of a <b>'priority PRIO'</b>) (rules d, g, h). In the case of two <b>'PRAM'</b>s which are both <b>'MONO'</b> or both <b>'DUO'</b>, ambiguities could arise if the corresponding parameter modes were "firmly related", i.e., if some (pair of) operand mode (s)  could be firmly coerced to the (pair of) parameter mode (s) of either <b>'PRAM'</b> (rules i, j). In the example with the two definitions of <tt>?</tt>, the two <b>'PRAM'</b>s are related since the modes specified by <tt>UNION (REF REAL, CHAR)</tt> and by <tt>REAL</tt> are firmly related, the mode specified by <tt>REF REAL</tt> being firmly coercible to either one.

<p>
It may be shown that two modes are firmly related if one of them, or some component <b>'MOOD'</b> of one of them, may be firmly coerced to the other (rules k, l), which requires a sequence of zero or more meek coercions followed by at most one uniting {<a href="report_3.html#641a">6.4.1.a</a>}. The possibility or otherwise of such a sequence of coercions between two modes is determined by the predicate <b>'is firm'</b> (rules m, n).

<p>
A <b>'PROP1'</b> also renders inaccessible a <b>'PROP2'</b> in an outer <b>'LAYER'</b> if that <b>'PROP2'</b> is not independent of <b>'PROP1'</b>;  e.g.,

<pre>
BEGIN INT x;
   BEGIN REAL x; &cent; here the <b>'PROP1'</b> is <b>'reference to real letter x'</b> &cent;
      SKIP
   END
END
</pre>

and likewise

<pre>
BEGIN OP ? = (INT i) INT: l, INT k := 2;
   BEGIN OP ? = (REF INT i) INT: 3;
     ? k &cent; delivers 3, but ? 4 could not occur here because its operator is inaccessible &cent;
   END
END.
</pre>
}

<h3>
<a name=72></a>7.2. Identification in nests
</h3>

<p>
{This section ensures that for each <b>applied-indicator</b> there is a corresponding property in some suitable <b>'LAYER'</b> of the nest.}

<h3>
<a name=721></a>7.2.1. Syntax
</h3>

<p>
{<b>PROPSETY :: PROPS ; EMPTY.</b>
<br>
<b>PROPS :: PROP ; PROPS PROP.</b>
<br>
<b>PROP :: DEC ; LAB ; FIELD.</b>
<br>
<b>QUALITY :: MODE ; MOID TALLY ; DYADIC ; label ; MODE field.</b>
<br>
<b>TAX :: TAG ; TAB ; TAD ; TAM.</b>}

<p>
<a name=721a></a>a) <b>WHETHER PROP identified in NEST new PROPSETY</b> {a, <a href="report_2.html#481b">48b</a> , <a href="report_2.html#5421a">542a</a>} <b>: where PROP resides in PROPSETY</b> {b, c, -}<b>, WHETHER true ; where PROP independent PROPSETY</b> {<a href="report_3.html#711a">71a, b, c</a>} <b>, WHETHER PROP identified in NEST</b> {a, -}<b>.</b>
<br>
<a name=721b></a>b) <b>WHETHER PROP1 resides in PROPS2 PROP2</b> {a, b, <a href="report_2.html#481d">48d</a> } <b>: WHETHER PROP1 resides in PROP2</b> {c, -}<b> or PROP1 resides in PROPS2</b> {b, c, -}<b>.</b>
<br>
<a name=721c></a>c) <b>WHETHER QUALITY1 TAX resides in QUALITY2 TAX</b> {a, b, <a href="report_2.html#481d">48d</a> } <b>: where (QUALITY1) is (label) or (QUALITY1) is (DYADIC) or (QUALITY1) is (MODE field), WHETHER (QUALITY1) is (QUALITY2) ; where (QUALITY1) is (MOID1 TALLETY) and (QUALITY2) is (MOID2 TALLETY), WHETHER MOID1 equivalent MOID2</b> {<a href="report_3.html#731a">73a</a> } <b>.</b>

<p>
{A nest, except the primal one (which is just <b>'new'</b>), is some <b>'NEST LAYER'</b> (i.e., some <b>'NEST new PROPSETY'</b>). A <b>'PROP'</b> is identified by first looking for it in that <b>'LAYER'</b> (rule a). If the <b>'PROP'</b> is some <b>'label TAX'</b> or <b>'DYADIC TAX'</b>, then a simple match of the <b>'PROP'</b>s is a sufficient test (rule c). If the <b>'PROP'</b>  is some <b>'MOID TALLETY TAX'</b>, then the mode equivalencing mechanism must be invoked (rule c). If it is not found in the <b>'LAYER'</b>, then the search continues with the <b>'NEST'</b> (without that <b>'LAYER'</b>), provided that it is independent of all <b>'PROP'</b>s in that <b>'LAYER'</b>; otherwise the search is abandoned (rule a). Note that rules b and c do double duty in that they are also used to check the validity of <b>applied-field-selectors</b> {<a href="report_2.html#481d">4.8.1.d</a>}.}

<h3>
<a name=722></a>7.2.2. Semantics
</h3>

<p>
<a name=722a></a>a) If some <b>NEST-range</b> <i>R</i> {<a href="report_2.html#301f">3.0.1.f</a>} contains an <b>applied-indicator</b> <i>I</i> {<a href="report_2.html#481b">4.8.1.b</a>} of which there is a descendent <b>where-PROP-identified-in-NEST-LAYER</b>, but no descendent <b>where-PROP-identified-in-NEST</b>, then <i>R</i> is the  "defining <b>range</b>" of that <i>I</i>. {Note that <b>'NEST'</b> is always the nest in force just outside the <b>range</b>.}

<p>
<a name=722b></a>b) A <b>QUALITY-applied-indicator-with-TAX</b> <i>I</i>  whose defining <b>NEST-range</b> {a} is <i>R</i> "identifies" the <b>QUALITY-NEST-LAYER-defining-indicator-with-TAX</b> contained in <i>R</i>.

<p>
{For example, in
<pre>
 (&cent; 1 &cent; REAL i = 2.0; (&cent; 2 &cent; INT i = 1; (&cent; 3 &cent; REAL x; print (i) &cent; 3 &cent; ) &cent;  2 &cent; ) &cent; 1 &cent;)
</pre>
there are three <b>ranges</b>. The <b>applied-identifier</b>  <tt>i</tt> in <tt>print (i)</tt> is forced, by the syntax, to be an <b>integral-NEST-new-real-letter-i-new-integral-letter-i-new-reference-to-real-letter-x-applied-identifier-with-letter-i</b>  {<a href="report_2.html#481b">4.8.1.b</a>}. Its defining <b>range</b> is the <b>NEST-new-real-letter-i-serial-clause-defining-new-integral-letter-i</b> {<a href="report_2.html#321a">3.2.1.a</a>} numbered <tt>&cent; 2 &cent;</tt>, it identifies the <b>defining-identifier</b>  <tt>i</tt> contained in <tt>INT i</tt> (not the one in <tt>REAL i</tt>), and its mode is <b>'integral'</b>.}

<p>
{By a similar mechanism, a <b>DYADIC-formula</b> {<a href="report_2.html#5421a">5.4.2.1.a</a>} may be said to "identify" that <b>DYADIC-defining-operator</b> {<a href="report_2.html#481a">4.8.1.a</a>} which determines its priority.}

<p>
<a name=722c></a>c) The environ <i>E</i> "necessary for" a construct <i>C</i>  in an environ <i>E1</i> is determined as follows:
<br>
If <i>E1</i> is the primal environ {<A href="report_1.html#222a">2.2.2.a</a>  },
<br>
then <i>E</i> is <i>E1</i>;
<br>
otherwise, letting <i>E1</i> be composed of a locale <i>L</i>    corresponding to some
<b>'PROPSETY'</b> and another environ <i>E2</i>,
<br>
If <i>C</i> contains any <b>QUALITY-applied-indicator-with-TAX</b>
<ul>
<li>which does not identify {b} a <b>defining-indicator</b> contained in <i>C</i>,
<li>which is not a <b>mode-indication</b> directly descended from a <b>formal-</b> or <b>virtual-declarer</b>, and
<li>which is such that the predicate <b>'where QUALITY TAX resides in PROPSETY'</b> {<a href="report_3.html#721b">7.2.1.b</a>} holds,
</ul>
then <i>E</i> is <i>E1</i>;
<br>
otherwise, {<i>L</i> is not necessary for <i>C</i> and} <i>E</i> is the environ necessary for <i>C</i> in <i>E2</i>.

</p>
{The environ necessary for a construct is used in the semantics of <b>routine-texts</b> {<a href="report_2.html#5412">5.4.1.2</a>} and in "establishing" {<a href="report_2.html#322b">3.2.2.b</a>}. For example, in
<pre>
&cent; 2 &cent; PROC VOID pp; INT n; (&cent; 1 &cent; PROC p = VOID: print (n); pp := p)
</pre>
if <i>E1</i> and <i>E2</i> are the environs established by the elaboration of the <b>serial-clauses</b> marked by the <b>comments</b> <tt>&cent; 1  &cent;</tt> and <tt>&cent; 2 &cent;</tt>, then <i>E2</i> is the environ necessary in <i>E1</i>  for the <b>routine-text</b> <tt>VOID: print (n)</tt>, and so the routine yielded by <tt>p</tt> in <i>E1</i> is composed of that <b>routine-text</b> together with E2 {<a href="report_2.html#5412">5.4.1.2</a>}. Therefore, the scope of that routine is the scope of <i>E2</i> {<a href="report_1.html#2135c">2.1.3.5.c</a>} and hence the assignment {<a href="report_2.html#5212b">5.2.1.2.b</a>} invoked by <tt>pp := p</tt> is well defined.}

<h3>
<a name=73></a>7.3. Equivalence of modes
</h3>

<p>
{The equivalence or nonequivalence of <b>'MOID'</b>s is determined in this section. For a discussion of equivalent <b>'MOID'</b>s see <a href="report_1.html#2112">2.1.1.2</a>.}

<p>
{One way of viewing recursive modes is to consider them as infinite trees. Such a "mode tree" is obtained by repeatedly substituting in some spelling, for each <b>'MU application'</b>, the <b>'MODE'</b> of the corresponding <b>'MU definition of MODE'</b>. Thus, the spelling <b>'mui definition of structured with integral field letter i reference to mui application field letter n mode'</b> would give rise to the following mode tree:
<pre>
<b>
                                             |
 ----------------------------------------------------------
 |                |                            |          |
'structured with' |                            |         'mode'
                  |                            |
 --------------------                -------------------
 |          |       |                |         |       |
'integral' 'field' 'letter i'        |       'field' 'letter n'
                               ---------------
                               |             |
                              'reference to' |
                                             |
 ----------------------------------------------------------
 |                |                            |          |
'structured with' |                            |         'mode'
                  |                            |
 --------------------                -------------------
 |          |       |                |         |       |
'integral' 'field' 'letter i'        |       'field' 'letter n'
                               ---------------
                               |             |
                              'reference to' |
                                             |</b>
                                            (et cetera).
</pre>

<p>
Two spellings are equivalent if and only if they give rise to identical mode trees. The equivalence syntax tests the equivalence of two spellings by, as it were, simultaneously developing the two trees until a difference is found (resulting in a blind alley) or until it becomes apparent that no difference can be found. The growing production tree reflects to some extent the structure of the mode trees.}

<h3>
<a name=731></a>7.3.1. Syntax
</h3>

<p>
<a name=731A></a>A) <b>SAFE :: safe ; MU has MODE SAFE ; yin SAFE ; yang SAFE ; remember MOID1 MOID2 SAFE.</b>
<br>
<a name=731B></a>B) <b>HEAD :: PLAIN ; PREF</b> {<a href="report_3.html#711A">71A</a> } <b>; structured with ; FLEXETY ROWS of ; procedure with ; union of ; void.</b>
<br>
<a name=731C></a>C) <b>TAILETY :: MOID ; FIELDS mode ; PARAMETERS yielding MOID ; MOODS mode ; EMPTY.</b>
<br>
<a name=731D></a>D) <b>PARTS :: PART ; PARTS PART.</b>
<br>
<a name=731E></a>E) <b>PART :: FIELD ; PARAMETER.</b>
<br>
<a name=731a></a>a) <b>WHETHER MOID1 equivalent MOID2</b> {<a href="report_3.html#641b">64b</a> , <a href="report_3.html#711m">71m</a>, <a href="report_3.html#721c">72c</a>} <b>: WHETHER safe MOID1 equivalent safe MOID2</b> {b}<b>.</b>
<br>
<a name=731b></a>b) <b>WHETHER SAFE1 MOID1 equivalent SAFE2 MOID2</b> {a, b, e, i, j, n}<b> : where (SAFE1) contains (remember MOID1 MOID2) or (SAFE2) contains (remember MOID2 MOID1), WHETHER true ; unless (SAFE1) contains (remember MOID1 MOID2) or (SAFE2) contains (remember MOID2 MOID1), WHETHER (HEAD3) is (HEAD4) and remember MOID1 MOID2 SAFE3 TAILETY3 equivalent SAFE4 TAILETY4</b> {b, d, e, k, q, -}<b>, where SAFE3 HEAD3 TAILETY3 develops from SAFE1 MOID1</b> {c}<b> and SAFE4 HEAD4 TAILETY4 develops from SAFE2 MOID2</b> {c}<b>.</b>
<br>
<a name=731c></a>c) <b>WHETHER SAFE2 HEAD TAILETY develops from SAFE1 MOID</b> {b, c}<b> : where (MOID) is (HEAD TAILETY), WHETHER (HEAD) shields SAFE1 to SAFE2</b> {<a href="report_3.html#741a">74a, b, c, d</a>  , -}<b>; where (MOID) is (MU definition of MODE), unless (SAFE1) contains (MU has), WHETHER SAFE2 HEAD TAILETY develops from MU has MODE SAFE1 MODE</b> {c}<b>;  where (MOID) is (MU application) and (SAFE1) is (NOTION MU has MODE SAFE3) and (NOTION) contains (yin) and (NOTION) contains (yang), WHETHER SAFE2 HEAD TAILETY develops from SAFE1 MODE</b> {c}<b>.</b>
<br>
<a name=731d></a>d) <b>WHETHER SAFE1 FIELDS1 mode equivalent SAFE2 FIELDS2 mode</b> {b}<b> : WHETHER SAFE1 FIELDS1 equivalent SAFE2 FIELDS2</b> {f, g, h, i}<b>.</b>
<br>
<a name=731e></a>e) <b>WHETHER SAFE1 PARAMETERS1 yielding MOID1 equivalent SAFE2 PARAMETERS2 yielding MOID2</b> {b}<b> : WHETHER SAFE1 PARAMETERS1 equivalent SAFE2 PARAMETERS2</b> {f, g, h, j}<b> and SAFE1 MOID1 equivalent SAFE2 MOID2</b> {b}<b>.</b>
<br>
<a name=731f></a>f) <b>WHETHER SAFE1 PARTS1 PART1 equivalent SAFE2 PARTS2 PART2</b> {d, e, f}<b> : WHETHER SAFE1 PARTS1 equivalent SAFE2 PARTS2</b> {f, g, h, i, j}<b> and SAFE1 PART1 equivalent SAFE2 PART2</b> {i, j}<b>.</b>
<br>
<a name=731g></a>g) <b>WHETHER SAFE1 PARTS1 PART1 equivalent SAFE2 PART2</b> {d, e, f}<b> : WHETHER false.</b>
<br>
<a name=731h></a>h) <b>WHETHER SAFE1 PART1 equivalent SAFE2 PARTS2 PART2</b> {d, e, f}<b> : WHETHER false.</b>
<br>
<a name=731i></a>i) <b>WHETHER SAFE1 MODE1 field TAG1 equivalent SAFE2 MODE2 field TAG2</b> {d, f}<b> : WHETHER (TAG1) is (TAG2) and SAFE1 MODE1 equivalent SAFE2 MODE2</b> {b}<b>.</b>
<br>
<a name=731j></a>j) <b>WHETHER SAFE1 MODE1 parameter equivalent SAFE2 MODE2 parameter</b> {e, f}<b> : WHETHER SAFE1 MODE1 equivalent SAFE2 MODE2</b> {b}<b>.</b>
<br>
<a name=731k></a>k) <b>WHETHER SAFE1 MOODS1 mode equivalent SAFE2 MOODS2 mode</b> {b}<b> : WHETHER SAFE1 MOODS1 suhset of SAFE2 MOODS2</b> {l, m, n}<b> and SAFE2 MOODS2 subset of SAFE1 MOODS1</b> {l, m, n}<b> and MOODS1 number equals MOODS2 number</b> {o, p}<b>.</b>
<br>
<a name=731l></a>l) <b>WHETHER SAFE1 MOODS1 MOOD1 subset of SAFE2 MOODS2</b> {k, l, <a href="report_2.html#461s">46s</a> , <a href="report_3.html#641b">64b</a>} <b>: WHETHER SAFE1 MOODS1 subset of SAFE2 MOODS2</b> {l, m, n}<b> and SAFE1 MOOD1 subset of SAFE2 MOODS2</b> {m, n}<b>.</b>
<br>
<a name=731m></a>m) <b>WHETHER SAFE1 MOOD1 subset of SAFE2 MOODS2 MOOD2</b> {k, l, m, <a href="report_2.html#461s">46s</a> , <a href="report_3.html#641b">64b</a>} <b>: WHETHER SAFE1 MOOD1 subset of SAFE2 MOODS2</b> {m, n}<b> or SAFE1 MOOD1 subset of SAFE2 MOOD2</b> {n}<b>.</b>
<br>
<a name=731n></a>n) <b>WHETHER SAFE1 MOOD1 subset of SAFE2 MOOD2</b> {k, l, m, <a href="report_3.html#641b">64b</a> } <b>: WHETHER SAFE1 MOOD1 equivalent SAFE2 MOOD2</b> {b}<b>.</b>
<br>
<a name=731o></a>o) <b>WHETHER MOODS1 MOOD1 number equals MOODS2 MOOD2 number</b> {k, o}<b> : WHETHER MOODS1 number equals MOODS2 number</b> {o, p, -}<b>.</b>
<br>
<a name=731p></a>p) <b>WHETHER MOOD1 number equals MOOD2 number</b> {k, o}<b> :  WHETHER true.</b>
<br>
<a name=731q></a>q) <b>WHETHER SAFE1 EMPTY equivalent SAFE2 EMPTY</b> {b}<b> :  WHETHER true.</b> 

<p>
{Rule a introduces the <b>'SAFE'</b>s which are used as associative memories during the determination of equivalence. There are two of them, one belonging to each mode. Rule b draws an immediate conclusion if the <b>'MOID'</b>s under consideration are already remembered (see below) in an appropriate <b>'SAFE'</b> in the form <b>'remember MOID1 MOID2'</b>. If this is not the case, then the two <b>'MOID'</b>s are first remembered in a <b>'SAFE'</b> (the one on the left) and then each <b>'MOID'</b> is developed (rule c) and split into its <b>'HEAD'</b> and its <b>'TAILETY'</b>, e.g.,  <b>'reference to real'</b> is split into <b>'reference to'</b> and <b>'real'</b>.

<p>
If the <b>'HEAD'</b>s differ, then the matter is settled (rule b); otherwise the <b>'TAILETY'</b>s are analyzed according to their structure (which must be the same if the <b>'HEAD'</b>s are identical). In each case, except where the <b>'HEAD'</b>s were <b>'union of'</b>, the equivalence is determined by examining the corresponding components, according to the following scheme:

<p>
<table border=0 cellspacing=6 cellpadding=0>
<tr><td>rule</td><td><b>'TAILETY'</b></td><td>components</td></tr>
<tr><td>d</td><td><b>'FIELDS mode'</b></td><td><b>'FIELDS'</b></tr>
<tr><td>e</td><td><b>'PARAMETERS yielding MOID'</b></td><td><b>'PARAMETERS'</b> and <b>'MOID'</b></tr>
<tr><td>f</td><td><b>'FIELDS FIELD'</b></td><td><b>'FIELDS'</b> and <b>'FIELD'</b></tr>
<tr><td>f</td><td><b>'PARAMETERS PARAMETER'</b></td><td><b>'PARAMETERS' and <b>'PARAMETER'</b></b></tr>
<tr><td>i</td><td><b>'MODE field TAG'</b></td><td><b>'MODE' and <b>'TAG'</b></b></tr>
<tr><td>j</td><td><b>'MODE parameter'</b></td><td><b>'MODE'</b></tr>
</table>

<p>
In the case of unions, the <b>'TAILETY'</b>s are of the form <b>'MOODS1 mode'</b> and <b>'MOODS2 mode'</b>. Since <b>'MOOD'</b>s within equivalent unions may commute, as in the modes specified by <tt>UNION (REAL, INT)</tt> and <tt>UNION (INT, REAL)</tt>, the equivalence is determined by checking that <b>'MOODS1'</b> is a subset of <b>'MOODS2'</b> and that <b>'MOODS2'</b> is a subset of <b>'MOODS1'</b>, where the subset test, of course, invokes the equivalence test recursively (rules k, l, m, n, o, p).

<p>
A <b>'MOID'</b> is developed (rule c) into the form <b>'HEAD TAILETY'</b> by determining that <OL type=1>   <li>it is already of that form: in which case markers (<b>'yin'</b> and <b>'yang'</b>) may be placed in its <b>'SAFE'</b> for the later determination of well-formedness (see <A href="report_3.html#74">7.4</a> );    <li>it is some <b>'MU definition of MODE'</b>: in which case <b>'MU has MODE'</b> is stored in its <b>'SAFE'</b> (provided that this particular <b>'MU'</b> is not there already) and the <b>'MODE'</b> is developed;    <li>it is some <b>'MU application'</b>: in which case there must be some <b>'MU has MODE'</b> in its <b>'SAFE'</b> already. That <b>'MODE'</b> is then developed after a well-formedness check (see <A href="report_3.html#74">7.4</a> )    consisting of the determination that there is at least one <b>'yin'</b> and at least one <b>'yang'</b> in the <b>'SAFE'</b> which is more recent than the <b>'MU has MODE'</b>. </li></ol>}

<p>
{Before a pair of <b>'TAILETY'</b>s is tested for equivalence, it is remembered in the <b>'SAFE'</b> that the original pair of <b>'MOID'</b>s is being tested. This is used to force a shortcut to <b>'WHETHER true'</b> if these <b>'MOID'</b>s should ever be tested again for equivalence lower down the production tree. Since the number of pairs of component <b>'MOID'</b>s that can be derived from any two given <b>'MOID'</b>s is finite, it follows that the testing process terminates.

<p>
It remains to be shown that the process is correct. Consider the unrestricted (possibly infinite) production tree that would be obtained if there were no shortcut in the syntax (by omitting the first alternative together with the first member of the other alternative of rule b). If two <b>'MOID'</b>s are not equivalent, then there exists in their mode trees a shortest path from the top node to some node exhibiting a difference. Obviously, the reflection of this shortest path in the unrestricted production tree cannot contain a repeated test for the equivalence of any pair of <b>'MOID'</b>s, and therefore none of the shortcuts to <b>'WHETHER true'</b> in the restricted production tree can occur on this shortest path. Consequently, the path to the difference must be present also in the (restricted) production tree produced by the syntax. If the testing process does not exhibit a difference in the restricted tree, then no difference can be found in any number of steps: i.e., the <b>'MOID'</b>s are equivalent.}

<h3>
<a name=74></a>7.4. Well-formedness
</h3>

<p>
{A mode is well formed if
<ol type=i>
<li>the elaboration of an <b>actual-declarer</b> specifying that mode is a finite action (i.e., any value of that mode can be stored in a finite memory)    and
<li>it is not strongly coercible from itself (since this would lead to ambiguities in coercion).
</ol>}

<h3>
<a name=741></a>7.4.1. Syntax
</h3>

<p>
<a name=741a></a>a) <b>WHETHER (NOTION)  shields SAFE to SAFE</b> {<a href="report_3.html#731c">73c</a> } <b>: where (NOTION) is (PLAIN) or (NOTION) is (FLEXETY ROWS of) or (NOTION) is (union of) or (NOTION) is (void), WHETHER true.</b>
<br>
<a name=741b></a>b) <b>WHETHER (PREF) shields SAFE to yin SAFE</b> {<a href="report_3.html#731c">73c</a> } <b>: WHETHER true.</b>
<br>
<a name=741c></a>c) <b>WHETHER (structured with) shields SAFE to yang SAFE</b> {<a href="report_3.html#731c">73c</a> } <b>: WHETHER true.</b>
<br>
<a name=741d></a>d) <b>WHETHER (procedure with) shields SAFE to yin yang SAFE</b> {<a href="report_3.html#731c">73c</a> } <b>: WHETHER true.</b> {As a by-product of mode equivalencing, modes are tested for well-formedness {<a href="report_3.html#731c">7.3.1.c</a>}. All nonrecursive modes are well formed. For recursive modes, it is necessary that each cycle in each spelling of that mode (from <b>'MU definition of MODE'</b> to <b>'MU application'</b>) passes through at least one <b>'HEAD'</b>  which is yin, ensuring condition (i) and one (possibly the same) <b>'HEAD'</b>  which is yang, ensuring condition (ii). Yin <b>'HEAD'</b>s are <b>'PREF'</b> and <b>'procedure with'</b>. Yang <b>'HEAD'</b>s are <b>'structured with'</b> and <b>'procedure with'</b>. The other <b>'HEAD'</b>s, including <b>'FLEXETY ROWS of'</b> and <b>'union of'</b>, are neither yin nor yang. This means that the modes specified by <tt>A</tt>, <tt>B</tt> and <tt>C</tt> in

<pre>
MODE A = STRUCT (INT n, REF A next), B = STRUCT (PROC B next), C = PROC (C) C
</pre>

are all well formed. However, <tt>MODE D = [1 : 10] D, E =  UNION (INT, E)</tt> is not a <b>mode-declaration</b>.}

<p>
<div align=right>
{Tao produced the one.<br>
The one produced the two.<br>
The two produced the three.<br>
And the three produced the ten thousand things.<br>
The ten thousand things carry the yin and embrace the yang, <br>
and through the blending of the material force they achieve harmony.<br>
Tao-te Ching, 42, Lao Tzu.}
</div>

<!-- RRFooter -->
<p>
<div style="border: 1px solid red">
<table cellpadding=6>
<tr>
<td>
<p style="font-size: 8pt; font-color: black;">
Text from the <i>Revised Report on the Algorithmic
Language Algol 68</i> is reproduced under the condition specified in
that report: <i>Reproduction of the Report, for any purpose, but only
of the whole text, is explicitly permitted without formality</i>. The
appendix <i>Specification of partial parametrization proposal</i> is
not a part of the Algol 68 Revised Report, and is distributed with
Algol 68 Genie with kind permission of C.H. Lindsey.
<p style="font-size: 8pt; font-color: black;">
Copyright &copy; 2001-2008 J. Marcel van der Veer.<br>
Algol 68 Genie Mark 15 (December 2008)
</td>
</tr>
</table>
</div>
</body>
</html>

