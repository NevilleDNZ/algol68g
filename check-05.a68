COMMENT Input for this program
rectangle
no
square
does it have four sides of equal length
yes
yes
no
no
cube
does it have three dimensions
yes
no
COMMENT

PR echo "[5] Building a decision-tree" PR

# This is a classic example for building a decision tree in Algol 68.
  We wrote programs like this for ALGOL68C/TOPS-20 in the eighties - MvdV. #

BEGIN FILE input;
      VOID (open (input, program idf, standin channel)); # read self #
      get (input, new line); # skip COMMENT line #

      OBJECTS library := get reply("Please name an object");

      WHILE print(("I will guess the object you are thinking of", new line));
            guess object(library);
            ask("Another round")
      DO # Q&A # SKIP
      OD;

      PROC guess object = (REF OBJECTS object) VOID:
           # How to guess an object #
           CASE object
           IN (STRING s): (ask(s) | SKIP | object := learn(s)),
              (FORK d):   guess object((ask(TEXT d) | HAS d | HASNT d))
           ESAC;

      PROC learn = (STRING guess) OBJECTS:
           # How to improve on a guess #
           IF STRING object = get reply("What was the object?"),
                     question = get reply("Give a question to distinguish '" + object + "'");
              ask("Does '" + question + "' apply to '" + object + "'")
           THEN new fork(question, object, guess)
           ELSE new fork(question, guess, object)
           FI;

      PROC get reply = (STRING prompt) STRING:
           BEGIN STRING s; 
                 print((prompt, new line)); 
                 get(input, (s, new line)); 
                 print (("'", s, "'", new line));
                 s
           END;
                
      PROC ask = (STRING question) BOOL:
           IF STRING s = get reply (question + "?");
              UPB s > 0
           THEN s[1] = "y" ORF s[1] = "Y"
           ELSE ask (question)
           FI;

      OP TEXT  = (FORK d) STRING: text OF d, # Access operators to "hide" the data structure #
         HAS   = (FORK d) REF OBJECTS: has OF d,
         HASNT = (FORK d) REF OBJECTS: hasnt OF d;

      MODE OBJECTS = UNION(STRING, FORK), # The data structure #
           FORK = STRUCT(STRING text, REF OBJECTS has, hasnt);

      PROC new fork = (STRING text, OBJECTS has, hasnt) FORK:
           (HEAP STRING := text, HEAP OBJECTS := has, HEAP OBJECTS := hasnt);
      
      SKIP # since a clause can not end in a declaration #

END
