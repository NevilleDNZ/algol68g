# This program is part of the
 
     Revised Mathematisch Centrum Algol 68 Test Set

  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.

  This test set is available from:

     http://www.dickgrune.com/CS/Algol68

  or from the Vrije Universiteit Amsterdam:

     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#numr06#
BEGIN # Vector calculus #
      MODE VEC = [1 : 1] REAL;
      
      OP * = (REAL a, VEC b) VEC:
         ([1 : UPB b] REAL c;
          
          FOR i TO UPB b 
          DO c[i] := a * b[i]
          OD;
          c),
      OP * = (VEC a, b) REAL:
         (REAL s := 0;
          
          FOR i TO UPB a 
          DO s +:= a[i] * b[i]
          OD;
          s),
      OP + = (VEC a, b) VEC:
         ([1 : UPB b] REAL c;
          
          FOR i TO UPB a 
          DO c[i] := a[i] + b[i]
          OD;
          c);
      
      PROC dec = (REF [, ] REAL a, REF [] INT p) VOID:
           BEGIN INT n = UPB p;
                 
                 INT pk,
                 REAL max, s,
                 [1 : n] REAL v;
                 
                 FOR i TO n 
                 DO v[i] := 1 / sqrt (a[i, ] * a[i, ])
                 OD;
                 FOR k TO n 
                 DO max := 0;
                    pk := k;
                    FOR i FROM k TO n 
                    DO a[i, k] -:= a[i,  : k - 1] * a[ : k - 1, k];
                       s := ABS a[i, k] * v[i];
                       IF s > max
                       THEN pk := i;
                            max := s
                       FI
                    OD;
                    p[k] := pk;
                    IF pk /= k
                    THEN [] REAL h = a[pk, ];
                         
                         a[pk, ] := a[k, ];
                         a[k, ] := h;
                         v[pk] := v[k]
                    FI;
                    FOR i FROM k + 1 TO n 
                    DO a[k, i] -:= a[k,  : k - 1] * a[ : k - 1, i]
                    OD;
                    a[k, k + 1 : 
                      # this row may be empty #
                      ] := (1 / a[k, k]) * a[k, k + 1 : ]
                 OD
           END
      # end decomposition of 'a' #
      ,
      PROC sol = ([, ] REAL a, [] INT p, REF [] REAL b) VOID:
           BEGIN INT n = UPB p;
                 
                 FOR k TO n 
                 DO INT pk = p[k],
                    REAL r = b[k];
                    
                    b[k] := (b[pk] - a[k,  : k - 1] * b[ : k - 1]) / a[k, k];
                    IF pk /= k
                    THEN b[pk] := r
                    FI
                 OD;
                 FOR k FROM n BY -1 TO 1 
                 DO b[k] -:= a[k, k + 1 : ] * b[k + 1 : ]
                 OD
           END
      # end of back substitution of solution into 'b' #
      ;
      
      FOR n TO 8 
      DO [1 : n, 1 : n] REAL a, aa,
         [1 : n] REAL b,
         [1 : n] INT piv;
         
         print (newline);
         print (" n =");
         print (n);
         print (newline);
         FOR i TO n 
         DO FOR j TO n 
            DO a[i, j] := aa[i, j] := 1 / (i + j - 1)
            OD
         OD;
         # Hilbert-matrix #
         FOR i TO n 
         DO b[i] := 2 / 2 ** i
         OD;
         dec (a, piv);
         sol (a, piv, b);
         FOR i TO n 
         DO print (aa[i, ] * b);
            print (newline);
            print (2 / 2 ** i);
            # these two should approximately be the same #
            print ((newline, newline))
         OD
      OD
END