<html>
<head>
<title>Algol 68 Genie - An Algol 68 interpreter</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: Arial,Helvetica;}
u {font-size: 10pt; font-family: Arial,Helvetica;}
dd {font-size: 10pt; font-family: Arial,Helvetica;}
h1 {font-size: 16pt; font-family: Arial,Helvetica;}
h2 {font-size: 14pt; font-family: Arial,Helvetica;}
h3 {font-size: 12pt; font-family: Arial,Helvetica;}
h4 {font-size: 10pt; font-family: Arial,Helvetica;}
td {font-size: 8pt; font-family: Arial,Helvetica;}
ul {font-size: 10pt; font-family: Arial,Helvetica;}
body {font-size: 10pt; font-family: Arial,Helvetica;}
code {font-size: 10pt; font-family: Courier;}
pre {font-size: 10pt; font-family: Courier;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>Documentation for Algol 68 Genie Mark 9.2</small>
</td>
</table>

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>Description of Algol68G</h2>
<small>
&nbsp;&middot;&nbsp;<a href="#high">About this Algol 68 implementation</a><br>
&nbsp;&middot;&nbsp;<a href="#diff">Algol68G compared to the Revised Report description</a><br>
&nbsp;&middot;&nbsp;<a href="#params">Partial parametrisation and currying</a><br>
&nbsp;&middot;&nbsp;<a href="#io">Transput implementation</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#genio">Transput in general</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#fmtio">Formatted transput</a><br>
&nbsp;&middot;&nbsp;<a href="#assert">Assertions as pre- or postconditions</a><br>
&nbsp;&middot;&nbsp;<a href="#prep">The preprocessor</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#prepcat">Concatenation of lines</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#prepinc">Inclusion of files</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#refine">The refinement preprocessor</a><br>
&nbsp;&nbsp;&nbsp;&middot;&nbsp;<a href="#prepsw">Switching the preprocessor on or off</a><br>
&nbsp;&middot;&nbsp;<a href="#speed">Interpreter speed</a><br>
&nbsp;&middot;&nbsp;<a href="#limitations">Limitations and bugs</a><br>
</small>
</td>
<td width="30%" valign=top align=center>
<img src="logo.gif">
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<small><b>Algol68G Mark 9.2</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="introduction.html"><small>Introduction</small></a><br>
&nbsp;&middot;&nbsp;<a href="install.html"><small>Installation</small></a><br>
&nbsp;&middot;&nbsp;<a href="description.html"><small>Description</small></a><br>
&nbsp;&middot;&nbsp;<a href="examples.html"><small>Example&nbsp;programs</small></a><br>
&nbsp;&middot;&nbsp;<a href="synopsis.html"><small>Synopsis</small></a><br>
&nbsp;&middot;&nbsp;<a href="syntax.html"><small>Syntax</small></a><br>
&nbsp;&middot;&nbsp;<a href="environ.html"><small>Environment</small></a><br>
<br>
<small><b>Extensions</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="extensions.html"><small>UNIX</small></a><br>
&nbsp;&middot;&nbsp;<a href="postgresql.html"><small>PostgreSQL</small></a><br>
&nbsp;&middot;&nbsp;<a href="drawing.html"><small>Drawing</small></a><br>
&nbsp;&middot;&nbsp;<a href="numerical.html"><small>Numerical</small></a><br>
<br>
&nbsp;&middot;&nbsp;<a href="contents.html"><small>Contents</small></a><br>
&nbsp;&middot;&nbsp;<a href="resources.html"><small>A68 Resources</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#obtaining"><small>Downloads</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#contact"><small>Contact</small></a>
</td>
</tr>
</table>
</table>
<!-- End navigation bar -->
</td>
</table>

<table border=0 cellspacing=0 cellpadding=12>
<td valign=top bgcolor="white">

<br>
<h3><a name="high"></a>About this Algol 68 implementation</h3>

<p>
<i>Algol 68 Genie</i> (Algol68G) is a nearly full implementation of Algol 68 as defined by <a href="resources.html#ref">[Revised Report 1976]</a> and also implements partial parametrisation, which is an extension of Algol 68. 

<p>
After successful parsing of an entire source program, the syntax tree, that serves as an intermediate program representation, is interpreted. The interpreter performs many runtime checks, therefore Algol68G resembles FLACC <a href="resources.html#ref">[Mailloux 1978]</a>. Algol68G employs the classical multipass scheme to parse Algol 68 <a href="resources.html#ref">[Lindsey 1993]</a>.
</p>

<br>
<h3><a name="diff"></a>Algol68G compared to the Revised Report description</h3>
<p>
This manual contains an <a href="syntax.html">Algol68G syntax summary</a> for quick reference.
<p>
<i>Features of this implementation</i>
<ul>
<li>The interpreter checks on many events, for example:
<ul>
<li>Assigning to, or dereferencing of, <code>NIL</code>.
<li>Using uninitialised values.
<li>Invalid operands to standard prelude operators and procedures.
<li>Bounds check when manipulating arrays.
<li>Overflow of arithmetic modes.
<li>"Dangling references", that are names that refer to deallocated storage.
</ul>
<li>Precision of numeric modes:
<ul>
<li>Implementation of <code>LONG INT, LONG REAL</code> and <code>LONG COMPLEX</code> with roughly doubled precision with respect to <code>INT, REAL, COMPLEX</code>.
<li>Implementation of multiprecision arithmetic through <code>LONG LONG INT, LONG LONG REAL</code> and <code>LONG LONG COMPLEX</code> which are modes with user defined precision which is set by an option.
</ul>
<li>On systems that support them, <a href="extensions.html#envunix">UNIX extensions</a> that allow e.g. for executing child processes that communicate through pipes, matching regular expressions or fetching web page contents.
<li>Procedures for <a href="drawing.html">drawing</a> using the GNU Plotting Utilities.
<li>Various <a href="numerical.html">numerical procedures</a> from the GNU Scientific Library.
<li>Format texts, straightening and <a href="#fmtio">formatted transput</a>. 
Transput routines work generically on files, (dynamic) strings and UNIX pipes.
<li>Support for <a href="http://www.postgresql.org">PostgreSQL</a>, an open-source relational database management system, enabling client applications in Algol 68.
<li>Parallel clause on platforms that support POSIX threads.
<li>Upper stropping is the default, quote stropping is optional.
</ul>

<p>
<i>Extra features compared to the Revised Report language</i>
<ul>
<li>Implementation of C.H. Lindsey's <a href="#params">partial parametrisation proposal</a>, which allows for currying in Algol 68, giving it a functional sublanguage [<a href="resources.html#ref">Koster 1996</a>].
<li>A simple <a href="#refine">refinement preprocessor</a> to facilitate top-down program construction.
<li>Implementation of pseudo-operators <code>ANDF</code> and <code>ORF</code> (or their respective alternatives <code>ANDTH</code> and <code>OREL</code>), defined as
<br>
<ul>
<pre>
tertiary 1 ANDF tertiary 2:
  IF tertiary 1 THEN tertiary 2 ELSE FALSE FI

tertiary 1 ORF tertiary 2:
  IF tertiary 1 THEN TRUE ELSE tertiary 2 FI
</pre>
</ul>
The syntactic position of those pseudo-operator expressions is a boolean-unit, the same as an identity relation. The tertiaries are meek-boolean-tertiaries.
<li>Implementation of <code>DOWNTO</code> with comparable function as <code>TO</code> in loop clauses; <code>DOWNTO</code> <i>decreases</i>, whereas <code>TO</code> <i>increases</i>, the loop counter by the value of the (implicit) by-part. 
For example
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<pre>
# Find last occurence of character in STRING s #

BOOL continue := TRUE;
FOR i FROM UPB s DOWNTO 1
WHILE continue
DO (s[i] = "a" | print (i); continue := FALSE)
OD
</pre>
</font>
</td>
</table>
<p>
<li>Implementation of a post-checked loop. A do-part may enclose a serial clause followed by an optional until-part, or just enclose an until-part. This is an alternative to the paradigm Algol 68 post-check loop <code>WHILE ... DO SKIP OD</code>. An until-part consists of the keyword <code>UNTIL</code> followed by a meek-boolean-enquiry-clause. The loop-clause terminates when the enquiry-clause yields <code>TRUE</code>.
For example
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<pre>
DO UNTIL read string = "continue" OD
</pre>
</font>
</td>
</table>
<p>
<li>Implementation of monadic- and dyadic operator <code>ELEMS</code> that operate on any row, defined as
<ul>
<pre>
OP ELEMS = ("ROWS" z) INT        # total number of elements in "z" #
OP ELEMS = (INT d, "ROWS" z) INT # number of elements in dimension "d" of "z" #
</pre>
</ul>
For example
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
[1 : 10, -5 : 5] INT r;<br>
print ((1 ELEMS r, 2 ELEMS r, ELEMS r)) # prints +10 +11 +110 #
</tt>
</font>
</td>
</table>
<p>
The monadic operator returns the total number of elements while the dyadic operator returns the number of elements in the specified dimension, if this is a valid dimension.
<li>When option <code>brackets</code> is specified, 
<code>(..)</code>, <code>[..]</code> and <code>{..}</code> 
are equivalent to the parser and any pair can be used where Algol 68 requires open-symbols and close-symbols. This allows for clearer coding when parenthesis are nested. For example:
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
poly := a0 + x * (a1 + x * {a2 + x * [a3 + x * a4]});<br>
COMPL z := {cos (phi), -sin (phi)};<br>
ln [x + sqrt {x^2 + 1}]
</tt>
</font>
</td>
</table>
<p>
If <code>brackets</code> is not specified, <code>(..)</code> is an alternative for <code>[..]</code> in bounds and indexers, which is traditional Algol 68 syntax. 
<li>The parser allows for colons, used in bounds and indexers, to be replaced by '<code>..</code>' which is the Pascal style. For instance
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
[1 .. n] INT z;<br>
z [1 .. n OVER 2]
</tt>
</font>
</td>
</table>
</ul>

<p>
<i>Deviations from the Revised Report language</i>
<ul>
<li>The important difference with the Revised Report transput model is that
Algol68G transput does not operate on <code>FLEX [] FLEX [] FLEX [] CHAR</code>,
but on a <code>FLEX [] CHAR</code>.
This maps better onto operating systems as UNIX or Linux.
Details can be found <a name="io_1" href="#io">here</a>.
<li><a name="par"></a>The Algol68G parallel clause deviates from the Algol 68 parallel clause when parallel clauses are nested. In Algol68G, stack frames inside a parallel unit are private, therefore if parallel units modify a shared variable then this variable must be declared outside the outermost parallel clause, and a jump out of a parallel unit can only be targeted at a label outside the outermost parallel clause.
<li>The interpreter does not implement so-called ghost-elements <a href="resources.html#rr">{RR 2.1.3.4}</a>, hence it cannot check bounds when assigning to rows of mode flexible-rows-of-rows-of-... when the destination has a flat descriptor, as in 
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
FLEX [1 : 0] [1 : 3] CHAR s := "more than 3 characters"
</tt>
</font>
</td>
</table>
<p>
A mode flexible-row-of-...-row-of-... is treated as if it were flexible throughout. The scope checker recognises the potential introduction of transient references resulting from this peculiarity in Algol68G.
<br>
<li>Algol68G does not recognise nonlocal environs <a href="resources.html#rr">{RR 5.2.3.2}</a>. All environs are local. Hence constructs as
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
REF INT i = (... | LOC INT | SKIP);<br>
...<br>
[n] REF INT a; FOR k TO n DO a[k] := LOC INT OD
</tt>
</font>
</td>
</table>
<p>
result in a scope violation error with Algol68G. 
<br>
<li>It is not possible to declare in a <code>[WHILE ...] DO ... [UNTIL ...] OD</code> part an identifier with equal spelling as the loop counter identifier. For instance
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
FOR i TO n DO INT i := 2 * n; ... OD;<br>
...<br>
FOR i TO n WHILE INT i := n OVER 2; ... DO ... OD
</tt>
</font>
</td>
</table>
<p>
are not accepted by Algol68G.
<br>
<li>Algol68G will map a declarer whose length is not implemented onto the most appropriate length available <a href="resources.html#rr">{RR 2.1.3.1}</a>. Algol68G considers mapped modes equivalent to the modes they are mapped onto. Routines or operators for not-implemented lengths are mapped accordingly.
</ul>

<br>
<h3><a name="params"></a>Partial parametrisation and currying</h3>
<p>
Algol68G implements C.H. Lindsey's 
<a href="resources.html#rr">proposal for partial parametrisation</a>.
In Algol68G, a
<a href="syntax.html#primaries">
call
</a>
does not require that all arguments be specified. In case not all of the actual-parameters are specified, a call yields a routine 
(with identical body but with already specified arguments stored) 
that requires the unspecified actual-parameters.
When specification of all required actual-parameters is complete (complete closure) a procedure will actually be evaluated to yield its result.
<p>
<small>
<i>Currying, named after Haskell Curry, is transforming a routine taking multiple arguments into a routine taking a single parameter and yielding a routine taking the remaining parameters. 
This transformation is for instance used in lambda-calculus.
Currying gives an imperative language such as Algol 68 a functional sublanguage [<a href="resources.html#ref">Koster 1996</a>].
</i>
</small>
<p>
Algol68G does not save copies of the stack upon partial parametrisation, as does for example LISP; the yield of a partially parametrised call in an environ <i>E</i>, cannot be newer in scope than <i>E</i>.
Therefore stored actual-parameters cannot refer to objects in stack frames that no longer exist, and
dynamic scope checking extends to stored actual-parameters.
</p>
<p>
A routine may be parametrised in several stages. Upon each stage
the yields of the new actual-parameters are stored
inside the routine's locale and the scope of the routine becomes the newest of its original scope and the scopes of those yields.
</p>
<p>
Examples of partial parametrisation:
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<pre>
# Raising a function to a power #

MODE FUN = PROC (REAL) REAL;
PROC pow = (FUN f, INT n, REAL x) REAL: f(x) ** n;
OP ** = (FUN f, INT n) FUN: pow (f, n, );

# Example: sin (3 x) = 3 sin (x) - 4 sin^3 (x) (follows from DeMoivre's theorem) #

REAL x = read real;
print ((new line, sin (3 * x),  3 *  sin (x) - 4 * (sin ** 3) (x)))
</pre>
</font>
</td>
</table>
</p>
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<pre>
# Partial parametrisation applied in handling a linked list #

MODE LIST = STRUCT (INT k, REF LIST next);

PROC map = (REF LIST l, PROC (INT) INT mapping) VOID:
     IF l ISNT NIL
     THEN k OF l := mapping (k OF l);
          map (next OF l, mapping)
     FI;

PROC (REF LIST) VOID zero = map (, (INT n) INT: 0);
PROC (REF LIST) VOID increment = map (, (INT n) INT: n + 1);
PROC (REF LIST) VOID list = map (, (INT n) INT: (print (n); n));

HEAP LIST p := (SKIP, NIL);
zero (p);
increment (p);
list (p)
</pre>
</font>
</td>
</table>
</p>

<br>
<h3><a name="io"></a>Transput implementation</h3>

<h4><a name="genio"></a>Transput in general</h4>
<p>Algol68G transput deviates from the Revised Report specification, as described below.
For an overview of implemented procedures refer to the <a name="envio_1" href="environ.html#envio">standard environment reference</a>.
</p>

<p>
<i>Features of this implementation</i>
<ul>
<li>Algol68G implements mode <code>FORMAT</code>, format texts, straightening and <a href="#fmtio">formatted transput</a>.
<li>Transput procedures operate generically on files, 
<a href="description.html#stringio">strings</a>
and <a href="extensions.html#envunix">UNIX pipes</a>.
For example, next program reads a filename and filters file contents using the UNIX program "od".
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<pre>
PIPE p = execve child pipe ("/usr/bin/od", ("/usr/bin/od", "-c", read string), "");
on logical file end (read OF p, (REF FILE f) BOOL: GOTO end);
DO STRING s;
   get (read OF p, (s, new line));
   put (stand out, ("From pipe: """, s, """", new line))
OD;
end: close (read OF p); close (write OF p)
</pre>
</font>
</td>
</table>
<p>
<li>Algol68G implements Algol68C routines as <code>read int</code> and <code>print int</code>, but not routines as <code>get int</code> and <code>put int</code>.
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
INT k = read int; COMPL z := read compl;
</tt>
</font>
</td>
</table>
<p>
<li>There are two extra procedures to examine a file:
<p>
<dl>
<dt><code>PROC idf = (REF FILE file) STRING</code>
<dd>Returns the identification string of <i>file</i>, if it is set.
<br><br>
<dt><code>PROC term = (REF FILE file) STRING</code>
<dd>Returns the terminator string of <i>file</i>, if it is set.
</dl>
</p>
<li>If a file does not exist upon calling <code>open</code>, the default action will be to create it on the file system.
<li>If a file exists upon calling <code>establish</code>, the event handler set by <code>on open error</code> will be invoked.
<li>Algol68G can write to file <code>stand error</code> with associated channel <code>stand error channel</code>. This file is linked to the standard error stream that is usually directed at the console.
</ul>

<p>
<i>Deviations from the Revised Report</i>
<ul>
<li>The important difference with the Revised Report transput model is that Algol68G transput does not operate on a <code>FLEX [] FLEX [] FLEX [] CHAR</code>, but on a <code>FLEX [] CHAR</code>. 
This maps better onto operating systems as UNIX or Linux.
<li>Getting and putting a file is essentially sequential. Only <code>reset</code> can intervene with sequential processing.
<li>Algol68G currently does not permit switching between <i>read mood</i> and <i>write mood</i> unless the file is <code>reset</code> first (and the file was opened with <code>standback channel</code>). Whether a file is in <i>read mood</i> or <i>write mood</i> is determined by the first actual transput operation (put or get) on a file after opening it.
<li><a name="stringio"></a>Since Algol68G transput operates on a <code>FLEX [] CHAR</code>, routine <code>associate</code> is declared as
<p>
<ul><code>PROC associate = (REF FILE, REF STRING) VOID</code></ul>
<p>
Note that RR specifies a <code>REF [][][] CHAR</code> argument where Algol68G specifies a <code>REF STRING</code> argument. On putting, the string is dynamically lengthened and output is added at the end of the string. 
Attempted getting outside the string provokes an end of file condition, and <code>on file end</code> is invoked.
When a file that is associated with a string is <code>reset</code>, getting restarts from the start of the associated string.
Next (trivial) code fragment illustrates the use of <code>associate</code> in transput.
<p>
<table border=0 cellpadding=12>
<td>
<font color=black><pre>
[n] COMPL u, v;
...
FILE in, out, STRING z; 
associate (in, z); associate (out, z);
putf (out, ($g$, u)); getf (in, ($g$, v));
</pre></font>
</td>
</table>
<p>
<li>Since a file is accessed sequentially, <code>backspace</code> is not implemented.
<li>Since an end on file event handler cannot move the filepointer to a good position (<code>reset</code> also resets a file's <i>read mood</i> and <i>write mood</i>),
encountering end of file terminates getting of a <code>STRING</code> value.
Conform RR, getting of a <code>STRING</code> value will resume if the end of line event handler or the end of page handler returns <code>TRUE</code>.
<li>There is no event routine <code>on char error mended</code>. Attempted conversion of an invalid value for a required mode, or attempted transput of a value that cannot be converted by the current format-pattern, evokes the event routine set by <code>on value error</code>. 
</ul>

<p>
<i>Event handlers</i>
<p>
Algol 68 transput uses event handlers to handle conditions as end of file, end of line, transput error, etcetera. For example, next program will read a filename and echo file contents to standout:
<p>
<table border=0 cellpadding=12>
<td>
<font color=black><pre>
open (standin, read string , standin channel);
on logical file end (standin, (REF FILE f) BOOL: stop);
DO STRING s;
   read ((s, newline)); 
   print ((s, newline))
OD
</pre></font>
</td>
</table>
<p>
Algol68G implements transput-event handlers 
with mode <code>PROC (REF FILE) BOOL</code> that can be set by the procedures listed below. 
An event handler must return <code>TRUE</code> when it can appropriately handle the event or 
<code>FALSE</code> when it cannot. When <code>TRUE</code> is returned, transput resumes, 
otherwise either a runtime error is produced, or a standard corrective action is taken (where specified in below list). Default handlers always return <code>FALSE</code>. 
<p>
<dl>
<dt><code>PROC on file end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dt><code>PROC on logical file end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dt><code>PROC on physical file end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when end of file is reached upon getting.
In Algol 68, <code>on logical file end</code> differs from <code>on physical file end</code> while in Algol68G these are identical, since one cannot position the filepointer outside the file.
<br><br>
<dt><code>PROC on page end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when end of page is reached upon getting. Standard corrective action is to take a new page.
<br><br>
<dt><code>PROC on line end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when end of line is reached upon getting. Standard corrective action is to take a new line.
<br><br>
<dt><code>PROC on value error = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when attempting to convert an invalid value for the required mode, or when attempting to transput a value that cannot be converted by the current format-pattern. The latter is non-standard, and is provided because <code>on char error</code> is not provided in Algol68G.
<br><br>
<dt><code>PROC on format end = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when the file's associated format is exhausted. If this routine yields <code>FALSE</code> then the format is repeated. Note that when a format yielded by a format-pattern ends, control is returned to the embedding format without calling this event routine.
</dl>
</p>
<p>
Next event handlers are not specified by the Revised Report.
</p>
<p>
<dl>
<dt><code>PROC on open error = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when a file cannot be linked as requested.
<br><br>
<dt><code>PROC on transput error = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called on transput failure, other than handled by <code>on value error</code>. 
<br><br>
<dt><code>PROC on format error = (REF FILE, PROC (REF FILE) BOOL) VOID</code>
<dd>The <code>PROC (REF FILE) BOOL</code> event handler will be called when the file's associated format has more pictures than there are arguments to be read or written with that format in a call of <code>readf, printf, writef, getf</code> or <code>putf</code>.
</dl>
</p>

<h4><a name="fmtio"></a>Formatted transput</h4>
<p> Algol68G implements mode <code>FORMAT</code>, format texts, straightening and formatted transput.
The syntax of formats is described in the <a href="syntax.html#formats">Algol68G syntax summary</a>. 
The Algol68G implementation deviates from the Revised Report specification, as described below.
</p>

<p>
<i>Features of this implementation</i>
<ul>
<li>Insertions can be any combination of alignments and literals.
<li>The argument for a general-pattern is an enclosed-clause yielding <code>[] INT</code> (which is a superset of the RR specification). 
<li>The radix for a bits-pattern can be 2 .. 16. The radix can be dynamic, by specifying 
<ul><code>n integral-enclosed-clause r</code></ul> 
<li>The Revised Report specification of getting using an integral choice pattern has the peculiarity that when two literals start with the same sequence of characters, the longer literal should appear first in the list. Algol68G makes no such demand, and will select the correct literal from the list whatever their order.
</ul>

<p>
<i>Deviations from the Revised Report</i>
<ul>
<li>When all arguments in a call of <code>readf, printf, writef, getf</code> or <code>putf</code> are processed, the format associated with the corresponding file is purged - that is, remaining insertions are processed and the format is discarded. 
If a pattern is encountered while purging, then there was no associated argument and the event routine set by <code>on format error</code> is called.
When this event routine returns <code>FALSE</code> (the default routine always returns <code>FALSE</code>) a runtime error will be produced. If one wants  remaining patterns to be silently ignored for a file <code>f</code>, one can specify
<ul><code>on format error (f, (REF FILE g) BOOL: TRUE)</code></ul>
<li><code>SIMPLIN</code> and <code>SIMPLOUT</code> are generic for both formatted and unformatted transput. Therefore <code>SIMPLIN</code> and <code>SIMPLOUT</code> include both mode <code>FORMAT</code> and <code>PROC (REF FILE) VOID</code>. Unformatted transput routines <code>read, print, write, get</code> and <code>put</code> ignore eventual <code>FORMAT</code> arguments. Formatted transput routines <code>readf, printf, writef, getf</code> and <code>putf</code> ignore eventual <code>PROC (REF FILE) VOID</code> arguments.
<li>Insertion <i>x</i> has the same effect as insertion <i>q</i>; both call <code>space</code>.
<li>Insertion <i>y</i> is not implemented since <code>backspace</code> is not implemented (see <a href="#genio">Transput in general</a>). Consequently, insertion <i>k</i> can only move forward.
<li>When a sign is shifted in a sign-mould, any character output by literal insertions in that sign-mould is replaced with a space as well, starting from the first z-frame until the sign is put.
<li>When getting a literal insertion, <code>space</code> is performed for every character in that literal. It is not checked whether read characters actually match the literal.
</ul>

<br>
<h3><a name="assert"></a>Assertions as pre- or postconditions</h3>
<p>Algol68G supports an extension called assertions. Assertions can be viewed in two ways. First, they provide a notation for invariants that can be used to code a proof of correctness together with an algorithm. Hardly anyone does this, but assertions make for debugging statements. The syntax for assertions reads
<p>
Assertion syntax can be found in the <a href="syntax.html#assertions">syntax summary</a>.
<p>Under control of the 'assertions' and 'noassertions' pragmat items, the tertiary of an assertion is elaborated at runtime. If the tertiary yields <code>FALSE</code>, a runtime error is produced. For example,
<p>
<table border=0 cellpadding=12>
<td>
<font color=black><pre>
OP FACULTY = (INT n) INT:
   IF ASSERT (n >= 0); 
      n > 0 
   THEN n * FACULTY (n - 1) 
   ELSE 1 
   FI
</pre></font>
</td>
</table>
<p>
will produce an error when <code>FACULTY</code> is called with a negative argument.
</p>

<br>
<h3><a name="prep"></a>The preprocessor</h3>
<p>
Algol68G has a basic preprocessor. 
Currently, the preprocessor supports these features:
<ul>
<li>concatenation of lines,
<li>inclusion of files,
<li>refinement preprocessor,
<li>switching the preprocessor on or off.
</ul>
<h4><a name="prepcat"></a>Concatenation of lines</h4>
<p>
Concatenation of lines is similar to what the C preprocessor does. Any line that ends in a backslash ('\') will be concatenated with the line following it. For example:
<p>
<table border=0 cellpadding=12>
<td>
<font color=black><tt>
STRING s := "spanning two \<br>
lines"
</tt></font>
</td>
</table>
<p>
will become
<p>
<table border=0 cellpadding=12>
<td>
<font color=black><tt>
STRING s := "spanning two lines"
</tt></font>
</td>
</table>
<p>
Using a backslash as an escape character causes no interference with Algol 68 source text since when using upper stropping, a backslash is an unworthy character; when using quote stropping a backslash is a times-ten-symbol, but a real-denotation cannot span end-of-line hence no interference occurs. 
<p>
Note that when you make use of line concatenation, diagnostics in a concatenated line may be placed in an earlier source line than its actual line in the original source text. In order to preserve line numbering as much as possible, a line is emptied but not deleted if it is joined with a preceeding one. This shows in the listing file as emptied lines.
</p>

<h4><a name="prepinc"></a>Inclusion of files</h4>
<p>
Algol68G supports inclusion of other files in an Algol 68 source text. The inclusion directive reads:
<p>
<table border=0 cellpadding=12>
<td>
<font color=black>
<tt>
PR read "filename" PR<br>
PR include "filename" PR
</tt>
</font>
</td>
</table>
<p>
The file with name <i>filename</i> is inserted textually <i>before</i> the line that holds the file inclusion directive. 
In this way tokens remain in their original lines, which will give more accurate placement of diagnostics. It is therefore recommended that a file inclusion directive be the only text on the line it is in. A file will only be inserted once, on attempted multiple inclusion the file is ignored. Attempted multiple inclusion may for example result from specifying, in an included file, an inclusion directive for an already included file.
</p>

<h4><a name="refine"></a>The refinement preprocessor</h4>
<p>
Algol68G is equipped with a refinement preprocessor, which allows programming through stepwise refinement as taught in <a href="introduction.html#programmeren">[Koster 1978, 1981]</a>.
The idea is to facilitate program construction by elaborating the description of the solution to a problem as ever more detailed steps until the description of the solution is complete. (See also <a href="http://www.acm.org/classics/dec95">Wirth's well known lecture</a>). 

<p>Refinement syntax can be found in the <a href="syntax.html#refinements">syntax summary</a>. Refinements cannot be recursive, nor can their definitions be nested. Also, refinement definitions must be unique, and a refinement can only be applied once (refinements are not procedures).
Algol68G will check whether a program looks like a stepwise refined program. The refinement preprocessor is transparent to programs that are not stepwise refined.
</p>

<h4><a name="prepsw"></a>Switching the preprocessor on or off</h4>
<p>
It is possible to switch the preprocessor on or off. The preprocessor is default switched on. If switched off, it will no longer process preprocessor items embedded in pragmats, except for switching the preprocessor on again. Concatenation of lines takes place even if the preprocessor is switched off.
<ul>
<dl>
<dt><code>PR preprocessor PR</code>
<dd>Switches the preprocessor on if it is switched off.
<dt><code>PR nopreprocessor PR</code>
<dd>Switches the preprocessor off if it is switched on.
</dl>
</ul>
</p>

<br>
<h3><a name="speed"></a>Interpreter speed</h3>
<p>The speed of the interpreter will depend on platform and application. To have a crude comparison, Algol68G was rated with the Whetstone benchmark. Next table compiles approximate Whetstone ratings for some personal computers running Algol68G and ratings for compiled FORTRAN code on various machines from the past (many of which ran 
<a href="resources.html#implementations">legacy Algol 68 implementations</a>). 
<p>
Algol 68 Genie speed approximately scales linearly in clock speed when run on PowerPC or ix86.
<p>
<table border=0 cellspacing=0 cellpadding=6>
<tr><td bgcolor=#e8e8e8><b>System</b></td><td bgcolor="#e8e8e8"><b>MWhets</b></td><td bgcolor="#e8e8e8"><b>Remarks</b></td></tr>
<tr><td bgcolor=#e8e8e8>VAX 11/785<br>IBM 4341-2</td><td bgcolor="#e8e8e8">1</td><td bgcolor="#e8e8e8">FORTRAN</td>
<tr><td bgcolor=#e8e8e8>ICL 2980<br>IBM 370/168</td><td bgcolor="#e8e8e8">2</td><td bgcolor="#e8e8e8">FORTRAN</td></tr>
<tr><td bgcolor=#e8e8e8>PowerPC G3 (233 MHz)</td><td bgcolor="#e8e8e8">2</td><td bgcolor="#e8e8e8">Algol68G/Linux/gcc</td></tr>
<tr><td bgcolor=#e8e8e8>Cyber 7600</td><td bgcolor="#e8e8e8">9</td><td bgcolor="#e8e8e8">FORTRAN</td></tr>
<tr><td bgcolor=#e8e8e8>Pentium III (1.2 GHz)</td><td bgcolor="#e8e8e8">10</td><td bgcolor="#e8e8e8">Algol68G/Windows XP/gcc</td></tr>
<tr><td bgcolor=#e8e8e8>Cyber 205 (Scalar)<br>Cray-1A (Scalar)<br></td><td bgcolor="#e8e8e8">12</td><td bgcolor="#e8e8e8">FORTRAN</td></tr>
<tr><td bgcolor=#e8e8e8>PowerPC G5 (Dual 2.5 GHz)</td><td bgcolor="#e8e8e8">20</td><td bgcolor="#e8e8e8">Algol68G/MacOS X/gcc</td></tr>
<tr><td bgcolor=#e8e8e8>Pentium IV (3 GHz)</td><td bgcolor="#e8e8e8">23</td><td bgcolor="#e8e8e8">Algol68G/OpenBSD/gcc</td></tr>
</table>
</p>

<br>
<br>
<h3><a name="limitations"></a>Limitations and bugs</h3>
<ul>
<li>The interpreter offers optional checking of the system stack. When this check is not activated, or on systems where this check would not work, the following may result in a segment violation: 
<ul>
<li>Deep recursion.
<li>Garbage collection of deeply recursive data structures.
<li>Using jumps to move between incarnations of recursive procedures.
</ul>
<li>When the <a href="synopsis.html#optionmem">stack overhead</a> is set to a too small value, a segment violation may occur.
<li>Algorithms for extended precision (<code>LONG LONG</code> arithmetic modes)</code> are not really suited for precisions larger than about a thousand digits. State of the art in the field offers more efficient algorithms than implemented here.
<li>Overflow- and underflow checks on <code>REAL</code> and <code>COMPLEX</code> operations require IEEE-754 compatibility. Many processor types, notably ix86's and PowerPC processors, are IEEE-754 compatible.
<li>A garbage collector cannot solve all memory allocation issues. It is therefore possible to get an unexpected "out of memory" diagnostic. Two options in such case are (1) to increase heap size or (2) to call standard prelude routine "sweep heap" or "preemptive sweep heap" at strategic positions in the program.
</ul>
</td>

</td>
</table>

<p>
<br>
<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<font color="black">
<small>Copyright &copy; 2001-2006 J. Marcel van der Veer.</small>
</font>
</td>
<td width="50%" align=right valign=top bgcolor="white">
<font color="black">
<small>Documentation for Algol 68 Genie Mark 9.2 (July 2006)</small>
</font>
</td>
</table>
</p>
</body>
</html>
