# This program is part of the Rennes Test Set, 
  automatically generated from the Algol 68 grammar 
  using a formalism of B. Houssais (University of Rennes, 1975).
 
  This test set is available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

# r541a #
(print (("routine texts without parameters", newline));
 INT vf = 47 * 10 + 45;
 
 INT ctr := 0, ctrt := 0, ctrloc;
 
 PROC ctrl = (INT inc) VOID:
      (ctr /= ctrloc + inc | print (("count er in test", ctrt, ctr, ctrloc + inc, newline)));
 
 # servitudes pour les corps de routines #
 OP MON = (REAL a) REAL:
    (ctr +:= 1; 3.1415),
     = = (BOOL a, INT b) INT:
    (a | b | ctr -:= 1),
 UNION (INT, BOOL) vu,
 MODE STRA = STRUCT (INT de, REF INT of),
 [, ] INT ta = 1,
 PROC pra = (UNION (INT, BOOL) a) INT:
      (a | (INT x): (ctr +:= 1; x)),
 INT ida = 1;
 
 MODE STRB = STRUCT (BOOL de, REF INT of),
 [, ] BOOL tb = TRUE,
 PROC prb = (UNION (INT, BOOL) a) BOOL:
      (a | (BOOL x): (ctr +:= 1; x)),
 BOOL idb = TRUE;
 
 # mode rendu :  PROC  INT  #
 (MODE R = PROC INT;
  
  PROC test = (R proc) VOID:
       IF proc = 1
       THEN ctr +:= 1
       ELSE print (("er", ctrt, ctr - ctrloc, newline))
       FI;
  
  OP ?=:= = (R x) R:
     (test (x);
      x);
  
  (ctrt := 1;
   ctrloc := ctr;
   test (INT:
         LOC INT := (ctr +:= 1; 1));
   FOR ident FROM INT:
   LOC INT := (ctr +:= 1; 1) BY INT:
   LOC INT := (ctr +:= 1; 1) TO INT:
   LOC INT := (ctr +:= 1; 1) 
   WHILE BOOL:
         LOC BOOL := (ctr +:= 1; TRUE)
   DO [INT:
       LOC INT := (ctr +:= 1; 1) : 4, -1 : INT:
       LOC INT := (ctr +:= 1; 1)] R ent;
      
      ent[INT:
          LOC INT := (ctr +:= 1; 1), 0] := ent[1, INT:
                                               LOC INT := (ctr +:= 1; 1)] := INT:
      LOC INT := (ctr +:= 1; 1);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            LOC INT := (ctr +:= 1; 1);
            REAL e = 0.12345;
            
            INT:
            LOC INT := (ctr +:= 1; 1));
   
   test (par);
   alfa := ?=:=(INT:
                LOC INT := (ctr +:= 1; 1));
   R ident = INT:
   LOC INT := (ctr +:= 1; 1),
   R loc := CASE INT:
                 LOC INT := (ctr +:= 1; 1)
   IN INT:
      LOC INT := (ctr +:= 1; 1), SKIP
   ESAC, tas := INT:
   LOC INT := (ctr +:= 1; 1);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        LOC INT := (ctr +:= 1; 1),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
LOC INT := (ctr +:= 1; 1), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               LOC INT := (ctr +:= 1; 1), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         LOC INT := (ctr +:= 1; 1));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                LOC INT := (ctr +:= 1; 1), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  LOC INT := (ctr +:= 1; 1)
          END), ?=:=(union; BOOL:
    LOC BOOL := (ctr +:= 1; TRUE) | INT:
    LOC INT := (ctr +:= 1; 1)), INT:
    LOC INT := (ctr +:= 1; 1), test ((BOOL bool = FALSE; union | (R): INT:
                                     LOC INT := (ctr +:= 1; 1), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 2;
   ctrloc := ctr;
   test (INT:
         INT:
         (ctr +:= 1; 1));
   FOR ident FROM INT:
   INT:
   (ctr +:= 1; 1) BY INT:
   INT:
   (ctr +:= 1; 1) TO INT:
   INT:
   (ctr +:= 1; 1) 
   WHILE BOOL:
         BOOL:
         (ctr +:= 1; TRUE)
   DO [INT:
       INT:
       (ctr +:= 1; 1) : 4, -1 : INT:
       INT:
       (ctr +:= 1; 1)] R ent;
      
      ent[INT:
          INT:
          (ctr +:= 1; 1), 0] := ent[1, INT:
                                    INT:
                                    (ctr +:= 1; 1)] := INT:
      INT:
      (ctr +:= 1; 1);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            INT:
            (ctr +:= 1; 1);
            REAL e = 0.12345;
            
            INT:
            INT:
            (ctr +:= 1; 1));
   
   test (par);
   alfa := ?=:=(INT:
                INT:
                (ctr +:= 1; 1));
   R ident = INT:
   INT:
   (ctr +:= 1; 1),
   R loc := CASE INT:
                 INT:
                 (ctr +:= 1; 1)
   IN INT:
      INT:
      (ctr +:= 1; 1), SKIP
   ESAC, tas := INT:
   INT:
   (ctr +:= 1; 1);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        INT:
        (ctr +:= 1; 1),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
INT:
(ctr +:= 1; 1), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               INT:
               (ctr +:= 1; 1), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         INT:
         (ctr +:= 1; 1));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                INT:
                                (ctr +:= 1; 1), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  INT:
                  (ctr +:= 1; 1)
          END), ?=:=(union; BOOL:
    BOOL:
    (ctr +:= 1; TRUE) | INT:
    INT:
    (ctr +:= 1; 1)), INT:
    INT:
    (ctr +:= 1; 1), test ((BOOL bool = FALSE; union | (R): INT:
                          INT:
                          (ctr +:= 1; 1), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 3;
   ctrloc := ctr;
   test (INT: 3.1415 = MON 0.5 = 1);
   FOR ident FROM INT: 3.1415 = MON 0.5 = 1 BY INT: 3.1415 = MON 0.5 = 1 TO INT: 3.1415 = MON 0.5 = 1 
   WHILE BOOL: 3.1415 = MON 0.5 = TRUE
   DO [INT: 3.1415 = MON 0.5 = 1 : 4, -1 : INT: 3.1415 = MON 0.5 = 1] R ent;
      
      ent[INT: 3.1415 = MON 0.5 = 1, 0] := ent[1, INT: 3.1415 = MON 0.5 = 1] := INT: 3.1415 = MON 0.5 = 1;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT: 3.1415 = MON 0.5 = 1;
            REAL e = 0.12345;
            
            INT: 3.1415 = MON 0.5 = 1);
   
   test (par);
   alfa := ?=:=(INT: 3.1415 = MON 0.5 = 1);
   R ident = INT: 3.1415 = MON 0.5 = 1,
   R loc := CASE INT: 3.1415 = MON 0.5 = 1
   IN INT: 3.1415 = MON 0.5 = 1, SKIP
   ESAC, tas := INT: 3.1415 = MON 0.5 = 1;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: INT: 3.1415 = MON 0.5 = 1,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT: 3.1415 = MON 0.5 = 1, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT: 3.1415 = MON 0.5 = 1, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT: 3.1415 = MON 0.5 = 1);
   
   UNION (R, CHAR) union := pr (proc, INT: 3.1415 = MON 0.5 = 1, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT: 3.1415 = MON 0.5 = 1 END), ?=:=(union; BOOL: 3.1415 = MON 0.5 = TRUE | INT: 3.1415 = MON 0.5 = 1), INT: 3.1415 = MON 0.5 = 1, test ((BOOL bool = FALSE; union | (R): INT: 3.1415 = MON 0.5 = 1, (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 4;
   ctrloc := ctr;
   test (INT:
         de OF STRA (1, ctr +:= 1));
   FOR ident FROM INT:
   de OF STRA (1, ctr +:= 1) BY INT:
   de OF STRA (1, ctr +:= 1) TO INT:
   de OF STRA (1, ctr +:= 1) 
   WHILE BOOL:
         de OF STRB (TRUE, ctr +:= 1)
   DO [INT:
       de OF STRA (1, ctr +:= 1) : 4, -1 : INT:
       de OF STRA (1, ctr +:= 1)] R ent;
      
      ent[INT:
          de OF STRA (1, ctr +:= 1), 0] := ent[1, INT:
                                               de OF STRA (1, ctr +:= 1)] := INT:
      de OF STRA (1, ctr +:= 1);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            de OF STRA (1, ctr +:= 1);
            REAL e = 0.12345;
            
            INT:
            de OF STRA (1, ctr +:= 1));
   
   test (par);
   alfa := ?=:=(INT:
                de OF STRA (1, ctr +:= 1));
   R ident = INT:
   de OF STRA (1, ctr +:= 1),
   R loc := CASE INT:
                 de OF STRA (1, ctr +:= 1)
   IN INT:
      de OF STRA (1, ctr +:= 1), SKIP
   ESAC, tas := INT:
   de OF STRA (1, ctr +:= 1);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        de OF STRA (1, ctr +:= 1),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
de OF STRA (1, ctr +:= 1), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               de OF STRA (1, ctr +:= 1), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         de OF STRA (1, ctr +:= 1));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                de OF STRA (1, ctr +:= 1), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  de OF STRA (1, ctr +:= 1)
          END), ?=:=(union; BOOL:
    de OF STRB (TRUE, ctr +:= 1) | INT:
    de OF STRA (1, ctr +:= 1)), INT:
    de OF STRA (1, ctr +:= 1), test ((BOOL bool = FALSE; union | (R): INT:
                                     de OF STRA (1, ctr +:= 1), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 5;
   ctrloc := ctr;
   test (INT:
         ta[ida, (ctr +:= 1; 1)]);
   FOR ident FROM INT:
   ta[ida, (ctr +:= 1; 1)] BY INT:
   ta[ida, (ctr +:= 1; 1)] TO INT:
   ta[ida, (ctr +:= 1; 1)] 
   WHILE BOOL:
         tb[ida, (ctr +:= 1; 1)]
   DO [INT:
       ta[ida, (ctr +:= 1; 1)] : 4, -1 : INT:
       ta[ida, (ctr +:= 1; 1)]] R ent;
      
      ent[INT:
          ta[ida, (ctr +:= 1; 1)], 0] := ent[1, INT:
                                             ta[ida, (ctr +:= 1; 1)]] := INT:
      ta[ida, (ctr +:= 1; 1)];
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            ta[ida, (ctr +:= 1; 1)];
            REAL e = 0.12345;
            
            INT:
            ta[ida, (ctr +:= 1; 1)]);
   
   test (par);
   alfa := ?=:=(INT:
                ta[ida, (ctr +:= 1; 1)]);
   R ident = INT:
   ta[ida, (ctr +:= 1; 1)],
   R loc := CASE INT:
                 ta[ida, (ctr +:= 1; 1)]
   IN INT:
      ta[ida, (ctr +:= 1; 1)], SKIP
   ESAC, tas := INT:
   ta[ida, (ctr +:= 1; 1)];
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        ta[ida, (ctr +:= 1; 1)],
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
ta[ida, (ctr +:= 1; 1)], (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               ta[ida, (ctr +:= 1; 1)], proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         ta[ida, (ctr +:= 1; 1)]);
   
   UNION (R, CHAR) union := pr (proc, INT:
                                ta[ida, (ctr +:= 1; 1)], proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  ta[ida, (ctr +:= 1; 1)]
          END), ?=:=(union; BOOL:
    tb[ida, (ctr +:= 1; 1)] | INT:
    ta[ida, (ctr +:= 1; 1)]), INT:
    ta[ida, (ctr +:= 1; 1)], test ((BOOL bool = FALSE; union | (R): INT:
                                   ta[ida, (ctr +:= 1; 1)], (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 6;
   ctrloc := ctr;
   test (INT: pra (1));
   FOR ident FROM INT: pra (1) BY INT: pra (1) TO INT: pra (1) 
   WHILE BOOL: prb (TRUE)
   DO [INT: pra (1) : 4, -1 : INT: pra (1)] R ent;
      
      ent[INT: pra (1), 0] := ent[1, INT: pra (1)] := INT: pra (1);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT: pra (1);
            REAL e = 0.12345;
            
            INT: pra (1));
   
   test (par);
   alfa := ?=:=(INT: pra (1));
   R ident = INT: pra (1),
   R loc := CASE INT: pra (1)
   IN INT: pra (1), SKIP
   ESAC, tas := INT: pra (1);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: INT: pra (1),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT: pra (1), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT: pra (1), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT: pra (1));
   
   UNION (R, CHAR) union := pr (proc, INT: pra (1), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT: pra (1)
          END), ?=:=(union; BOOL: prb (TRUE) | INT: pra (1)), INT: pra (1), test ((BOOL bool = FALSE; union | (R): INT: pra (1), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 7;
   ctrloc := ctr;
   test (INT:
         INT (ctr +:= 1; ida | 1, SKIP));
   FOR ident FROM INT:
   INT (ctr +:= 1; ida | 1, SKIP) BY INT:
   INT (ctr +:= 1; ida | 1, SKIP) TO INT:
   INT (ctr +:= 1; ida | 1, SKIP) 
   WHILE BOOL:
         BOOL (ctr +:= 1; ida | TRUE, SKIP)
   DO [INT:
       INT (ctr +:= 1; ida | 1, SKIP) : 4, -1 : INT:
       INT (ctr +:= 1; ida | 1, SKIP)] R ent;
      
      ent[INT:
          INT (ctr +:= 1; ida | 1, SKIP), 0] := ent[1, INT:
                                                    INT (ctr +:= 1; ida | 1, SKIP)] := INT:
      INT (ctr +:= 1; ida | 1, SKIP);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            INT (ctr +:= 1; ida | 1, SKIP);
            REAL e = 0.12345;
            
            INT:
            INT (ctr +:= 1; ida | 1, SKIP));
   
   test (par);
   alfa := ?=:=(INT:
                INT (ctr +:= 1; ida | 1, SKIP));
   R ident = INT:
   INT (ctr +:= 1; ida | 1, SKIP),
   R loc := CASE INT:
                 INT (ctr +:= 1; ida | 1, SKIP)
   IN INT:
      INT (ctr +:= 1; ida | 1, SKIP), SKIP
   ESAC, tas := INT:
   INT (ctr +:= 1; ida | 1, SKIP);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        INT (ctr +:= 1; ida | 1, SKIP),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
INT (ctr +:= 1; ida | 1, SKIP), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               INT (ctr +:= 1; ida | 1, SKIP), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         INT (ctr +:= 1; ida | 1, SKIP));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                INT (ctr +:= 1; ida | 1, SKIP), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  INT (ctr +:= 1; ida | 1, SKIP)
          END), ?=:=(union; BOOL:
    BOOL (ctr +:= 1; ida | TRUE, SKIP) | INT:
    INT (ctr +:= 1; ida | 1, SKIP)), INT:
    INT (ctr +:= 1; ida | 1, SKIP), test ((BOOL bool = FALSE; union | (R): INT:
                                          INT (ctr +:= 1; ida | 1, SKIP), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 8;
   ctrloc := ctr;
   test (INT:
         BEGIN INT x;
               
               ctr +:= 1;
               e: 1 EXIT
               f: SKIP
         END);
   FOR ident FROM INT:
   BEGIN INT x;
         
         ctr +:= 1;
         e: 1 EXIT
         f: SKIP
   END BY INT:
   BEGIN INT x;
         
         ctr +:= 1;
         e: 1 EXIT
         f: SKIP
   END TO INT:
   BEGIN INT x;
         
         ctr +:= 1;
         e: 1 EXIT
         f: SKIP
   END 
   WHILE BOOL:
         BEGIN INT x;
               
               ctr +:= 1;
               e: TRUE EXIT
               f: SKIP
         END
   DO [INT:
       BEGIN INT x;
             
             ctr +:= 1;
             e: 1 EXIT
             f: SKIP
       END : 4, -1 : INT:
       BEGIN INT x;
             
             ctr +:= 1;
             e: 1 EXIT
             f: SKIP
       END] R ent;
      
      ent[INT:
          BEGIN INT x;
                
                ctr +:= 1;
                e: 1 EXIT
                f: SKIP
          END, 0] := ent[1, INT:
                         BEGIN INT x;
                               
                               ctr +:= 1;
                               e: 1 EXIT
                               f: SKIP
                         END] := INT:
      BEGIN INT x;
            
            ctr +:= 1;
            e: 1 EXIT
            f: SKIP
      END;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            BEGIN INT x;
                  
                  ctr +:= 1;
                  e: 1 EXIT
                  f: SKIP
            END;
            REAL e = 0.12345;
            
            INT:
            BEGIN INT x;
                  
                  ctr +:= 1;
                  e: 1 EXIT
                  f: SKIP
            END);
   
   test (par);
   alfa := ?=:=(INT:
                BEGIN INT x;
                      
                      ctr +:= 1;
                      e: 1 EXIT
                      f: SKIP
                END);
   R ident = INT:
   BEGIN INT x;
         
         ctr +:= 1;
         e: 1 EXIT
         f: SKIP
   END,
   R loc := CASE INT:
                 BEGIN INT x;
                       
                       ctr +:= 1;
                       e: 1 EXIT
                       f: SKIP
                 END
   IN INT:
      BEGIN INT x;
            
            ctr +:= 1;
            e: 1 EXIT
            f: SKIP
      END, SKIP
   ESAC, tas := INT:
   BEGIN INT x;
         
         ctr +:= 1;
         e: 1 EXIT
         f: SKIP
   END;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        BEGIN INT x;
              
              ctr +:= 1;
              e: 1 EXIT
              f: SKIP
        END,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
BEGIN INT x;
      
      ctr +:= 1;
      e: 1 EXIT
      f: SKIP
END, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               BEGIN INT x;
                     
                     ctr +:= 1;
                     e: 1 EXIT
                     f: SKIP
               END, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         BEGIN INT x;
               
               ctr +:= 1;
               e: 1 EXIT
               f: SKIP
         END);
   
   UNION (R, CHAR) union := pr (proc, INT:
                                BEGIN INT x;
                                      
                                      ctr +:= 1;
                                      e: 1 EXIT
                                      f: SKIP
                                END, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  BEGIN INT x;
                        
                        ctr +:= 1;
                        e: 1 EXIT
                        f: SKIP
                  END
          END), ?=:=(union; BOOL:
    BEGIN INT x;
          
          ctr +:= 1;
          e: TRUE EXIT
          f: SKIP
    END | INT:
    BEGIN INT x;
          
          ctr +:= 1;
          e: 1 EXIT
          f: SKIP
    END), INT:
    BEGIN INT x;
          
          ctr +:= 1;
          e: 1 EXIT
          f: SKIP
    END, test ((BOOL bool = FALSE; union | (R): INT:
               BEGIN INT x;
                     
                     ctr +:= 1;
                     e: 1 EXIT
                     f: SKIP
               END, (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 9;
   ctrloc := ctr;
   test (INT:
         (NOT idb | SKIP | ctr +:= 1; ida));
   FOR ident FROM INT:
   (NOT idb | SKIP | ctr +:= 1; ida) BY INT:
   (NOT idb | SKIP | ctr +:= 1; ida) TO INT:
   (NOT idb | SKIP | ctr +:= 1; ida) 
   WHILE BOOL:
         (NOT idb | SKIP | ctr +:= 1; idb)
   DO [INT:
       (NOT idb | SKIP | ctr +:= 1; ida) : 4, -1 : INT:
       (NOT idb | SKIP | ctr +:= 1; ida)] R ent;
      
      ent[INT:
          (NOT idb | SKIP | ctr +:= 1; ida), 0] := ent[1, INT:
                                                       (NOT idb | SKIP | ctr +:= 1; ida)] := INT:
      (NOT idb | SKIP | ctr +:= 1; ida);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            (NOT idb | SKIP | ctr +:= 1; ida);
            REAL e = 0.12345;
            
            INT:
            (NOT idb | SKIP | ctr +:= 1; ida));
   
   test (par);
   alfa := ?=:=(INT:
                (NOT idb | SKIP | ctr +:= 1; ida));
   R ident = INT:
   (NOT idb | SKIP | ctr +:= 1; ida),
   R loc := CASE INT:
                 (NOT idb | SKIP | ctr +:= 1; ida)
   IN INT:
      (NOT idb | SKIP | ctr +:= 1; ida), SKIP
   ESAC, tas := INT:
   (NOT idb | SKIP | ctr +:= 1; ida);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        (NOT idb | SKIP | ctr +:= 1; ida),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
(NOT idb | SKIP | ctr +:= 1; ida), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               (NOT idb | SKIP | ctr +:= 1; ida), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         (NOT idb | SKIP | ctr +:= 1; ida));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                (NOT idb | SKIP | ctr +:= 1; ida), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  (NOT idb | SKIP | ctr +:= 1; ida)
          END), ?=:=(union; BOOL:
    (NOT idb | SKIP | ctr +:= 1; idb) | INT:
    (NOT idb | SKIP | ctr +:= 1; ida)), INT:
    (NOT idb | SKIP | ctr +:= 1; ida), test ((BOOL bool = FALSE; union | (R): INT:
                                             (NOT idb | SKIP | ctr +:= 1; ida), (CHAR car): SKIP)));
   ctrl (47));
  (ctrt := 10;
   ctrloc := ctr;
   test (INT:
         CASE vu := (ctr +:= 1; 1)
         IN (INT x): x
         ESAC);
   FOR ident FROM INT:
   CASE vu := (ctr +:= 1; 1)
   IN (INT x): x
   ESAC BY INT:
   CASE vu := (ctr +:= 1; 1)
   IN (INT x): x
   ESAC TO INT:
   CASE vu := (ctr +:= 1; 1)
   IN (INT x): x
   ESAC 
   WHILE BOOL:
         CASE vu := (ctr +:= 1; TRUE)
         IN (BOOL x): x
         ESAC
   DO [INT:
       CASE vu := (ctr +:= 1; 1)
       IN (INT x): x
       ESAC : 4, -1 : INT:
       CASE vu := (ctr +:= 1; 1)
       IN (INT x): x
       ESAC] R ent;
      
      ent[INT:
          CASE vu := (ctr +:= 1; 1)
          IN (INT x): x
          ESAC, 0] := ent[1, INT:
                          CASE vu := (ctr +:= 1; 1)
                          IN (INT x): x
                          ESAC] := INT:
      CASE vu := (ctr +:= 1; 1)
      IN (INT x): x
      ESAC;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            CASE vu := (ctr +:= 1; 1)
            IN (INT x): x
            ESAC;
            REAL e = 0.12345;
            
            INT:
            CASE vu := (ctr +:= 1; 1)
            IN (INT x): x
            ESAC);
   
   test (par);
   alfa := ?=:=(INT:
                CASE vu := (ctr +:= 1; 1)
                IN (INT x): x
                ESAC);
   R ident = INT:
   CASE vu := (ctr +:= 1; 1)
   IN (INT x): x
   ESAC,
   R loc := CASE INT:
                 CASE vu := (ctr +:= 1; 1)
                 IN (INT x): x
                 ESAC
   IN INT:
      CASE vu := (ctr +:= 1; 1)
      IN (INT x): x
      ESAC, SKIP
   ESAC, tas := INT:
   CASE vu := (ctr +:= 1; 1)
   IN (INT x): x
   ESAC;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        CASE vu := (ctr +:= 1; 1)
        IN (INT x): x
        ESAC,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
CASE vu := (ctr +:= 1; 1)
IN (INT x): x
ESAC, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               CASE vu := (ctr +:= 1; 1)
               IN (INT x): x
               ESAC, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         CASE vu := (ctr +:= 1; 1)
         IN (INT x): x
         ESAC);
   
   UNION (R, CHAR) union := pr (proc, INT:
                                CASE vu := (ctr +:= 1; 1)
                                IN (INT x): x
                                ESAC, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT:
                  CASE vu := (ctr +:= 1; 1)
                  IN (INT x): x
                  ESAC
          END), ?=:=(union; BOOL:
    CASE vu := (ctr +:= 1; TRUE)
    IN (BOOL x): x
    ESAC | INT:
    CASE vu := (ctr +:= 1; 1)
    IN (INT x): x
    ESAC), INT:
    CASE vu := (ctr +:= 1; 1)
    IN (INT x): x
    ESAC, test ((BOOL bool = FALSE; union | (R): INT:
                CASE vu := (ctr +:= 1; 1)
                IN (INT x): x
                ESAC, (CHAR car): SKIP)));
   ctrl (47));
  SKIP);
 # mode rendu :  INT  #
 (MODE R = INT;
  
  PROC test = (R proc) VOID:
       IF proc = 1
       THEN ctr +:= 1
       ELSE print (("er", ctrt, ctr - ctrloc, newline))
       FI;
  
  OP ?=:= = (R x) R:
     (test (x);
      x);
  
  (ctrt := 11;
   ctrloc := ctr;
   test (INT:
         LOC INT := (ctr +:= 1; 1));
   FOR ident FROM INT:
   INT:
   (ctr +:= 1; 1) BY INT: pra (1) TO INT:
   ta[ida, (ctr +:= 1; 1)] 
   WHILE BOOL:
         tb[ida, (ctr +:= 1; 1)]
   DO [INT:
       de OF STRA (1, ctr +:= 1) : 4, -1 : INT:
       LOC INT := (ctr +:= 1; 1)] R ent;
      
      ent[INT:
          CASE vu := (ctr +:= 1; 1)
          IN (INT x): x
          ESAC, 0] := ent[1, INT:
                          INT:
                          (ctr +:= 1; 1)] := INT:
      BEGIN INT x;
            
            ctr +:= 1;
            e: 1 EXIT
            f: SKIP
      END;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            INT:
            LOC INT := (ctr +:= 1; 1);
            REAL e = 0.12345;
            
            INT:
            INT (ctr +:= 1; ida | 1, SKIP));
   
   test (par);
   alfa := ?=:=(INT:
                INT:
                (ctr +:= 1; 1));
   R ident = INT:
   INT (ctr +:= 1; ida | 1, SKIP),
   R loc := CASE INT:
                 de OF STRA (1, ctr +:= 1)
   IN INT:
      ta[ida, (ctr +:= 1; 1)], SKIP
   ESAC, tas := INT: pra (1);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        INT:
        INT:
        (ctr +:= 1; 1),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (INT:
BEGIN INT x;
      
      ctr +:= 1;
      e: 1 EXIT
      f: SKIP
END, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, INT:
               (NOT idb | SKIP | ctr +:= 1; ida), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         INT:
         INT (ctr +:= 1; ida | 1, SKIP));
   
   UNION (R, CHAR) union := pr (proc, INT:
                                INT (ctr +:= 1; ida | 1, SKIP), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN INT: pra (1)
          END), ?=:=(union; BOOL: prb (TRUE) | INT: pra (1)), INT:
    de OF STRA (1, ctr +:= 1), test ((BOOL bool = FALSE; union | (R): INT:
                                     de OF STRA (1, ctr +:= 1), (CHAR car): SKIP)));
   ctrl (45));
  SKIP);
 print ((ctr, " tests ", (ctr = vf | "ok" | "error"))))