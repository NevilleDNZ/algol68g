# This program is part of the
 
     Revised Mathematisch Centrum Algol 68 Test Set

  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.

  This test set is available from:

     http://www.dickgrune.com/CS/Algol68

  or from the Vrije Universiteit Amsterdam:

     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#misc05#

# Runs and yields 1.0, 1.0, 1.0, -2.0 #
BEGIN MODE FORM = UNION (REF CONST, REF VAR, REF TRIPLE, REF CALL),
            CONST = STRUCT (REAL value),
            VAR = STRUCT (STRING name, REAL value),
            TRIPLE = STRUCT (FORM leftoperand, INT operator, FORM rightoperand),
            FUNCTION = STRUCT (REF VAR boundvar, FORM body),
            CALL = STRUCT (REF FUNCTION functionname, FORM parameter);
      
      INT plus = 1, minus = 2, times = 3, by = 4, to = 5;
      
      HEAP CONST zero, one;
      
      value OF zero := 0;
      value OF one := 1;
      OP = = (FORM a, REF CONST b) BOOL:
         CASE a
         IN (REF CONST ec): ec :=: b
         OUT FALSE
         ESAC;
      
      OP + = (FORM a, b) FORM:
         (a = zero | b |: b = zero | a | HEAP TRIPLE := (a, plus, b));
      
      OP - = (FORM a, b) FORM:
         (b = zero | a | HEAP TRIPLE := (a, minus, b));
      
      OP * = (FORM a, b) FORM:
         (a = zero OR b = zero | zero |: a = one | b |: b = one | a | HEAP TRIPLE := (a, times, b));
      
      OP / = (FORM a, b) FORM:
         (a = zero AND NOT (b = zero) | zero |: b = one | a | HEAP TRIPLE := (a, by, b));
      
      OP ** = (FORM a, REF CONST b) FORM:
         (a = one OR (b :=: zero) | one |: b :=: one | a | HEAP TRIPLE := (a, to, b));
      
      PROC derivativeof = (FORM e, REF VAR x) FORM:
           CASE e
           IN (REF CONST): zero, (REF VAR ev): (ev :=: x | one | zero), (REF TRIPLE et): CASE FORM u = leftoperand OF et, v = rightoperand OF et;
                      
                      FORM udash = derivativeof (u, x), vdash = derivativeof (v, x);
                      
                      operator OF et
              IN udash + vdash, udash - vdash, u * vdash + udash * v, (udash - et * vdash) / v, (v | (REF CONST ec): v * u ** (HEAP CONST c;
                                                       
                                                       value OF c := value OF ec - 1;
                                                       c) * udash)
              ESAC, (REF CALL ef): BEGIN REF FUNCTION f = functionname OF ef,
                                         FORM g = parameter OF ef;
                                         
                                         REF VAR y = boundvar OF f;
                                         
                                         HEAP FUNCTION fdash := (y, derivativeof (body OF f, y));
                                         
                                         (HEAP CALL := (fdash, g)) * derivativeof (g, x)
              END
           ESAC;
      
      PROC valueof = (FORM e) REAL:
           CASE e
           IN (REF CONST ec): value OF ec, (REF VAR ev): value OF ev, (REF TRIPLE et): CASE REAL u = valueof (leftoperand OF et), v = valueof (rightoperand OF et);
                    
                    operator OF et
              IN u + v, u - v, u * v, u / v, exp (v * ln (u))
              ESAC, (REF CALL ef): BEGIN REF FUNCTION f = functionname OF ef;
                                         
                                         value OF boundvar OF f := valueof (parameter OF ef);
                                         valueof (body OF f)
              END
           ESAC;
      
      HEAP FORM f, g;
      
      HEAP VAR a := ("a", SKIP), b := ("b", SKIP), x := ("x", SKIP);
      
      value OF a := 1;
      value OF b := 1;
      value OF x := 1;
      f := a + x / (b + x);
      g := (f + one) / (f - one);
      print ((value OF a, value OF b, value OF x, valueof (derivativeof (g, x))))
END