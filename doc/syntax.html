<html>
<head>
<title>Algol 68 Genie - An Algol 68 interpreter</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: Arial,Helvetica;}
u {font-size: 10pt; font-family: Arial,Helvetica;}
dd {font-size: 10pt; font-family: Arial,Helvetica;}
h1 {font-size: 16pt; font-family: Arial,Helvetica;}
h2 {font-size: 14pt; font-family: Arial,Helvetica;}
h3 {font-size: 12pt; font-family: Arial,Helvetica;}
h4 {font-size: 10pt; font-family: Arial,Helvetica;}
td {font-size: 8pt; font-family: Arial,Helvetica;}
ul {font-size: 10pt; font-family: Arial,Helvetica;}
body {font-size: 10pt; font-family: Arial,Helvetica;}
code {font-size: 10pt; font-family: Courier;}
pre {font-size: 10pt; font-family: Courier;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>Documentation for Algol 68 Genie Mark 9.2</small>
</td>
</table>

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>Context-free syntax summary</h2>
<small>
&nbsp;&middot;&nbsp;<a href="#basic">Notions and notation</a><br>
&nbsp;&middot;&nbsp;<a href="#reserved">Reserved symbols</a><br>
&nbsp;&middot;&nbsp;<a href="#coercions">Coercions</a><br>
&nbsp;&middot;&nbsp;<a href="#tags">Tags</a><br>
&nbsp;&middot;&nbsp;<a href="#program">Particular program</a><br>
&nbsp;&middot;&nbsp;<a href="#clauses">Clauses</a><br>
&nbsp;&middot;&nbsp;<a href="#expressions">Expressions</a><br>
&nbsp;&nbsp;&middot;&nbsp;<a href="#primaries">Primaries</a><br>
&nbsp;&nbsp;&middot;&nbsp;<a href="#secondaries">Secondaries</a><br>
&nbsp;&nbsp;&middot;&nbsp;<a href="#tertiaries">Tertiaries</a><br>
&nbsp;&nbsp;&middot;&nbsp;<a href="#units">Units</a><br>
&nbsp;&middot;&nbsp;<a href="#declarations">Declarations</a><br>
&nbsp;&middot;&nbsp;<a href="#declarers">Declarers</a><br>
&nbsp;&middot;&nbsp;<a href="#formats">Formats</a><br>
&nbsp;&middot;&nbsp;<a href="#pragments">Pragments</a><br>
&nbsp;&middot;&nbsp;<a href="#refinements">Refinements</a><br>
</small>
</td>
<td width="30%" bgcolor="white" valign=top align=center>
<img src="logo.gif">
<p>
<div align=right>
</div>
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<small><b>Algol68G Mark 9.2</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="introduction.html"><small>Introduction</small></a><br>
&nbsp;&middot;&nbsp;<a href="install.html"><small>Installation</small></a><br>
&nbsp;&middot;&nbsp;<a href="description.html"><small>Description</small></a><br>
&nbsp;&middot;&nbsp;<a href="examples.html"><small>Example&nbsp;programs</small></a><br>
&nbsp;&middot;&nbsp;<a href="synopsis.html"><small>Synopsis</small></a><br>
&nbsp;&middot;&nbsp;<a href="syntax.html"><small>Syntax</small></a><br>
&nbsp;&middot;&nbsp;<a href="environ.html"><small>Environment</small></a><br>
<br>
<small><b>Extensions</b></small>
<br>
&nbsp;&middot;&nbsp;<a href="extensions.html"><small>UNIX</small></a><br>
&nbsp;&middot;&nbsp;<a href="postgresql.html"><small>PostgreSQL</small></a><br>
&nbsp;&middot;&nbsp;<a href="drawing.html"><small>Drawing</small></a><br>
&nbsp;&middot;&nbsp;<a href="numerical.html"><small>Numerical</small></a><br>
<br>
&nbsp;&middot;&nbsp;<a href="contents.html"><small>Contents</small></a><br>
&nbsp;&middot;&nbsp;<a href="resources.html"><small>A68 Resources</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#obtaining"><small>Downloads</small></a><br>
&nbsp;&middot;&nbsp;<a href="introduction.html#contact"><small>Contact</small></a>
</td>
</tr>
</table>
<!-- End navigation bar -->
</td>
</table>

<p>
This syntax summary provides a quick reference for Algol68G syntax.
<a href="environ.html">Predefined tags</a> can be found in a different chapter.
There is a separate chapter with <a href="examples.html">sample programs</a>.
<p>
The syntax described here is context-free. The advantage of presenting a context-free syntax is that the backbone of constructions can be explained quickly. The disadvantage is that a context-free grammar cannot reject programs that are semantically incorrect, for instance those that apply undeclared tags.
To accept only semantically correct programs, a two-level grammar is needed <a href="resources.html#ref">[Revised Report 1976]</a>. The full <a href="resources.html#rr">Algol 68 syntax</a> is available from on-line sources.

<h3><a name="basic"></a>Notions and notation</h3>
<p>This paragraph introduces notions and notation used in this reference text.
<p>
<table border=0 cellspacing=0 cellpadding=6>
<tr><td bgcolor="#e8e8e8"><b>Notion, notation</b></td><td bgcolor="#e8e8e8"><b>Meaning</b></td></tr>
<tr><td  bgcolor="#e8e8e8">a <i>value</i></td><td  bgcolor="#e8e8e8"> 
<li>integer number or real number
<li>truth value (<code>TRUE</code> or <code>FALSE</code>)
<li>character
<li>void value (<code>EMPTY</code>)
<li>structured value, f.i. a COMPLEX number
<li>multiple value, a <i>n</i>-dimensional row of values, f.i. a STRING value
<li>name
<li>routine
<br>
<br>
(note that there is neither a united value nor a flexible value, id est there is no value with mode UNION or FLEX) 
</td></tr>
<tr><td  bgcolor="#e8e8e8">a <i>name</i></td><td  bgcolor="#e8e8e8">a <i>name</i> is a value that refers to another value, or which can be NIL (that refers to no value)</td></tr>
<tr><td  bgcolor="#e8e8e8">( )</td><td  bgcolor="#e8e8e8">used to group notions</td></tr>
<tr><td  bgcolor="#e8e8e8">[SOME]</td><td  bgcolor="#e8e8e8">means "optional SOME"</td></tr>
<tr><td  bgcolor="#e8e8e8"><b>a</b>: b.</td><td  bgcolor="#e8e8e8">means "definition of a is b"</td></tr>
<tr><td  bgcolor="#e8e8e8">a, b</td><td  bgcolor="#e8e8e8">means "a or b"</td></tr>
<tr><td  bgcolor="#e8e8e8">`SOME'</td><td  bgcolor="#e8e8e8">means literal symbol SOME</td></tr>
<tr><td  bgcolor="#e8e8e8">SOME-list</td><td  bgcolor="#e8e8e8">SOME [`,' SOME-list]</td></tr>
<tr><td  bgcolor="#e8e8e8">SOME-sequence</td><td  bgcolor="#e8e8e8">SOME [SOME-sequence]</td></tr>
</table>

<h3><a name="reserved"></a>Reserved symbols</h3>
<p>
Next symbols are reserved in Algol 68 Genie Mark 9.2:
<p>
<code>
  ANDF,
  ANDTH,
  ASSERT,
  AT,
  BEGIN,
  BITS,
  BOOL,
  BY,
  BYTES,
  CASE,
  CHANNEL,
  CHAR,
  CO,
  CODE,
  COMMENT,
  COMPL,
  COMPLEX,
  DO,
  DOWNTO,
  EDOC,
  ELIF,
  ELSE,
  ELSF,
  EMPTY,
  END,
  ENVIRON,
  ESAC,
  EXIT,
  FALSE,
  FI,
  FILE,
  FLEX,
  FOR,
  FORMAT,
  FROM,
  GO,
  GOTO,
  HEAP,
  IF,
  IN,
  INT,
  IS,
  ISNT,
  LOC,
  LONG,
  MODE,
  NIL,
  OD,
  OF,
  OP,
  OREL,
  ORF,
  OUSE,
  OUT,
  PAR,
  PIPE,
  PR,
  PRAGMAT,
  PRIO,
  PROC,
  REAL,
  REF,
  SEMA,
  SHORT,
  SKIP,
  STRING,
  STRUCT,
  THEF,
  THEN,
  TO,
  TRUE,
  UNION,
  UNTIL,
  VOID,
  WHILE
</code>

<br>
<h3><a name="coercions"></a>Coercions</h3>
<p>The "strength" of a context determines what coercions are possible in that context. A "strong" context allows all coercions, and typically requires that the resulting mode is known a priori; for example in the case of initial values assigned in a declaration or parameters in procedure calls.
<p>
<table border=0 cellspacing=0 cellpadding=6>
<tr>
<td bgcolor="#e8e8e8"><b>Context strength</b></td>
<td bgcolor="#e8e8e8"><b>Allowed coercions</b></td>
</tr>
<tr>
<td bgcolor="#e8e8e8">soft</td>
<td bgcolor="#e8e8e8">deproceduring</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">weak</td>
<td bgcolor="#e8e8e8">dereferencing or deproceduring, yielding a name</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">meek</td>
<td bgcolor="#e8e8e8">dereferencing or deproceduring</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">firm</td>
<td bgcolor="#e8e8e8">meek, followed by uniting</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">strong</td>
<td bgcolor="#e8e8e8">firm, followed by widening, rowing or voiding</td>
</tr>
</table>

<p>
In a strong context, Algol68G implements next widenings:
<p>
<table border=0 cellspacing=0 cellpadding=6>
<tr>
<td bgcolor="#e8e8e8"><b>From</b></td></td><td bgcolor="#e8e8e8"><b>To</b></td>
</tr>
<tr>
<td bgcolor="#e8e8e8">INT</td>
<td bgcolor="#e8e8e8">REAL<br>LONG INT</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG INT</td>
<td bgcolor="#e8e8e8">LONG LONG INT<br>LONG LONG REAL</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG LONG INT</td>
<td bgcolor="#e8e8e8">LONG LONG REAL</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">REAL</td>
<td bgcolor="#e8e8e8">COMPLEX<br>LONG REAL</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG REAL</td>
<td bgcolor="#e8e8e8"> LONG LONG REAL<br>LONG COMPLEX
</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG LONG REAL</td>
<td bgcolor="#e8e8e8">LONG LONG COMPLEX</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">COMPLEX</td>
<td bgcolor="#e8e8e8">LONG COMPLEX</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG COMPLEX</td>
<td bgcolor="#e8e8e8">LONG LONG COMPLEX</td>
</tr>
</tr>
<tr>
<td bgcolor="#e8e8e8">BITS</td>
<td bgcolor="#e8e8e8">LONG BITS</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">LONG BITS</td>
<td bgcolor="#e8e8e8">LONG LONG BITS</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">BITS<br>LONG BITS<br>LONG LONG BITS</td>
<td bgcolor="#e8e8e8">[ ] BOOL</td>
</tr>
<tr>
<td bgcolor="#e8e8e8">BYTES<br>LONG BYTES</td>
<td bgcolor="#e8e8e8">[ ] CHAR</td>
</tr>
</table>

<br>
<h3> <a name="tags"></a>Tags</h3>
<h4>Declarer-identifier tags, identifier tags and label tags</h4>
<ul>
<b>declarer-identifier</b>: uppercase-letter-sequence.<br>
<ul><code>
<li>TREE
<li>NUMBER
</code></ul>
<p>
<b>identifier</b>: lowercase-letter [(lowercase letter, digit)-sequence].<br>
<ul><code>
<li>pi
<li>x mod 2pi # note that whitespace is irrelevant in identifiers #
</code></ul>
<p>
<b>label</b>: identifier.
</ul>

<h4>Operator tags</h4>
<p>
To avoid ambiguity in parsing operator tag sequences, 
operator characters are divided into <code>monads</code> and <code>nomads</code>, 
the latter group being inherently dyadic. Next rules force that for instance
1++-1 can <code>only</code> mean 1 `+' `+' `-' 2, and 1+>2 can <code>only</code> mean 1 `+>' 2.
<p>
Note that Algol 68 forbids operator tags that start with a double monad, such as `++' or `&&', though dyadic operator tags starting with a double nomad (`**', `>>', etcetera) are allowed.
<ul>
<p>
<b>monad</b>: `+', `-', `!', `?', `%', `^', `&', `~'.
<p>
<b>nomad</b>: `<', `>', `/', `=', `*'.
<p>
<b>operator</b>: monadic operator, dyadic operator.
<p>
<b>monadic operator</b>: uppercase-letter-sequence, monad[nomad][`:=', `=:'].
<ul><code>
<li>ABS, SIGN, CONJ
<li>+, +=, +==:
</code></ul>
<p>
<b>dyadic operator</b>: uppercase-letter-sequence, (monad, nomad)[nomad][`:=', `=:'].
<ul><code>
<li>ELEM, OVER, MOD
<li>*, **, **:=, **=:
</code></ul>
</ul>

<br>
<h3><a name="program"></a>Particular program</h3>
<p>A particular program is the actual application, embedded in the standard environ.
<ul>
<b>particular-program</b>: [(label `:')-sequence] enclosed-clause.<br>
<ul><code>
<li>begin: start: BEGIN print ("Hello, world!") END
</code></lu>
</ul>
</ul>

<br>
<h3><a name="clauses"></a>Clauses</h3>
<p>
Serial - and enquiry clauses describe how declarations and units ("statements") are put in sequence.
Algol 68 requires clauses to yield a value. 
As declarations yield no value, serial- and enquiry-clauses cannot end in a declaration. 
<p>
<code>EXIT</code> leaves a serial-clause, yielding the value of the preceeding unit. If the unit following 
<code>EXIT</code> would not be labeled, it could never be reached. Hence Revised Report syntax 
for the serial-clause is more elaborate than presented here to require that the unit following <code>EXIT</code> is labeled.
In a serial-clause there cannot be labeled units before declarations to prevent re-entering declarations 
once they have been executed.
<ul>
<b>serial-clause</b>: [initialiser-series `;'] labeled-unit-series.<br>
<b>labeled-unit-series</b>: [([label `:'] unit (';', `EXIT'))-sequence] unit.<br>
<b>initialiser-series</b>: (unit, declaration-list) [`;' initialiser-series]. 
<ul><code>
<li># Not a recommended style #<br>
REAL sum := 0, INT k := 0; again: sum +:= k; IF (k +:= 1) <= limit THEN again FI 
<li># Serial clause yielding BOOL value #<br>
IF INT child = fork; child > 0 THEN wait pid (child); TRUE ELSE print ("fork failed"); FALSE FI
<li># Serial clause yielding VOID #<br>
print ("give two numbers"); INT n = read int, m = read int; print (("their sum is ", m + n))
</code></ul>
</ul>
<p>
An enquiry-clause provides a value to direct the conditional-clause, integer-case-clause, united-case-clause or while-part in a loop-clause. An enquiry-clause has no labels, so you cannot for instance jump back to the enquiry-clause at <code>IF</code> 
from the serial-clause at <code>THEN</code>.
<ul>
<b>enquiry-clause</b>: [initialiser-series `;'] [(unit `;')-sequence] unit.<br>
<ul><code>
<li>
INT mid = (top + bottom) OVER 2; elem [mid] ~= sought
<li>n > 1
<li>UNION (REAL, INT) z
</code></ul>
</ul>

<p>
Enclosed clauses provide structure for a particular program.

<ul>
<b>enclosed-clause</b>: closed-clause,
                 collateral-clause,
                 parallel-clause,
                 conditional-clause,
                 integer-case-clause,
                 united-case-clause,
                 loop-clause.<br>
</ul>
</ul>

<ul>
Short-hand notations for enclosed clauses:<br> 
<ul>
<li>`(' .. `)' for `BEGIN' .. `END'<br>
<li>`(' .. `|' .. `|:' .. `|' .. `)' for `IF' .. `THEN' .. `ELIF' .. `THEN' .. `FI'<br>
<li>`(' .. `|' .. `|:' .. `|' .. `)' for `CASE' .. `IN' .. `OUSE' .. `OUT' .. `ESAC'<br>
</ul>
</ul>

<ul>
<b>closed-clause</b>: `BEGIN' serial-clause `END'.<br>
<ul><code>
<li>BEGIN REAL z = read real; sin (z) END
<li>2 * (k + 1) # Orthogonality! #
</code></ul>
</ul>

<ul>
<b>collateral-clause</b>: `BEGIN' [unit-list] `END'.<br>
<small>Collateral-clauses are mainly used as <code>displays</code> which are denotations for a row or structured value.</small>
<ul><code>
<li>COMPLEX z := (a * c - b * d, a * d + b * c)
<li>[ ] REAL origin = (0, 0, 0)
<li>print ( ("The sum is ", m + n") ) # display for [ ] SIMPLOUT  #
<li>FLEX [ ] INT k := ( ) # "vacuum" - display for an empty row #
</code></ul>
</ul>

<ul>
<b>parallel-clause</b>: `PAR' `BEGIN' unit-list `END'.<br>
<small>In a parallel-clause the elaboration of units can be synchronised using semaphores.</small>
</ul>

<ul>
<b>conditional-clause</b>: `IF' meek-boolean-enquiry-clause `THEN' serial-clause
                    [(`ELIF' meek-boolean-enquiry-clause `THEN' serial-clause)-sequence] 
                    [`ELSE' serial-clause]
                    `FI'
<ul><code>
<li>REAL max := (a > b | a | b)
<li>IF INT k = read int; k > 0 THEN OP ! = (INT n) INT: (n = 0 | 1 | n * ! (n - 1)); print (! k) FI
</code></ul>
</ul>

<ul>
<b>integer-case-clause</b>: `CASE' meek-integer-enquiry-clause `IN' unit-list 
                     [(`OUSE' meek-integer-enquiry-clause `IN' unit-list)-sequence]                    
                     [`OUT' serial-clause] 
                     `ESAC'.<br>
<ul><code>
<li>CASE k IN option (1), option (2) OUT option error ESAC
</code></ul>
</ul>

<ul>
<b>united-case-clause</b>: `CASE' meek-united-enquiry-clause `IN' specified-unit-list 
                    [(`OUSE' meek-united-enquiry-clause `IN' specified-unit-list)-sequence]                   
                    [`OUT' serial-clause] 
                    `ESAC'.<br>

<b>specified-unit</b>: `(' (formal-declarer, `VOID') [identifier] `)' `:' unit.<br>
<small>The specified mode must be acceptable <a href="resources.html#rr">{RR 2.1.3.6}</a> to the mode yielded by the enquiry-clause.</small>
<ul><code>
<li>CASE u IN (INT): print ("INT"), (REAL x): print (sin (x)) ESAC
</code></ul>
</ul>

<ul>
<b>loop-clause</b>: [`FOR' identifier]
             [`FROM' meek-integer-unit]
             [`BY' meek-integer-unit]
             [(`TO', `DOWNTO') meek-integer-unit]
             [`WHILE' meek-boolean-enquiry-clause]
             `DO' (serial-clause [`UNTIL' meek-boolean-enquiry-clause]), `UNTIL' meek-boolean-enquiry-clause `OD'.<br>
<small>`DOWNTO' and `UNTIL' are Algol68G extensions.</small>
<ul><code>
<li>FOR i TO 10 DO item [i] := 0 OD
<li>FOR i FROM 10 DOWNTO WHILE item [i] ~= sought DO print (i) OD
<li>DO print ("*") OD  # will write "*" until the end of time #
</code></ul>
</ul>

<br>
<h3><a name="expressions"></a>Expressions</h3>
<p>
Expressions are orthogonal, for instance an enclosed-clause can be an operand in a formula. The constituent constructs of expressions are primaries, secondaries, tertiaries and units.

<br>
<h3><a name="primaries"></a>Primaries</h3>
<ul>
<b>primary</b>: enclosed-clause,
         identifier,
         call,
         slice,
         cast,
         format-text,
         denotation.<br>
</ul>

<ul>
<b>call</b>: meek-primary `(' actual-parameter-list')'<br>
<b>actual-parameter</b>: [strong-unit]<br>
<small>A call invokes a procedure.</small>
<ul><code>
<li>sin (x)
<li>put (stand error, (new line, x, y, z := x + y))
<li>fun(1)(x)
</code></ul>
<small>(Algol68G extension) Partial parametrisation adds arguments to a procedure's locale - when the locale is complete the procedure is called otherwise currying takes place.</small>
<ul><code>
<li>putf (, (new line, x, y, z := x + y)) (standout)
<li>PROC (CHAR, STRING) BOOL strchr = char in string (, HEAP INT,)
</code></ul>
</ul>

<ul>
<b>slice</b>: weak-primary `[' indexer-list `]'.<br>
<b>indexer</b>: [meek-integer-unit] [`:'] [meek-integer-unit] [revised-lower-bound].<br>
<b>revised-lower-bound</b>: (`AT', `@') meek-integer-unit.<br>
<small>A slice selects an element or a sub-row from a rowed value.</small>
<ul><code>
<li>z [1 : 10, 3]
<li>z [n] [3]
<li>z [2 : ]
<li>(condition | x | y) [10,, @0]
</code></ul>
</ul>

<ul>
<b>cast</b>: (formal-declarer, `VOID') strong-enclosed-clause.<br>
<small>A cast forces a strong context in which all coercions are allowed.</small>
<ul><code>
<li>VOID (open (file, "idf", standin channel)) # Discard result of open #
<li>REF TREE (root) :=: NIL # Force comparison of a REF TREE value #
</code></ul>
</ul>

<ul>
<b>denotation</b>: integer-denotation,
         real-denotation,
         boolean-denotation,
         bits-denotation,
         character-denotation,
         row-of-character-denotation,
         VOID-denotation.<br>
</ul>

<ul>
<b>integer-denotation</b>: [`LONG'-sequence, `SHORT'-sequence] digit-sequence.<br>
<ul><code>
<li>0, SHORT 1, LONG 10000000000000
</code></ul>
</ul>

<ul>
<b>real-denotation</b>: [`LONG'-sequence, `SHORT'-sequence] digit-sequence `.' digit-sequence[`E' [`+', `-'] digit-sequence].<br>
<ul><code>
<li>1.0, 1E3, SHORT 3.1415927, LONG 3.141592653589793238462643383
</code></ul></ul>

<ul>
<b>boolean-denotation</b>: `TRUE', `FALSE'.<br>
</ul>

<ul>
<b>bits-denotation</b>: [`LONG'-sequence, `SHORT'-sequence] digit-sequence `r' bits-digit-sequence.<br>
<small>The left-hand side digit-sequence yields the radix for the number and can range from 2 to 16. Hexadecimal digits, when letters, must be lower case conform the Revised Report.</small>
<ul><code>
<li>2r1010, 8r377, LONG 16rffffffffffff
</code></ul>
</ul>

<ul>
<b>character-denotation</b>: `"' character `"'.<br>
<ul><code>
<li>"a"
<li>"""" # Since two adjacent denotations cannot occur in Algol 68, "" within "" denotes a quote #
</code></ul>
</ul>

<ul>
<b>row-of-character-denotation</b>: `"' character-sequence `"'.<br>
<ul><code>
<li>"Hello, world!"
</code></ul>
</ul>

<ul>
<b>VOID-denotation</b>: `EMPTY'.<br>
<ul><code>
<li>UNION (INT, VOID) uiv := (value available | value | EMPTY)
</code></ul>
</ul>

<ul>
<b>format-text</b>: for definition see section on <a href="#formats">formats</a>.
</ul>

<br>
<h3><a name="secondaries"></a>Secondaries</h3>

<ul>
<b>secondary</b>: primary,
           selection,
           generator.<br>
</ul>

<ul>
<b>selection</b>: identifier `OF' secondary.<br>
<small>A selection selects a field from a structured value.</small>
<ul><code>
<li>re OF z
<li>im OF (end point OF z)
</code></ul>
</ul>

<ul>
<b>generator</b>: (`HEAP', `LOC') actual-declarer.<br>
<small>A generator allocates memory for a value, and yields a name refering to allocated space.
HEAP allocates in the heap and LOC allocates in the stack.</small>
<ul><code>
<li>HEAP INT
<li>LOC [1 : 10] REAL
<li>LOC PROC (INT) INT
</code></ul>
</ul>

<br>
<h3><a name="tertiaries"></a>Tertiaries</h3>
<ul>
<b>tertiary</b>: secondary,
          nihil,
          formula.<br>
</ul>

<ul>
<b>nihil</b>: `NIL'.<br>
<small>Nihil is a name that refers to no value.</small>
</ul>

<ul>
<b>formula</b>: monadic-operator-sequence firm-secondary,
         firm-factor dyadic-operator firm-factor.<br>
<b>factor</b>: [monadic-operator-sequence] secondary, formula.<br>
<small>Formulas apply operators to operands.</small>
<ul><code>
<li>- 1
<li>- SIGN z * ARG z # means (- (SIGN z)) * (ARG z)
<li>- x ** 2 # means (- x) ** 2, not - (x ** 2) ! #
</code></ul>
</ul>

<br>
<h3><a name="units"></a>Units</h3>
<ul>
<b>unit</b>: tertiary,
      assignation,
      routine-text,
      identity-relation,
      jump,
      skip,
      assertion,
      conditional-function.<br>
</ul>

<ul>
<b>assignation</b>: soft-tertiary `:=' strong-unit.<br>
<ul><code>
<li>x := pi + phase shift
<li>z := z1 := IF in plane THEN (0, 1) ELSE (0, 0) FI
<li>(selector | x, y, z) := 1 # assigns to either x, y or z depending on selector #
</code></ul>
</ul>

<ul>
<b>identity-relation</b>: soft-tertiary (`IS', `:=:'), (`ISNT', `:/=:') soft-tertiary.<br>
<small>An identity-relation tests equality of two names.</small>
<ul><code>
<li>REF TREE (root) IS NIL, REF TREE (root) :=: NIL
<li>name 1 :/=: name 2
</code></ul>
</ul>

<ul>
<b>jump</b>: [`GOTO'] label.<br>
<ul><code>
<li>on file end (standin, PROC (REF FILE f) VOID: stop)<br>
# Pitfall - failure to write the jump as a routine-text here will jump immediately! #
</code></ul>
</ul>

<ul>
<b>skip</b>: `SKIP'.<br>
<small>Skip has no action but yield an undefined value of the required mode.</small>
</ul>

<a name="assertions"></a>
<ul>
<b>assertion</b>: `ASSERT' meek-boolean-enclosed-clause.<br>
<small>(Algol68G extension) Assertions can be used as invariants or debugging statements.</small>
<ul><code>
<li>ASSERT (n /= 0 AND m > n)
</code></ul>
</ul>

<ul>
<b>conditional-function</b>: meek-boolean-tertiary (`ANDF', `ANDTH', `ORF', `OREL') meek-boolean-tertiary.<br>
<small>(Algol68G extension) A conditional function does not evaluate its second operand if the result can be deduced after evaluating the first.</small>
<ul><code>
<li>(z ISNT NIL) ANDF freq OF z > 0 # avoid dereferencing NIL #  
</code></ul>
</ul>

<ul>
<b>routine-text</b>: [`(' (formal-declarer identifier)-list `)'] formal-declarer `:' strong-unit.<br>
<small>A routine-text is a procedure body. It can be considered as a "procedure-denotation" or an "anonymous procedure".</small>
<ul><code>
<li>REF STRING: HEAP STRING := "xyzzy"
<li>(REAL x) REAL: sin (2 * z)
<li>(INT k) INT: (k > 0 | k | -k)
</code></ul>
</ul>

<br>
<h3><a name="declarations"></a>Declarations</h3>
<p>
Declarations introduce definitions of tags. Algol 68 does not require that a tag is defined before it is used (although Algol 68 does require that a tag is assigned a value before it is used). Hence there is no need for forward declarations when defining mutually recursive procedures, or recursive modes.
<ul>
<b>declaration</b>: mode-declaration,
             identity-declaration,
             variable-declaration,
             procedure-declaration,
             procedure-variable-declaration,
             operator-declaration,
             priority-decalaration.<br>
</ul>

<ul>
<b>mode-declaration</b>: `MODE' (declarer-identifier `=' actual-declarer)-list.<br>
<small>A mode-declaration introduces a new mode. Modes must not be declared in a cyclic way and must give objects that (1) are of finite size, and (2) require a finite number of coercions.
</small>
<ul><code>
<li>MODE TREE = STRUCT (INFO info, NODE smaller, larger), INFO = STRING, NODE = REF TREE
</code></ul>
</ul>

<ul>
<b>identity-declaration</b>: formal-declarer (identifier `=' strong-unit)-list.<br>
<small>An identity-relation binds values to identifiers. The identifier becomes a synonym for the value, further assignation is not possible.</small>
<ul><code>
<li>INT number = 1000, [ ] INT first primes = (1, 3, 5, 7, 11)
</code></ul>
</ul>

<ul>
<b>variable-declaration</b>: [`HEAP', `LOC'] actual-declarer (identifier `:=' strong-unit)-list.<br>
<small>A variable-declaration binds an identifier to space allocated for a value. The initial value can be assigned in the declaration. HEAP variables go to the heap, LOC variables go into the stack.</small>
<ul><code>
<li>REAL sum := 0, max := - max real
<li>HEAP INT k := read int, LOC BOOL z := k = 1
</code></ul>
</ul>

<ul>
<b>procedure-declaration</b>: `PROC' (identifier `=' routine-text)-list.<br>
<small>A procedure-declaration binds a routine-text to an identifier. Further assignation of another routine-text is not possible.</small>
<ul><code>
<li>PROC inc = (INT n) INT: n + 1
</code></ul>
</ul>

<ul>
<b>procedure-variable-declaration</b>: [`HEAP', `LOC'] `PROC' (identifier `:='  routine-text)-list.<br>
<small>A procedure-variable-declaration binds an identifier to space allocated for a routine-text. The initial routine-text must be assigned in the declaration. HEAP variables go to the heap, LOC variables go into the stack.</small>
<ul><code>
<li>LOC PROC inc := (INT n) INT: n + 1
</code></ul>
</ul>

<ul>
<b>operator-declaration</b>: 
`OP' (operator `=' routine-text)-list, `OP' [`(' formal-declarer-list `)' (formal-declarer, `VOID')] (operator `=' strong-unit)-list.<br>
<small>An operator-declaration introduces new operators.</small>
<ul><code>
<li>OP F = (INT i) INT: (i > 0 | i * F (i - 1) | 1) 
<li>OP (REAL) REAL SQRT = sqrt, LN = ln, TAN = tan
</code></ul>
</ul>

<ul>
<b>priority-declaration</b>: `PRIO' (operator `=' digit)-list.<br>
<small>A priority-declaration introduces a priority for operators.</small>
<ul><code>
<li>PRIO + = 6, * = 7, / = 7
</code></ul>
</ul>

<br>
<h3><a name="declarers"></a>Declarers</h3>
<p>
Declarers describe modes. The context determines whether a mode must be formal, 
virtual, or actual. 
Formal- or virtual-declarers are needed where the size of rows is irrelevant. Actual declarers are needed where the size of rows must be known, for instance when allocating memory for rows.
<p>
Algol 68 employs structural equivalence for modes. Note that field identifiers in structured values are part of the mode, but bounds of a row are not (these are part of the value). For example: 
<ul>
<ul><code>
<li>MODE PERPLEX = [1 : 2] STRUCT (REAL re, im) </code>introduces a mode equivalent to <code><br>
<li>[1 : 3] COMPL # COMPL is a primitive mode, defined as STRUCT (REAL re, im) #
</code></ul>
</ul>

<ul>
<b>victal</b>: virtual, actual, formal.<br>
</ul>

<ul>
<b>victal-declarer</b>: (`LONG'-sequence, `SHORT'-sequence) primitive-declarer,
                 declarer-identifier,
                 `REF' virtual-declarer,
                 `[' victal-bounds-list `]' victal-declarer,
                 `FLEX' `[' victal-bounds-list `]' victal-declarer,
                 `STRUCT' `(' (victal-declarer identifier)-list `)',
                 `UNION' `(' (formal-declarer, `VOID')-list `)',
                 `PROC' [`(' formal-declarer-list `)'] (formal-declarer, `VOID').<br>
<ul><code>
<li>LONG LONG COMPLEX
<li>MODE ROW = [1 : n] STRUCT (INT re, im)
<li>REF [,, ] INT
<li>STRUCT (UNION (FORM, RULE, VOID) value, UNION (PROC (FORM) RULE, VOID) action)
<li>PROC (INT, STRING) REF FLEX [ ] STRING
</code></ul>
</ul>

<ul>
<b>primitive-declarer</b>: `INT', `REAL', `COMPL', `COMPLEX', `BOOL', `CHAR', `STRING', `BITS', `BYTES', `FORMAT', `FILE', `PIPE', `CHANNEL', `SEMA'.<br>
<small>Primitive-declarers are the standard provided modes.</small>
</ul>
 
<ul>
<b>actual-bounds</b>:  [meek-integer-unit `:'] meek-integer-unit. # default lower bound is 1 #<br>
<b>formal-bounds</b>, <b>virtual-bounds</b>:  [`:'].<br>
<small>Bounds provide the size per dimension of a row, where needed.</small>
<br>
</ul>

<br>
<h3><a name="formats"></a>Formats</h3>
<p>Formats describe the lay-out for transputting data. Formats are values so you can have format-variables,
procedures yielding formats etcetera. A format-text can be considered as a (dynamic) "format-denotation".
<ul>
<ul>
<li><code>printf (($2l"The sum is:"x, g(0)$, m + n))</code> prints the same as
<li><code>print ((new line, new line, "The sum is:", space, whole (m + n, 0))</code>
</ul>
</ul>

<ul>
<b>format-text</b>: `$' picture-list `$'.<br>
</ul>

<ul>
<b>picture</b>: insertion, pattern, collection, replicator collection.<br>
</ul>

<ul>
<b>replicator</b>: integer-denotation, `n' meek-integer-enclosed-clause.<br>
<ul><code>
<li>9
<li>n (um | (INT): int width, (REAL): real width)
</code></ul>
</ul>

<ul>
<b>collection</b>: `(' picture-list `)'.<br>
</ul>

<ul>
<b>insertion</b>: (replicator `k', [replicator] `l', [replicator] `p', [replicator] `x',  [replicator] `q', [replicator] row-of-character-denotation)-sequence.<br>
<ul><code>
<li>3p              # 3 calls to newpage #
<li>l               # calls newline #
<li>x, q            # calls space #
<li>n (10 * j) k    # advances to position 10 * j in the current line #
<li>"The result is" # literal text #
<li>l3x"$"          # transputs new line, 3 spaces, and a dollar-sign #
</code></ul>
</ul>

<ul>
<b>pattern</b>: general-pattern, integer-pattern, real-pattern, complex-pattern, bits-pattern, string-pattern, boolean-pattern, choice-pattern, format-pattern.<br>
</ul>

<ul>
<b>general-pattern</b>: `g'[strong-row-of-integer-enclosed-clause].<br>
<ul><code>
<li>g # applies default format as used by read and print #
<li>g (0) # calls "whole" #
<li>g (12, 8) # calls "fixed" #
<li>g (-12, 3, 2) # calls "float" #
</code></ul>
</ul>

<ul>
<b>integer-pattern</b>: [sign-mould] integer-mould.<br>
<ul><code>
<li>4d          # transputs 9 as "0009", error on negative number since there is no sign-mould #
<li>zzz-d, 3z-d # transputs -9 as "   -9" #
<li>3z","2z-d   # transputs 100000 as " 100,000" #
</code></ul>
<b>sign-mould</b>: [replicator] [`s'] (`z', `d') [([replicator] [`s'] (`z', `d'), insertion)-sequence] (`+', `-').<br>
<ul><code>
<li>+, -
<li>zzz+, 3z+
</code></ul>
<b>integer-mould</b>: [replicator] [`s'] (`z', `d') [([replicator] [`s'] (`z', `d'), insertion)-sequence].
<ul><code>
<li>4d, dddd, zzzd
<li>3d"-"3d"-"4d   # transputs 5551234567 as 555-123-4567 #
</code></ul>
</ul>

<ul>
<b>real-pattern</b>: [sign-mould] [`s'] `.' [insertion] integer-mould [[`s']`e' [insertion] [sign-mould] integer-mould].
<ul><code>
<li>d.3d             # transputs pi as "3.142" #
<li>d.3dez-d         # transputs 0.3333 as "3.333e -1" #
<li>ds.","3dse"^"z-d # transputs 0.3333 as "3,333^ -1" #
</code></ul>
</ul>

<ul>
<b>complex-pattern</b>: real-pattern [`s']`i' [insertion] real-pattern.
<ul><code>
<li>-d.3di-d.3d # transputs f.i. 0.000i-1.000 #
<li>-d.3dsi-d.3d, "j" # transputs f.i. 0.000-1.000j #
</code></ul>
</ul>

<ul>
<b>bits-pattern</b>: replicator `r' integer-mould.<br>
<small>The replicator yields the radix for the number and can range from 2 to 16.</small>
<ul><code>
<li>2r7zd # binary 8-bit byte with trailing zero-bit suppression #
<li>16r8d # hexadecimal 32 bit without trailing zero-digit suppression #
</code></ul>
</ul>

<ul>
<b>string-pattern</b>: [replicator] [`s'] `a' [([replicator] [`s'] `a', insertion)-sequence].<br>
<ul><code>
<li>printf ($7a$, "Algol68") # prints "Algol68" #
<li>printf ($5a"-"2a, "Algol68") # prints "Algol-68" #
<li>printf ($5a2sa, "Algol68") # prints "Algol" #
</code></ul>
</ul>

<ul>
<b>boolean-pattern</b>: `b' `(' row-character-denotation `,' row-character-denotation `)'.<br>
<ul><code>
<li>printf ($b ("true", "not true")$, read bool)
</code></ul>
</ul>

<ul>
<b>choice-pattern</b>: `c' `(' row-character-denotation-list `)'.<br>
<ul><code>
<li>printf ($c ("one", "two", "three")$, read int)
</code></ul>
</ul>

<ul>
<b>format-pattern</b>: `f' meek-format-enclosed-clause.<br>
<ul><code>
<li>f (um | (INT): $g(0)$, (REAL): $g(0, 4)$)
</code></ul>
</ul>

<br>
<h3><a name="pragments"></a>Pragments</h3>
<p>
Pragments are either pragmats or comments. 
Pragmats contain preprocessor directives, or set options from within an Algol 68 program.
<ul>
<b>pragment</b>: pragmat, comment.<br>
<b>pragmat</b>: pragmat-symbol, pragmat-item-sequence, pragmat-symbol.<br>
<b>pragmat-symbol</b>: `PR', `PRAGMAT'.
<ul><code>
<li>PR heap=32M PR
</ul></code>
<b>comment</b>: comment-symbol, character-sequence, comment-symbol.<br>
<b>comment-symbol</b>: `#', `CO', `COMMENT'.
<ul><code>
<li>COMMENT do not use for n > 100 COMMENT
</ul></code>
</ul>

<br>
<h3><a name="refinements"></a>Refinements</h3>
<p>
The <a href="extensions.html#refine">refinement preprocessor</a> is a low-level tool for top-down programming. It is not really a part of Algol68G syntax, but superimposed on top of it. Note that refinements interfere somewhat with labels.
<ul>
<b>refined program</b>: paragraph `.', refinement definition sequence. <br>
<ul><code>
<li>(read and add). read and add: INT m = read int, n = read int; INT sum := m + n. 
</code></ul>
<b>refinement definition</b>: identifier `:'  paragraph `.'.
<ul><code>
<li>read and add: INT m = read int, n = read int; INT sum := m + n. 
</code></ul>
<b>paragraph</b>: # Algol 68 program text without `.' except when in string - or real denotations #.
<ul><code>
<li>INT m = read int, n = read int; INT sum := m + n
</code></ul>
</ul>

<p>
<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<font color="black">
<small>Copyright &copy; 2001-2006 J. Marcel van der Veer.</small>
</font>
</td>
<td width="50%" align=right valign=top bgcolor="white">
<font color="black">
<small>Documentation for Algol 68 Genie Mark 9.2 (July 2006)</small>
</font>
</td>
</table>
</p>

</body>
</html>
