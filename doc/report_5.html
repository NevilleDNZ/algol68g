<!-- RRHeader -->
<html>
<head>
<title>Revised Report on the Algorithmic Language Algol 68 - Algol 68 Genie</title>
<meta name="Keywords" content="algol,algol68,68,algol-68,algol68g,algol68-g,a68g,a68-g,68g,genie,interpreter">
<meta http-equiv="Content-Style-Type" content="text/css"; charset=ISO-8859-1">
<style type="text/css">
a:link    {color: blue; text-decoration: underline;}
a:visited {color: blue; text-decoration: underline;}
a:active  {color: blue; text-decoration: underline;}
p {font-size: 10pt; font-family: arial, sans-serif;}
u {font-size: 10pt; font-family: arial, sans-serif;}
dd {font-size: 10pt; font-family: arial, sans-serif;}
h1 {font-size: 14pt; font-family: arial, sans-serif;}
h2 {font-size: 12pt; font-family: arial, sans-serif;}
h3 {font-size: 10pt; font-family: arial, sans-serif;}
h4 {font-size: 10pt; font-family: arial, sans-serif;}
td {font-size: 10pt; font-family: arial, sans-serif;}
ul {font-size: 10pt; font-family: arial, sans-serif;}
body {font-size: 10pt; font-family: arial, sans-serif;}
tt {font-size: 10pt; font-family: "courier new", monospace;}
code {font-size: 10pt; font-family: "courier new", monospace;}
var {font-size: 10pt; font-weight: normal; font-style: normal; font-family: "courier new", monospace; color: darkred;}
pre {font-size: 10pt; font-family: "courier new", monospace;}
</style>
</head>

<body bgcolor="white">

<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="100%" background="lines.gif">
<img src="lines.gif" align=right>
<small>
<b>Revised Report on the Algorithmic Language Algol 68</b>
</small>
</td>
</table>


<table width="100%" border=0 cellspacing=0 cellpadding=0>
<td width="50%" valign=top bgcolor="white">
<br>
<h2>
Algol 68 Revised Report
</h2>
<h3>
PART V - Environment and Examples
</h3>
</td>
<td width="30%" bgcolor="white" valign=top align=center>
<img src="algol68.gif" align=center>
</td>
<td width="5%" valign=top bgcolor="white">
</td>
<td width="15%" valign=top bgcolor="white">
<!-- Navigation bar -->
<table border="0" cellspacing="0" width="100%">
<tr>
<td background="lines.gif">
<p>
<a href="algol.html"><small><b>A68G Home</b></small></a>
<p>
<a href="report_contents.html"><small><b>Revised Report</b></small></a>
<p>
<a href="algol.html#obtaining"><small><b>Downloads</b></small></a>
</td>
</tr>
</table>
<!-- End navigation bar -->
</td>
</table>  

<h3>
10. Standard environment  
</h3>

<p>
{The "standard environment" encompasses the constituent <b>EXTERNAL-preludes</b>, <b>system-tasks</b> and <b>particular-postludes</b> of a <b>program-text</b>.}  

<h3>
<a name=A1></a>10.1. Program texts
</h3>

<p>
{The programmer is concerned with <b>particular-programs</b> {<a href="#A11g">10.1.1.g</a>}. These are always included in a <b>program-text</b> {<a href="#A11a">10.1.1.a</a>} which also contains the <b>standard-prelude</b>, a <b>library-prelude</b>, which depends upon the implementation, a <b>system-prelude</b> and <b>system-tasks</b>, which correspond to the operating environment, possibly some other <b>particular-programs</b>, one or more <b>particular-preludes</b>  (one for each <b>particular-program</b>) and one or more <b>particular-postludes</b>.}  

<h3>
<a name=A11></a>10.1.1. Syntax
</h3>

<p>
<a name=A11A></a>A) <b>EXTERNAL ::  standard ; library ; system ; particular.</b> 
<br>
<a name=A11B></a>B) <b>STOP :: label letter s letter t letter o letter p.</b> 
<br>
<a name=A11a></a>a) <b>program text : STYLE begin</b> {<a href="report_4.html#941f">94f, -</a>}  <b>token, new LAYER1 preludes</b> {b}<b>, parallel</b> {<a href="report_4.html#941f">94f</a>}  <b>token, new LAYER1 tasks</b> {d}<b> PACK, STYLE end</b> {<a href="report_4.html#941f">94f, -</a>}  <b>token.</b> 
<br>
<a name=A11b></a>b) <b>NEST1 preludes {a} : NEST1 standard prelude with DECS1</b> {c}<b>, NEST1 library prelude with DECSETY2</b> {c}<b>, NEST1 system prelude with DECSETY3</b> {c}<b>, where (NEST1) is (new EMPTY new DECS1 DECSETY2  DECSETY3) .</b> 
<br>
<a name=A11c></a>c) <b>NEST1 EXTERNAL prelude with DECSETY</b> {b,f}<b> :  strong void NEST1 series with DECSETY1 </b> {<a href="report_2.html#321b">32b</a>}  <b>, go on</b> {<a href="report_4.html#941f">94f</a>}  <b>token where (DECSETY1) is (EMPTY) , EMPTY.</b> 
<br>
<a name=A11d></a>d) <b>NEST1 tasks {a} : NEST1 system task</b> {e}<b> list, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST1 user task</b> {f}<b> PACK list.</b> 
<br>
<a name=A11e></a>e) <b>NEST1 system task</b> {d}<b> : strong void NEST1  unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b> 
<br>
<a name=A11f></a>f) <b>NEST1 user task</b> {d}<b> : NEST2 particular prelude with DECS</b> {c}<b>, NEST2 particular program</b> {g}<b> PACK, go on</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST2 particular prelude</b> {i}<b>, where (NEST2) is (NEST1 new DECS STOP) .</b> 
<br>
<a name=A11g></a>g) <b>NEST2 particular program</b> {f}<b> : NEST2 new LABSETY3 joined label definition of LABSETY3</b> {h}<b>, strong void NEST2 new LABSETY3 ENCLOSED clause</b> {<a href="report_2.html#311a">31a</a> ,<a href="report_2.html#331a">33a,c</a>,<a href="report_2.html#341a">34a</a>,<a href="report_2.html#351a">35a</a>}  <b>.</b> 
<br>
<a name=A11h></a>h) <b>NEST joined label definition of LABSETY</b> {g,h}<b> :  where (LABSETY) is (EMPTY) , EMPTY; where (LABSETY) is (LAB1 LABSETY1) , NEST label definition of LAB1</b> {<a href="report_2.html#321c">32c</a>}  <b>, NEST joined label definition of LABSETY1</b> {h}<b>.</b> 
<br>
<a name=A11i></a>i) <b>NEST2 particular postlude</b> {f}<b> : strong void NEST2 series with STOP</b> {<a href="report_2.html#321b">32b</a>}  <b>.</b> 

<p>
<pre>
{Examples:  
a) (&cent; standard-prelude &cent;; &cent; library-prelude &cent;; &cent; system-prelude &cent;;
      PAR BEGIN &cent; system-task-1 &cent;, &cent; system-task-2 &cent;,
         (&cent; particular-prelude &cent;;
            (start: commence: BEGIN SKIP END);
            &cent; particular-postlude &cent;) ,
         (&cent; another user-task &cent;) 
      END) 
b) &cent; standard-prelude (<a href="#A2">10.2</a>, <a href="#A3">10.3</a>) &cent;; &cent; library-prelude &cent;;
      &cent; system-prelude (<a href="#A41">10.4.1</a>) &cent;;
d) &cent; system-task-1 (<a href="#A42a">10.4.2.a</a>) &cent;, &cent; system-task-2 &cent;,
      (&cent; particular-prelude &cent;;
         (start: commence: BEGIN SKIP END);
         &cent; particular-postlude &cent;) ,
      (&cent; another user-task &cent;)       
f) &cent; particular-prelude (<a href="#A51">10.5.1</a>) &cent;;
      (start: commence: BEGIN SKIP END); 
      &cent; particular-postlude (<a href="#A52">10.5.2</a>) &cent;      
g) start: commence: BEGIN SKIP END      
h) start: commence:
i) stop: lock (stand in); lock (stand out); lock (stand back) }
</pre>

<h3>
<a name=A12></a>10.1.2. The environment condition
</h3>

<p>
<a name=A12a></a>a) A <b>program</b> in the strict language must be akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to some <b>program-text</b> whose constituent <b>EXTERNAL-preludes</b> and <b>particular-postludes</b> are as specified in the remainder of this section.  {It is convenient to speak of the <b>standard-prelude</b>, the <b>library-prelude</b>, the <b>particular-programs</b>, etc. of a <b>program</b>  when discussing those parts of that <b>program</b> which correspond to the constituent <b>standard-prelude</b>, etc. of the corresponding <b>program-text</b>.}  

<p>
<a name=A12b></a>b) The constituent <b>standard-prelude</b> of all <b>program-texts</b> is that <b>standard-prelude</b> whose representation is obtained {<a href="#A13">10.1.3</a>}  from the forms given in sections <a href="#A2">10.2</a> and <a href="#A3">10.3</a>.  

<p>
<a name=A12c></a>c) The constituent <b>library-prelude</b> of a <b>program-text</b> is not specified in this Report {but must be specified for each implementation; the syntax of <b>'program text'</b> ensures that a <b>declaration</b> contained in a <b>library-prelude</b> may not contradict any <b>declaration</b> contained in the <b>standard-prelude</b>} .  

<p>
<a name=A12d></a>d) The constituent <b>system-prelude</b>  (<b>system-task-list</b>) of all <b>program-texts</b> is that <b>system-prelude</b> (<b>system-task-list</b>) whose representation is obtained from the forms given in section <a href="#A4">10.4</a> , with the possible addition of other forms not specified in this Report {but to be specified to suit the operating environment of each implementation} .  

<p>
<a name=A12e></a>e) Each constituent <b>particular-prelude</b>  (<b>particular-postlude</b>) of all <b>program-texts</b> is that <b>particular-prelude</b> (<b>particular-postlude</b>) whose representation is obtained from the forms given in section <a href="#A5">10.5</a> , with the possible addition of other forms not specified in this Report {but to be specified for each implementation}.  

<h3>
<a name=A13></a>10.1.3. The method of description of the standard environment
</h3>
  
<p>
A representation of an <b>EXTERNAL-prelude</b>, <b>system-task</b> or <b>particular-postlude</b> is obtained by altering each form in the relevant sections of this chapter in the following steps:  

<p>
<a name=A13s1></a>Step 1: If a given form <i>F</i> begins with <tt>OP</tt> {the <b>operator-symbol</b>} followed by one of the marks <tt><b>P</b></tt>, <tt><b>Q</b></tt>,  <tt><b>R</b></tt> or <tt><b>E</b></tt>, then <i>F</i> is replaced by a number of new forms each of which is a copy of <i>F</i> in which that mark {following the <tt>OP</tt>} is (all other occurrences in <i>F</i> of that mark are) replaced, in each respective new form, by:  

<dl>
<dd>
<a name=A13cA></a>Case A: The mark is <tt><b>P</b></tt>:  
<br>
&bull; <tt>-</tt>, <tt>+</tt>, <tt>&laquo;&times;, *&raquo;</tt> or <tt>/</tt> (<tt>-</tt>,  <tt>+</tt>, <tt>*</tt> or <tt>/</tt>); 

<dd>
<a name=A13cB></a>Case B: The mark is <tt><b>Q</b></tt>:  
<br>
&bull; <tt>&laquo;MINUSAB, -:=&raquo; , &laquo;PLUSAB, +:=&raquo;, &laquo;TIMESAB, &times;:=, *:=&raquo;</tt> or <tt>&laquo;DIVAB, /:=&raquo;</tt> (<tt>-:= , +:= , *:=</tt> or <tt>/:=</tt>); 
<dd>
<a name=A13cC></a>Case C: The mark is <tt><b>R</b></tt>:  
<br>
&bull; <tt>&laquo;&lt;, LT&raquo;</tt> , <tt>&laquo;&le;, LE&raquo;</tt> , <tt>&laquo;=, EQ&raquo;</tt>,  <tt>&laquo;&ne;, /=, NE&raquo;</tt> , <tt>&laquo;&ge;, GE&raquo;</tt> or <tt>&laquo;&gt;, GT&raquo;</tt>  (<tt>&lt;</tt>, <tt>&le;</tt>, =, <tt>&ne;</tt>, <tt>&ge;</tt> or <tt>&gt;</tt>); 
<dd>
<a name=A13cD></a>Case D: The mark is <tt><b>E</b></tt>:  
<br>
&bull; <tt>&laquo;=, EQ&raquo;</tt> or <tt>&laquo;&ne;, /=, NE&raquo;</tt> (= or <tt>&ne;</tt>); 
</dl>

<p>
<a name=A13s2></a>Step 2: If, in some form, as possibly made in the step above, <tt>?</tt>  occurs followed by an <b>INDICATOR</b> (a <b>field-selector</b>) <i>I</i>, then that occurrence of <tt>?</tt> is deleted and each <b>INDICATOR</b> (<b>field-selector</b>) akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to <i>I</i> contained in any form is replaced by a copy of one same <b>INDICATOR</b> (<b>field-selector</b>) which does not occur elsewhere in the <b>program</b> and Step 2 is taken again;  

<p>
<a name=A13s3></a>Step 3: If a given form <i>F</i>, as possibly modified or made in the steps above, begins with <tt>OP</tt> {the <b>operator-symbol</b>} followed by a chain of <b>TAO-symbols</b> separated by <b>and-also-symbols</b>, the chain being enclosed between &laquo; and &raquo;, then <i>F</i> is replaced by a number of different  "versions" of that form each of which is a copy of <i>F</i> in which that chain, together with its enclosing &laquo; and &raquo;, has been replaced by one of those <b>TAO-symbols</b> {; however, an implementation is not obliged to provide more than one such version {<a href="report_4.html#94b">9.4.b</a>}  } ;  

<p>
<a name=A13s4></a>Step 4: If, in a given form, as possibly modified or made in the steps above, there occurs a sequence <i>S</i> of <b>symbols</b> enclosed between &laquo; and  &raquo; and if, in that <i>S</i>, <tt><b><i>L</i></b> INT</tt>, <tt><b><i>L</i></b>  REAL</tt>, <tt><b><i>L</i></b> COMPL</tt>, <tt><b><i>L</i></b> BITS</tt> or <tt><b><i>L</i></b> BYTES</tt> occurs, then <i>S</i> is replaced by a chain of a sufficient number of sequences separated by <b>and-also-symbols</b>, the <i>n</i>-th of which is a copy of <i>S</i> in which copy each occurrence of <tt><i>L</i></tt> (<tt><i>L</i></tt>, <tt> <b>K</b></tt>, <tt> <b>S</b></tt>)  is replaced by (n - 1) times <tt>long</tt> (<tt>LONG</tt>, <tt>LENG</tt>,  <tt>SHORTEN</tt>) , followed by an <b>and-also-symbol</b> and a further chain of a sufficient number of sequences separated by <b>and-also-symbols</b>, the <i>m</i>-th of which is a copy of <i>S</i> in which copy each occurrence of <tt><i>L</i></tt> (<tt><i>L</i></tt>, <tt> <b>K</b></tt>, <tt> <b>S</b></tt>) has been replaced by <i>m</i> times <tt>short</tt> (<tt>SHORT</tt>, <tt>SHORTEN</tt>, <tt>LENG</tt>);  the &laquo; and &raquo; enclosing that <i>S</i> are then deleted;  

<p>
<a name=A13s5></a>Step 5: If, in a given form <i>F</i>, as possibly modified or made in the steps above, <tt><b><i>L</i></b> INT</tt>, (<tt><b><i>L</i></b>  REAL</tt>, <tt><b><i>L</i></b> COMPL</tt>, <tt><i>L</i>  BITS</tt>, <tt><b><i>L</i></b> BYTES</tt>) occurs, then <i>F</i> is replaced by a sequence of a sufficient number of new forms, the <i>n</i>-th of which is a copy of <i>F</i> in which copy each occurrence of <tt><i>L</i></tt> (<tt><i>L</i></tt>,  <tt> <b>K</b></tt>, <tt> <b>S</b></tt>) is replaced by (n - 1) times <tt>long</tt>  (<tt>LONG</tt>, <tt>LENG</tt>, <tt>SHORTEN</tt>) , and each occurrence of <tt>long <i>L</i></tt> (<tt>LONG <i>L</i></tt>) by <i>n</i> times <tt>long</tt>  (<tt>LONG</tt>) , followed by a further sequence of a sufficient number of new forms, the <i>m</i>-th of which is a copy of <i>F</i> in which copy each occurrence of <tt><i>L</i></tt> (<tt><i>L</i></tt>, <tt> <b>K</b></tt>, <tt> <b>S</b></tt>) is replaced by <i>m</i> times <tt>short</tt> (<tt>SHORT</tt>, <tt>SHORTEN</tt>,  <tt>LENG</tt>) , and each occurrence of <tt>LONG <i>L</i></tt> (<tt>long <i>L</i></tt>) by (m - 1) times <tt>SHORT</tt> (<tt>short</tt>);  

<p>
<a name=A13s6></a>Step 6: Each occurrence of <tt><b>F</b></tt> (<tt>PRIM</tt>) in any form, as possibly modified or made in the steps above, is replaced by a representation of a <b>letter-aleph-symbol</b> (<b>primal-symbol</b>) {<a href="report_4.html#94a">9.4.a</a>};   

<p>
<a name=A13s7></a>Step 7: If a sequence of representations beginning with and ending with <b>C</b> occurs in any form, as possibly modified or made in the steps above, then this sequence, which is termed a "pseudo-comment", is replaced by a representation of a <b>declarer</b> or <b>closed-clause</b> suggested by the sequence;  

<p>
<a name=A13s8></a>Step 8: If, in any form, as possibly modified or made in the steps above, a <b>routine-text</b> occurs whose calling involves the manipulation of real numbers, then this <b>routine-text</b> may be replaced by any other <b>routine-text</b> whose calling has approximately the same effect {; the degree of approximation is left undefined in this Report (see also <a href="report_1.html#2131e">2.1.3.1.e</a>) };  

<p>
<a name=A13s9></a>Step 9: In the case of an <b>EXTERNAL-prelude</b>, a form consisting of a <b>skip-symbol</b> followed by a <b>go-on-symbol</b> {<tt>SKIP;</tt>} is added at the end. 
<p>
{The term "sufficient number", as used in Steps 4 and 5 above, implies that no intended <b>particular-program</b> should have a different meaning or fail to be produced by the syntax solely on account of an insufficiency of that number.}  

<p>
Wherever {in the transput declarations} the representation <tt><sub>10</sub></tt> (<tt>\</tt>, <tt>I</tt>) occurs within a <b>character-denotation</b> or <b>string-denotation</b>, it is to be interpreted as the representation of the <b>string-item</b> {<a href="report_4.html#8141b">8.1.4.1.b</a>} used to indicate "times ten to the power" (an alternative form {, if any,} of  "times ten to the power", "plus i times") on external media. {Clearly, these representations have been chosen because of their similarity to those of the <b>times-ten-to-the-power-symbol</b> {<a href="report_4.html#941b">9.4.1.b</a>}  and the <b>plus-i-times-symbol</b> {<a href="report_4.html#941c">9.4.1.c</a>}, but, on media on which these characters are not available, other <b>string-items</b> must be chosen (and the <b>letter-e-symbol</b> and the <b>letter-i-symbol</b> are obvious candidates) .}  

<p>
{The declarations in this chapter are intended to describe their effect clearly. The effect may very well be obtained by a more efficient method.}   

<h3>
<a name=A2></a>10.2. The standard prelude
</h3>

<p>
{The <b>declarations</b> of the <b>standard-prelude</b> comprise "environment enquiries", which supply information concerning a specific property of the implementation {<a href="report_1.html#222c">2.2.2.c</a>}, "standard modes", "standard operators and functions", "synchronization operations" and "transput declarations" (which are given in section <a href="#A3">10.3</a>) .}  

<h3>
<a name=A21></a>10.2.1. Environment enquiries
</h3>

<a name=A21a></a>
<pre>
a) INT int lengths = <b>C</b> 1 plus the number of extra lengths of integers {<a href="report_1.html#2131d">2.1.3.1.d</a>} <b>C</b>; 
<a name=A21b></a>
b) INT int shorths = <b>C</b> 1 plus the number of extra shorths of integers {<a href="report_1.html#2131d">2.1.3.1.d</a>} <b>C</b>; 
<a name=A21c></a>
c) <b><i>L</i></b> INT <i>L</i> max int = <b>C</b> the largest <i>L</i> integral value {<a href="report_1.html#222b">2.2.2.b</a>}  <b>C</b>; 
<a name=A21d></a>
d) INT real lengths = <b>C</b> 1 plus the number of extra lengths of real numbers {<a href="report_1.html#2131d">2.1.3.1.d</a>}  <b>C</b>; 
<a name=A21e></a>
e) INT real shorths = <b>C</b> 1 plus the number of extra shorths of real numbers {<a href="report_1.html#2131d">2.1.3.1.d</a>}  <b>C</b>; 
<a name=A21f></a>
f) <b><i>L</i></b> REAL <i>L</i> max real = <b>C</b> the largest <i>L</i> real value {<a href="report_1.html#222b">2.2.2.b</a>}  <b>C</b>; 
<a name=A21g></a>
g) <b><i>L</i></b> REAL <i>L</i> small real = <b>C</b> the smallest <i>L</i> real value such that both <b><i>L</i></b> 1 +  small real &gt; <b><i>L</i></b> 1 and <b><i>L</i></b> 1 -  small real &lt; <b><i>L</i></b> 1 {<a href="report_1.html#222b">2.2.2.b</a>} <b>C</b>; 
<a name=A21h></a>
h) INT bits lengths = <b>C</b> 1 plus the number of extra widths {j} of bits <b>C</b>; 
<a name=A21i></a>
i) INT bits shorths = <b>C</b> 1 plus the number of extra shorths {j} of bits <b>C</b>; 
<a name=A21j></a>
j) INT <i>L</i> bits width = <b>C</b> the number of elements in <i>L</i> bits; see <b><i>L</i></b> BITS {<a href="#A22g">10.2.2.g</a>};  this number increases (decreases) with the "size", i.e., the number of 'long's (minus the number of 'short's) of which '<i>L</i>' is composed, until a certain size is reached, viz., "the number of extra widths" (minus "the number of extra shorths") of bits, after which it is constant <b>C</b>; 
<a name=A21k></a>
k) INT bytes lengths = <b>C</b> 1 plus the number of extra widths {m} of bytes <b>C</b>; 
<a name=A21l></a>
l) INT bytes shorths  = <b>C</b> 1 plus the number of extra shorths {m} of bytes <b>C</b>; 
<a name=A21m></a>
m) INT <i>L</i> bytes width = <b>C</b> the number of elements in <i>L</i> bytes; see <b><i>L</i></b> BYTES {<a href="#A22h">10.2.2.h</a>};  this number increases (decreases) with the "size", i.e., the number of 'long's (minus the number of 'short's) of which '<i>L</i>' is composed, until a certain size is reached, viz., "the number of extra widths" (minus "the number of extra shorths") of bytes, after which it is constant <b>C</b>; 
<a name=A21n></a>
n) OP ABS = (CHAR a) INT: <b>C</b> the integral equivalent {<a href="report_1.html#2131g">2.1.3.1.g</a>}  of the character 'a' <b>C</b>; 
<a name=A21o></a>
o) OP REPR = (INT a) CHAR: <b>C</b> that character 'x', if it exists, for which ABS x = a <b>C</b>; 
<a name=A21p></a>
p) INT max abs char = <b>C</b> the largest integral equivalent {<a href="report_1.html#2131g">2.1.3.1.g</a>} of a character <b>C</b>; 
<a name=A21q></a>
q) CHAR null character = <b>C</b>  some character <b>C</b>; 
<a name=A21r></a>
r) CHAR flip = <b>C</b> the character used to represent '<tt>true</tt>' during transput {<a href="#A331a">10.3.3.1.a</a>, <a href="#A332a">10.3.3.2.a</a>}  <b>C</b>; 
<a name=A21s></a>
s) CHAR flop = <b>C</b> the character used to represent '<tt>false</tt>' during transput <b>C</b>; 
<a name=A21t></a>
t) CHAR errorchar = <b>C</b> the character used to represent unconvertible arithmetic values {<a href="#A321b">10.3.2.1.b</a>, c, d, e, f} during transput <b>C</b>; 
<a name=A21u></a>
u) CHAR blank =  " ";  
</pre>

<h3>
<a name=A22></a>10.2.2. Standard modes
</h3>

<a name=A22a></a>
<pre>
a) MODE VOID = <b>C</b> an actual-declarer specifying the mode 'void' <b>C</b>; 
<a name=A22b></a>
b) MODE BOOL = <b>C</b> an actual-declarer specifying the mode 'boolean' <b>C</b>; 
<a name=A22c></a>
c) MODE <b><i>L</i></b> INT = <b>C</b> an actual-declarer specifying the mode '<i>L</i> integral' <b>C</b>; 
<a name=A22d></a>
d) MODE <b><i>L</i></b> REAL = <b>C</b> an actual-declarer  specifying the mode '<i>L</i> real' <b>C</b>; 
<a name=A22e></a>
e)  MODE CHAR = <b>C</b> an actual-declarer specifying the mode 'character'  <b>C</b>; 
<a name=A22f></a>
f) MODE <b><i>L</i></b> COMPL = STRUCT (<b><i>L</i></b> REAL re, im); 
<a name=A22g></a>
g) MODE <b><i>L</i></b> BITS = STRUCT ([1 : <i>L</i> bits width] BOOL <i>L</i> <b>F</b>); {See <a href="#A21j">10.2.1.j</a>} 
      {The <b>field-selector</b> is hidden from the user in order that he may not 
      break open the structure; in particular, he may not subscript the field.} 
<a name=A22h></a>
h) MODE <b><i>L</i></b> BYTES = STRUCT ([1 : <i>L</i> bytes width] CHAR <i>L</i>  <b>F</b>); {See <a href="#A21m">10.2.1.m</a>}  
<a name=A22i></a>
i) MODE STRING = FLEX [1 : 0] CHAR;   
</pre>

<h3>
<a name=A23></a>10.2.3. Standard operators and functions
</h3>

<h3>
<a name=A230></a>10.2.3.0. Standard priorities
</h3>

<a name=A230a></a>
<pre>
a) PRIO MINUSAB = 1, PLUSAB = 1, TIMESAB = 1, DIVAB = 1, OVERAB = 1, MODAB = 1, PLUSTO = 1,
      -:= = 1, +:= = 1, &times;:= = 1,  *:= = 1, /:= = 1, &divide;:= = 1, %:= = 1, &divide;&times;:= = 1,
      &divide;*:= = 1,  %&times;:= = 1, +=: = 1, 

      OR = 2,

      &amp = 3, AND = 3, 

      = = 4, EQ = 4, &ne; = 4, /= = 4, NE = 4, 

      &lt; = 5, LT = 5, &le; = 5, &le; = 5, LE = 5, &ge; = 5, &ge; = 5, GE = 5, &gt; = 5, GT = 5, 

      - = 6, + = 6, 

      &times; = 7, * = 7, / = 7, &divide = 7, % = 7, OVER = 7,
      &divide;&times; = 7,  &divide;* = 7, %&times; = 7, %* = 7, MOD = 7, ELEM = 7, 

      &uarr; = 8, ** =  8, &darr; = 8, UP = 8, DOWN = 8, SHL = 8, SHR = 8, 

      LWB = 8, UPB = 8,

      +&times; = 9, +* = 9, I = 9;
</pre>   

<h3>
<a name=A231></a>10.2.3.1. Rows and associated operations
</h3>

<a name=A231a></a>
<pre>
a) MODE ? ROWS = <b>C</b> an actual-declarer specifying a mode united from 
      {<a href="report_1.html#2136a">2.1.3.6.a</a>} a sufficient set of modes each of which begins with 'row' <b>C</b>;  
<a name=A231b></a>
b) OP LWB = (INT n, ROWS a) INT: <b>C</b> the lower bound in the n-th bound
      pair of the descriptor of the value of 'a', if that bound pair exists <b>C</b>;  
<a name=A231c></a>
c) OP UPB = (INT n, ROWS a) INT: <b>C</b> the upper bound in the n-th
      bound pair of the descriptor of the value of 'a', if that bound pair exists <b>C</b>;  
<a name=A231d></a>
d) OP LWB = (ROWS a) INT: 1 LWB a;   
<a name=A231e></a>
e) OP UPB = (ROWS a) INT: 1 UPB a; 
</pre>

<p>
{The term "sufficient set", as used in a above and also in <a href="#A322b">10.3.2.2.b and d</a>, implies that no intended <b>particular-program</b> should fail to be produced (nor any unintended <b>particular-program</b> be produced) by the syntax solely on account of an insufficiency of modes in that set.}

<h3>
<a name=A232></a>10.2.3.2. Operations on boolean operands
</h3>

<p>
<a name=A232a></a>
<pre>
a) OP OR = (BOOL b) BOOL: (a | TRUE | b); 
<a name=A232b></a>
b) OP &laquo;&amp;, AND&raquo; = (BOOL a, b) BOOL: (a | b | FALSE); 
<a name=A232c></a>
c) OP &laquo;~, &not;, NOT&raquo; = (BOOL a) BOOL: (a | FALSE | TRUE); 
<a name=A232d></a>
d) OP &laquo;=, EQ&raquo; = (BOOL a, b) BOOL: (a AND b) OR (NOT a AND NOT b); 
<a name=A232e></a>
e) OP &laquo;&ne;, /=, NE&raquo; = (BOOL a, b) BOOL: NOT (a = b);  
<a name=A232f></a>
f) OP ABS = (BOOL a) INT: (a | 1 | 0);
</pre> 

<h3>
<a name=A233></a>10.2.3.3. Operations on integral operands
</h3>

<a name=A233a></a>
<pre>
a) OP &laquo;&lt;, LT&raquo; = (<b><i>L</i></b> INT a, b) BOOL: <b>C</b> <tt>true</tt> if the value of 'a' is smaller than 
      {<a href="report_1.html#2131e">2.1.3.1.e</a>}  that of 'b' and <tt>false</tt> otherwise <b>C</b>; 
<a name=A233b></a>
b) OP &laquo;&le;, <=, LE&raquo; = (<b><i>L</i></b> INT a, b) BOOL: NOT (b < a);
<a name=A233c></a>
c) OP &laquo;=, EQ&raquo; = (<b><i>L</i></b> INT a, b) BOOL: a &le; b AND  b &le; a; 
<a name=A233d></a>
d) OP &laquo;&ne;, /=, NE&raquo; = (<b><i>L</i></b> INT a, b) BOOL: NOT (a = b); 
<a name=A233e></a>
e) OP &laquo;&ge;, >=, GE&raquo; = (<b><i>L</i></b> INT a, b) BOOL: b &le; a; 
<a name=A233f></a>
f)  OP &laquo;&gt;, GT&raquo; = (<b><i>L</i></b> INT a, b) BOOL: b &lt; a; 
<a name=A233g></a>
g) OP - = (<b><i>L</i></b> INT a, b) <b><i>L</i></b> INT: <b>C</b> the value of 'a'  minus {<a href="report_1.html#2131e">2.1.3.1.e</a>} that of 'b' <b>C</b>; 
<a name=A233h></a>
h) OP - = (<b><i>L</i></b> INT a) <b><i>L</i></b> INT: <i>L</i> 0 - a; 
<a name=A233i></a>
i) OP + = (<b><i>L</i></b> INT a, b) <b><i>L</i></b> INT: a - -b; 
<a name=A233j></a>
j) OP + = (<b><i>L</i></b> INT a) <b><i>L</i></b> INT: a;  
<a name=A233k></a>
k) OP ABS = (<b><i>L</i></b> INT a) <b><i>L</i></b> INT: (a &lt; <i>L</i> 0 | -a | a); 
<a name=A233l></a>
l) OP &laquo;&times;, *&raquo; = (<b><i>L</i></b> INT a, b) <b><i>L</i></b> INT:
      BEGIN <b><i>L</i></b> INT s := <i>L</i> 0, i := ABS b;
         WHILE i &ge; <b><i>L</i></b> 1
         DO s := s + a, i := i - <b><i>L</i></b> 1 OD;
         (b &lt; <i>L</i> 0 | -s | s) 
      END;
<a name=A233m></a>
m) OP &laquo;&divide, %, OVER&raquo; = (<b><i>L</i></b> INT a, b) <b><i>L</i></b> INT:
     IF b &ne; <i>L</i> 0
     THEN <b><i>L</i></b> INT q := <i>L</i> 0, r := ABS a;
        WHILE (r := r - ABS b) &ge; <i>L</i> 0 DO q := q + <b><i>L</i></b> 1 OD;
        (a &lt; <i>L</i> 0 AND b &gt; <i>L</i> 0 OR a &ge; <i>L</i> 0 AND b &lt; <i>L</i> 0 | -q | q) 
     FI;
<a name=A233n></a>
n) OP &laquo;&divide;&times; &divide;&times;, %&times;, MOD&raquo; = (<b><i>L</i></b> INT a, i) <b><i>L</i></b> INT:
      (<b><i>L</i></b> INT r = a - a &divide; b &times; b; r &lt; 0 | r + ABS b | r); 
<a name=A233o></a>
o) OP / = (<b><i>L</i></b> INT a, b) <b><i>L</i></b>  REAL: <b><i>L</i></b>  REAL (a) / <i>L</i>  REAL (b); 
<a name=A233p></a>
p) OP &laquo;&uarr;, **, UP&raquo; = (<b><i>L</i></b> INT a, INT b) <b><i>L</i></b> INT:
      (b &ge; 0 | <b><i>L</i></b> INT p := <b><i>L</i></b> 1; TO b DO p := p &times; a OD; p); 
<a name=A233q></a>
q) OP LENG = (<b><i>L</i></b> INT a) LONG <i>L</i>  INT: <b>C</b> the long <i>L</i> integral value lengthened
      from {<a href="report_1.html#2131e">2.1.3.1.e</a>} the value of 'a' <b>C</b>; 
<a name=A233r></a>
r) OP SHORTEN = (LONG <b><i>L</i></b> INT a) <b><i>L</i></b> INT: <b>C</b> the <i>L</i> integral value, if it exists,
      which can be lengthened to {<a href="report_1.html#2131e">2.1.3.1.e</a>} the value of 'a' <b>C</b>; 
<a name=A233s></a>
s) OP ODD = (<b><i>L</i></b> INT a) BOOL: ABS a &divide;&times; <i>L</i>2 = <i>L</i>1; 
<a name=A233t></a>
t) OP SIGN = (<i>L</i>  INT a) INT:
      (a &gt; <i>L</i> 0 | 1 |: a &lt; <i>L</i>0 | -1 | 0); 
<a name=A233u></a>
u) OP &laquo;+&times;, +*, I&raquo; = (<b><i>L</i></b> INT a, b)  <b><i>L</i></b> COMPL : (a, b);  
</pre>

<h3>
<a name=A234></a>10.2.3.4. Operations on real operands
</h3>
 
<a name=A234a></a>
<pre>
a) OP &laquo;&lt;, LT&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: <b>C</b> <tt>true</tt> if the value of 'a' is smaller 
      than {<a href="report_1.html#2131e">2.1.3.1.e</a>}  that of 'b' and <tt>false</tt> otherwise <b>C</b>; 
<a name=A234b></a>
b) OP &laquo;&le;, <=, LE&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: NOT (b < a);
<a name=A234c></a>
c) OP &laquo;=, EQ&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: a &le; b AND b &le; a; 
<a name=A234d></a>
d) OP &laquo;&ne;, /=, NE&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: NOT (a = b); 
<a name=A234e></a>
e) OP &laquo;&ge;,  >=, GE&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: b &le; a; 
<a name=A234f></a>
f) OP &laquo;&gt;, GT&raquo; = (<b><i>L</i></b>  REAL a, b) BOOL: b < a;
<a name=A234g></a>
g) OP - = (<b><i>L</i></b>  REAL a, b) <b><i>L</i></b>  REAL: <b>C</b> the value of 'a' minus {<a href="report_1.html#2131e">2.1.3.1.e</a>} that of 'b' <b>C</b>; 
<a name=A234h></a>
h) OP - = (<b><i>L</i></b>  REAL a) <b><i>L</i></b>  REAL: <i>L</i> 0 - a; 
<a name=A234i></a>
i) OP + = (<b><i>L</i></b>  REAL a, b) <b><i>L</i></b>  REAL: a - -b; 
<a name=A234j></a>
j) OP + = (<b><i>L</i></b>  REAL a) <b><i>L</i></b>  REAL: a; 
<a name=A234k></a>
k) OP ABS = (<b><i>L</i></b>  REAL a) <b><i>L</i></b>  REAL: (a &lt; <i>L</i> 0 | -a | a); 
<a name=A234l></a>
l) OP &laquo;&times;, *&raquo; = (<b><i>L</i></b>  REAL a, b) <b><i>L</i></b>  REAL: <b>C</b> the value of 'a' times {<a href="report_1.html#2131e">2.1.3.1.e</a>}  that of 'b' <b>C</b>; 
<a name=A234m></a>
m) OP / = (<b><i>L</i></b>  REAL a, b) <i>L</i>  REAL: <b>C</b> the value of 'a' divided by {<a href="report_1.html#2131e">2.1.3.1.e</a>} that of 'b' <b>C</b>;
<a name=A234n></a>
n) OP LENG = (<b><i>L</i></b>  REAL a) LONG <b><i>L</i></b>  REAL: <b>C</b> the long <i>L</i> real value lengthened
      from {<a href="report_1.html#2131e">2.1.3.1.e</a>} the value of 'a' <b>C</b>; 
<a name=A234o></a>
o) OP SHORTEN = (LONG <i>L</i>  REAL a) <b><i>L</i></b>  REAL: <b>C</b> if ABS a &le; <b>S</b> LENG max real, then a <b><i>L</i></b>  REAL} value 'v' such that, for any <b><i>L</i></b>  REAL value 'w', ABS (LENG v - a) &le; ABS (LENG w - a) <b>C</b>; 
<a name=A234p></a>
p) OP ROUND = (<b><i>L</i></b>  REAL a) <b><i>L</i></b> INT: <b>C</b> a <i>L</i>  integral value, if one exists, which
      is widenable to {<a href="report_1.html#2131e">2.1.3.1.e</a>}  a <b><i>L</i></b>  REAL value differing by not more 
      than one-half from the value of 'a' <b>C</b>; 
<a name=A234q></a>
q) OP SIGN = (<b><i>L</i></b> REAL a) INT: (a &gt;<i>L</i> 0 | 1 |: a &lt; <i>L</i> 0 | -1 | 0);  
<a name=A234r></a>
r) OP ENTIER = (<b><i>L</i></b> REAL a) <b><i>L</i></b> INT:
      BEGIN <b><i>L</i></b> INT j := <i>L</i> 0;
         WHILE j &lt; a DO j := j + <i>L</i>1 OD;
         WHILE j &gt; a DO j := j - <i>L</i>1 OD;
         j
      END;
<a name=A234s></a>
s) OP &laquo;+*, +*, I&raquo;  = (<b><i>L</i></b>  REAL a, b) <b><i>L</i></b> COMPL: (a, b);  
</pre>

<h3>
<a name=A235></a>10.2.3.5. Operations on arithmetic operands
</h3>

<a name=A235a></a>
<pre>
a) OP <b>P</b> = (<b><i>L</i></b>  REAL a, <b><i>L</i></b> INT b) <b><i>L</i></b>  REAL: a <b>P</b> <b><i>L</i></b>  REAL (b); 
<a name=A235b></a>
b) OP <b>P</b> = (<b><i>L</i></b> INT a, <b><i>L</i></b>  REAL b) <b><i>L</i></b>  REAL: <b><i>L</i></b>  REAL (a) <b>P</b> b; 
<a name=A235c></a>
c)  OP <b>R</b> = (<b><i>L</i></b>  REAL a, <b><i>L</i></b> INT b) BOOL: a <b>R</b> <b><i>L</i></b>  REAL (b); 
<a name=A235d></a>
d) OP <b>R</b> = (<b><i>L</i></b> INT a, <b><i>L</i></b>  REAL b) BOOL: <b><i>L</i></b>  REAL (a) <b>R</b> b; 
<a name=A235e></a>
e) OP &laquo;+&times;, +*, I&raquo; = (<b><i>L</i></b>  REAL a, <b><i>L</i></b> INT b) <b><i>L</i></b> COMPL: (a, b); 
<a name=A235f></a>
f)  OP &laquo;+&times;, +*, I&raquo; = (<b><i>L</i></b> INT a, <b><i>L</i></b>  REAL b) <b><i>L</i></b> COMPL: (a, b); 
<a name=A235g></a>
g) OP &laquo;&uarr;, **, UP&raquo; = (<i>L</i> REAL a, INT b) <b><i>L</i></b> REAL: 
      (<b><i>L</i></b> REAL p := <b><i>L</i></b> 1; TO ABS b DO p := p &times; a OD; (b &ge; 0 | p | <b><i>L</i></b> 1 / p));  
</pre>

<h3>
<a name=A236></a>10.2.3.6. Operations on character operands
</h3>

<a name=A236a></a>
<pre>
a) OP <b>R</b> (CHAR a, b) BOOL: ABS a <b>R</b> ABS b; {<a href="#A21n">10.2.1.n</a>}
<a name=A236b></a>
b) OP + = (CHAR a, b) STRING: (a, b);  
</pre>

<h3>
<a name=A237></a>10.2.3.7. Operations on complex operands
</h3>

<a name=A237a></a>
<pre>
a) OP RE = (<b><i>L</i></b> COMPL a) <b><i>L</i></b>  REAL: re OF a;  
<a name=A237b></a>
b) OP IM = (<b><i>L</i></b> COMPL a) <b><i>L</i></b>  REAL: im OF a;  
<a name=A237c></a>
c) OP ABS = (<b><i>L</i></b> COMPL a) <b><i>L</i></b>  REAL: <i>L</i>  sqrt (RE a&uarr; 2 + IM a &uarr; 2); 
<a name=A237d></a>
d) OP ARG = (<b><i>L</i></b> COMPL a) <b><i>L</i></b>  REAL:
      IF <b><i>L</i></b>  REAL re = RE a, im = IM a;
         re &ne; <i>L</i> 0 OR im &ne; <i>L</i> 0
      THEN IF ABS re &gt; ABS im
         THEN <i>L</i> arctan (im / re) + <i>L</i> pi / <i>L</i> 2 &times;
            (im &lt; <i>L</i> 0 | SIGN re - 1 | 1 - SIGN re) 
         ELSE - <i>L</i> arctan (re / im) + <i>L</i> pi / <i>L</i> 2 &times; SIGN im
         FI
      FI;
<a name=A237e></a>
e) OP CONJ = (<b><i>L</i></b> COMPL a) <b><i>L</i></b> COMPL: RE a I - IM a; 
<a name=A237f></a>
f) OP &laquo;=, EQ&raquo; = (<b><i>L</i></b> COMPL a, b) BOOL: RE a = RE b AND IM a = IM b; 
<a name=A237g></a>
g)  OP &laquo;&ne;, /=, NE&raquo; = (<b><i>L</i></b> COMPL a, b) BOOL: NOT (a = b); 
<a name=A237h></a>
h) OP - = (<b><i>L</i></b> COMPL a, b) <b><i>L</i></b> COMPL: (RE a - RE b) I (IM a - IM b); 
<a name=A237i></a>
i) OP - = (<b><i>L</i></b> COMPL a) <b><i>L</i></b> COMPL: -RE a I -IM a; 
<a name=A237j></a>
j) OP + = (<b><i>L</i></b> COMPL a, b) <b><i>L</i></b> COMPL: (RE a + RE b) I (IM a + IM b); 
<a name=A237k></a>
k) OP + = (<b><i>L</i></b> COMPL a) <b><i>L</i></b> COMPL: a; 
<a name=A237l></a>
l) OP &laquo;&times;,*&raquo; = (<b><i>L</i></b> COMPL a, b) <b><i>L</i></b> COMPL: 
      (RE a &times; RE b - IM a &times; IM b) I (RE a &times; IM b + IM a &times; RE b); 
<a name=A237m></a>
m) OP / = (<b><i>L</i></b> COMPL a, b) <b><i>L</i></b> COMPL:
      (<b><i>L</i></b>  REAL d = RE (b &times; CONJ b); <b><i>L</i></b> COMPL n = a&times; CONJ b;
      (RE n / d) I (IM n / d));
<a name=A237n></a>
n) OP LENG = (<b><i>L</i></b> COMPL a) LONG <b><i>L</i></b> COMPL: LENG RE a I LENG IM a; 
<a name=A237o></a>
o) OP SHORTEN  = (LONG <b><i>L</i></b> COMPL a) <b><i>L</i></b> COMPL: SHORTEN RE a I SHORTEN IM a; 
<a name=A237p></a>
p) OP <b>P</b> = (<b><i>L</i></b> COMPL a, <b><i>L</i></b> INT b) <b><i>L</i></b> COMPL: a <b>P</b> <b><i>L</i></b> COMPL (b); 
<a name=A237q></a>
q) OP <b>P</b> = (<b><i>L</i></b> COMPL a, <b><i>L</i></b>  REAL b) <b><i>L</i></b> COMPL: a <b>P</b> <b><i>L</i></b> COMPL (b); 
<a name=A237r></a>
r) OP <b>P</b> = (<b><i>L</i></b> INT a, <b><i>L</i></b> COMPL b) <b><i>L</i></b> COMPL: <b><i>L</i></b> COMPL (a) <b>P</b> b;  
<a name=A237s></a>
s) OP <b>P</b> = (<b><i>L</i></b>  REAL a, <b><i>L</i></b> COMPL b) <b><i>L</i></b> COMPL: <b><i>L</i></b> COMPL (a) <b>P</b> b; 
<a name=A237t></a>
t) OP &laquo;&uarr;,  **, UP&raquo; = (<b><i>L</i></b> COMPL a, INT b) <b><i>L</i></b> COMPL: 
      (<b><i>L</i></b> COMPL p := <b><i>L</i></b> 1; TO ABS b DO p := p &times; a OD; (b &ge; 0 | p | <b><i>L</i></b> 1 / p)); 
<a name=A237u></a>
u) OP <b>E</b> = (<b><i>L</i></b> COMPL a, <b><i>L</i></b> INT b) BOOL: a <b>E</b> <b><i>L</i></b> COMPL (b); 
<a name=A237v></a>
v) OP <b>E</b> = (<b><i>L</i></b> COMPL a, <b><i>L</i></b>  REAL b) BOOL: a <b>E</b> <b><i>L</i></b> COMPL (b); 
<a name=A237w></a>
w) OP <b>E</b> =  (<b><i>L</i></b> INT a, <b><i>L</i></b> COMPL b) BOOL: b <b>E</b> a; 
<a name=A237x></a>
x) OP <b>E</b> = (<b><i>L</i></b>  REAL a, <b><i>L</i></b> COMPL b) BOOL: b <b>E</b> a;  
</pre>

<h3>
<a name=A238></a>10.2.3.8. Bits and associated operations
</h3>

<pre>
<a name=A238a></a>
a) OP &laquo;=, EQ&raquo; = (<b><i>L</i></b> BITS a, b) BOOL:
      BEGIN BOOL c;
         FOR i TO <i>L</i> bits width
         WHILE c := (<i>L</i> <b>F</b> OF a) [i]= (<i>L</i> <b>F</b> OF b) [i]
         DO SKIP OD;
         c
      END;
<a name=A238b></a>
b) OP &laquo;&ne;, /=, NE&raquo; = (<b><i>L</i></b> BITS a, b) BOOL: NOT (a = b); 
<a name=A238c></a>
c) OP OR = (<b><i>L</i></b> BITS a, b) <b><i>L</i></b> BITS :
      BEGIN <b><i>L</i></b> BITS c;
         FOR i TO <i>L</i> bits width
         DO (<i>L</i> <b>F</b> OF c) [i] = (<i>L</i> <b>F</b> OF a) [i] OR (<i>L</i> <b>F</b> OF b) [i] OD;
         c
      END;
<a name=A238d></a>
d) OP &laquo;&amp;, AND&raquo; = (<b><i>L</i></b> BITS a, b) <b><i>L</i></b> BITS :
      BEGIN <b><i>L</i></b> BITS c;
         FOR i TO <i>L</i> bits width
         DO (<i>L</i> <b>F</b> OF c) [i]:= (<i>L</i> <b>F</b> OF a) [i] AND (<i>L</i> <b>F</b> OF b) [i] OD;
         c
      END;
<a name=A238e></a>
e) OP &laquo;&le;, <=, LE&raquo; = (<i>L</i>  BITS a, b) BOOL: (a OR b) = b; 
<a name=A238f></a>
f) OP &laquo;&ge;,  >=, GE&raquo; = (<b><i>L</i></b> BITS a, b) BOOL: b &le; a; 
<a name=A238g></a>
g) OP &laquo;&uarr; , UP, SHL&raquo;= (<b><i>L</i></b> BITS a, INT b) <b><i>L</i></b> BITS :
      IF ABS b &le; <i>L</i> bits width
      THEN <b><i>L</i></b> BITS c := a;
         TO ABS b
         DO IF b &gt;0 THEN
            FOR i FROM 2 TO <i>L</i> bits width
            DO (<i>L</i> <b>F</b> OF e) [i - 1] := (<i>L</i> <b>F</b> OF c) [i] OD;
            (<i>L</i> <b>F</b> OF c) [<i>L</i> bits width] := FALSE
         ELSE
            FOR i FROM <i>L</i> bits width BY -1 TO 2
            DO (<i>L</i> <b>F</b> OF c) [i] := (<i>L</i> <b>F</b> OF c) [i - 1] OD;
            (<i>L</i> <b>F</b> OF c) [1] := FALSE
         FI OD;
         c
      FI;
<a name=A238h></a>
h) OP &laquo;DOWN, SHR&raquo; = (<b><i>L</i></b> BITS x, INT n) <b><i>L</i></b> BITS: x &uarr; -n; 
<a name=A238i></a>
i) OP ABS = (<b><i>L</i></b> BITS a) <b><i>L</i></b> INT :
      BEGIN <b><i>L</i></b> INT c := <i>L</i> 0;
         FOR i TO <i>L</i> bits width
         DO c := <i>L</i>2 &times; c + <b>K</b> ABS (<i>L</i> <b>F</b> OF a) [i] OD;
         c
      END;
 
</pre>
<a name=A238j></a>
<pre>
j) OP BIN = (<b><i>L</i></b> INT a) <b><i>L</i></b> BITS :
      IF a &ge; <i>L</i> 0
      THEN <b><i>L</i></b> INT b := a; <b><i>L</i></b> BITS c;
         FOR i FROM <i>L</i> bits width BY - 1 TO 1
         DO (<i>L</i> <b>F</b> OF c) [i] := ODD b; b := b % <i>L</i> 2 OD;
         c
      FI;
<a name=A238k></a>
k) OP ELEM = (INT a, <b><i>L</i></b> BITS b) BOOL: (<i>L</i> <b>F</b> OF b) [a];
<a name=A238l></a>
l) PROC <i>L</i> bits pack = ([ ] BOOL a) <b><i>L</i></b> BITS :
      IF INT n = UPB a[@1];
         n &le; <i>L</i> bits width
      THEN <b><i>L</i></b> BITS c;
         FOR i TO <i>L</i> bits width
         DO (<i>L</i> <b>F</b> OF c) [i] := 
            (i &le; <i>L</i> bits width - n | FALSE | a[@1][i - <i>L</i> bits width + n ]) 
         OD;
         c
      FI;
<a name=A238m></a>
m) OP &laquo;~, &not;, NOT&raquo; = (<b><i>L</i></b> BITS a) <b><i>L</i></b> BITS :
      BEGIN <b><i>L</i></b> BITS c;
         FOR i TO <i>L</i> bits width DO (<i>L</i> <b>F</b> OF c) [i] := NOT (<i>L</i> <b>F</b> OF a) [i] OD;
         c
      END;
<a name=A238n></a>
n) OP LENG = (<b><i>L</i></b> BITS a) LONG <b><i>L</i></b> BITS : long <i>L</i> bits pack (a); 
<a name=A238o></a>
o) OP SHORTEN =  (LONG <b><i>L</i></b> BITS a) <b><i>L</i></b> BITS: <i>L</i> bits pack ([ ] BOOL (a) 
      [long <i>L</i> bits width -  <i>L</i> bits width + 1 : ]);  
</pre>

<h3>
<a name=A239></a>10.2.3.9. Bytes and associated operations
</h3>

<a name=A239a></a>
<pre>
a) OP <b>R</b> = (<b><i>L</i></b> BYTES a, b) BOOL: STRING (a) <b>R</b> STRING (b); 
<a name=A239b></a>
b) OP ELEM = (INT a, <b><i>L</i></b> BYTES b) CHAR: (<i>L</i> <b>F</b> OF b) [a]; 
<a name=A239c></a>
c) PROC <i>L</i> bytes pack = (STRING a) <b><i>L</i></b> BYTES:
      IF INT n = UPB a [@1];
         n &le; <i>L</i> bytes width
      THEN <b><i>L</i></b> BYTES c;
         FOR i TO <i>L</i> bytes width
         DO (<i>L</i> <b>F</b> OF c) [i] := (i &le; n | a[@1][i] | null character) OD;
         c
      FI;
<a name=A239d></a>
d) OP LENG = (<b><i>L</i></b> BYTES a) LONG <b><i>L</i></b> BYTES: long <i>L</i> bytes pack (a); 
<a name=A239e></a>
e) OP SHORTEN = (LONG <b><i>L</i></b> BYTES a) <b><i>L</i></b> BYTES: 
      <i>L</i> bytes pack (STRING (a) [ : <i>L</i> bytes width]);
</pre>   

<h3>
<a name=A23A></a>10.2.3.10. Strings and associated operations
</h3>

<a name=A23Aa></a>
<pre>
a) OP &laquo;&lt;, LT&raquo; = (STRING a, b) BOOL:
      BEGIN INT m = UPB a[@1], n = UPB b[@1]; INT c := 0;
         FOR i TO (m &lt; n | m | n) 
         WHILE (c := ABS a [@1][i] - ABS b[@1][i]) = 0
         DO SKIP OD;
         (c = 0 | m &lt; n AND n &gt; 0 | c &lt; 0) 
      END;
<a name=A23Ab></a>
b) OP &laquo;&le;, <=, LE&raquo; = (STRING a, b) BOOL: NOT (b &lt; a); 
<a name=A23Ac></a>
c) OP &laquo;=, EQ&raquo;  = (STRING a, b) BOOL: a &le; b AND b &ge; a; 
<a name=A23Ad></a>
d)  OP &laquo;&ne;, /=, NE&raquo; = (STRING a, b) BOOL: NOT (a = b); 
<a name=A23Ae></a>
e) OP &laquo;&ge;, >=, GE&raquo; = (STRING a, b) BOOL: b &le; a; 
<a name=A23Af></a>
f) OP &laquo;&gt;, GT&raquo; = (STRING a, b) BOOL: b < a; 
<a name=A23Ag></a>
g) OP <b>R</b> = (STRING a, CHAR b)  BOOL: a <b>R</b> STRING (b); 
<a name=A23Ah></a>
h) OP <b>R</b> = (CHAR a, STRING b) BOOL: STRING (a) <b>R</b> b; 
<a name=A23Ai></a>
i) OP + = (STRING a, b) STRING:
      (INT m = (INT la = UPB a[@1]; la &lt; 0 | 0 | la),
           n = (INT lb = UPB b[@1]; lb &lt; 0 | 0 | lb);
       [1 : m + n] CHAR c;
       c[1 : m] := a[@1]; c[m + 1 : m + n] := b[@1]; c
       <var>[[The assignments in the last line have potential bounds errors 
         when UPB a[@1] < 0 or UPB b[@1] < 0 and should read
         (m > 0 | c[1 : m] := a[@1]);  (n > 0 | c[m + 1 : m + n] := b[@1]); c]]</var>
      );
<a name=A23Aj></a>
j) OP + = (STRING a, CHAR b) STRING: a  + STRING (b); 
<a name=A23Ak></a>
k) OP + = (CHAR a, STRING b)  STRING: STRING (a) + b; 
<a name=A23Al></a>
l) OP &laquo;&times;, *&raquo; = (STRING a, INT b) STRING: (STRING c; TO b DO c := c + a OD; c); 
<a name=A23Am></a>
m) OP &laquo;&times;, *&raquo; = (INT a, STRING b) STRING: b &times; a;  
<a name=A23An></a>
n) OP &laquo;&times;, *&raquo; = (CHAR a, INT b)  STRING: STRING (a) &times; b; 
<a name=A23Ao></a>
o) OP &laquo;&times;, *&raquo; = (INT a, CHAR b) STRING: b &times; a;
</pre>
<p>
{The operations defined in a, g and h imply that if <tt>ABS "a" &lt; ABS "b"</tt>, then <tt>""&lt; "a"; "a"&lt; "b";  "aa"&lt; "ab"; "aa" &lt; "ba"; "ab" &lt; "b"</tt> and <tt>"ab" &lt; "ba"</tt>.}    

<h3>
<a name=A23B></a>10.2.3.11. Operations combined with assignations
</h3>

<a name=A23Ba></a>
<pre>
a) OP &laquo;MINUSAB, -:=&raquo; = (REF <b><i>L</i></b> INT a, <i>L</i>  INT b) REF <b><i>L</i></b> INT: a := a - b; 
<a name=A23Bb></a>
b) OP &laquo;MINUSAB, -:=&raquo; = (REF <b><i>L</i></b>  REAL a, <b><i>L</i></b>  REAL b) REF <b><i>L</i></b>  REAL: a := a - b;  
<a name=A23Bc></a>
c) OP &laquo;MINUSAB, -:=&raquo; = (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b> COMPL b) REF <b><i>L</i></b> COMPL: a := a - b; 
<a name=A23Bd></a>
d) OP &laquo;PLUSAB, +:=&raquo; = (REF <b><i>L</i></b> INT a, <b><i>L</i></b> INT b) REF <b><i>L</i></b> INT: a := a + b; 
<a name=A23Be></a>
e) OP &laquo;PLUSAB, +:=&raquo; = (REF <b><i>L</i></b>  REAL a, <b><i>L</i></b>  REAL b) REF <b><i>L</i></b>  REAL: a := a + b; 
<a name=A23Bf></a>
f) OP &laquo;PLUSAB, +:=&raquo;  = (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b> COMPL b) REF <b><i>L</i></b> COMPL: a := a + b; 
<a name=A23Bg></a>
g) OP &laquo;TIMESAB, &times;:=, *:=&raquo; = (REF <b><i>L</i></b> INT a,  <b><i>L</i></b> INT b) REF <b><i>L</i></b> INT :a := a &times; b; 
<a name=A23Bh></a>
h) OP &laquo;TIMESAB, &times;:=, *:=&raquo; = (REF <b><i>L</i></b>  REAL a, <b><i>L</i></b>  REAL b) REF <b><i>L</i></b>  REAL: a :=  a &times; b; 
<a name=A23Bi></a>
i) OP &laquo;TIMESAB, &times;:=, *:=&raquo; =  (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b> COMPL b) REF <b><i>L</i></b> COMPL: a := a &times; b; 
<a name=A23Bj></a>
j) OP &laquo;OVERAB, &divide;:=, %:= , %:=&raquo; = (REF <b><i>L</i></b> INT a, <b><i>L</i></b> INT b) REF <b><i>L</i></b> INT: a := a &divide; b; 
<a name=A23Bk></a>
k) OP &laquo;MODAB,  &divide;&times;:=, &divide;*:=, %&times;:=, %*:=&raquo; = 
      (REF <b><i>L</i></b> INT a, <b><i>L</i></b> INT b) REF <b><i>L</i></b> INT: a := a &divide;&times; b;  
<a name=A23Bl></a>
l) OP &laquo;DIVAB, /:=&raquo; = (REF <b><i>L</i></b>  REAL a, <i>L</i>  REAL b) REF <b><i>L</i></b>  REAL :a := a / b; 
<a name=A23Bm></a>
m) OP &laquo;DIVAB, /:=&raquo; = (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b> COMPL b) REF <b><i>L</i></b> COMPL: a := a / b;  
<a name=A23Bn></a>
n) OP <b>Q</b> = (REF <b><i>L</i></b>  REAL a, <b><i>L</i></b> INT b) REF <b><i>L</i></b>  REAL: a <b>Q</b> <b><i>L</i></b>  REAL (b); 
<a name=A23Bo></a>
o) OP <b>Q</b> = (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b> INT b) REF <b><i>L</i></b> COMPL: a <b>Q</b> <b><i>L</i></b> COMPL (b); 
<a name=A23Bp></a>
p) OP <b>Q</b> = (REF <b><i>L</i></b> COMPL a, <b><i>L</i></b>  REAL b) REF <b><i>L</i></b> COMPL: a <b>Q</b> <b><i>L</i></b> COMPL (b); 
<a name=A23Bq></a>
q) OP &laquo;PLUSAB, +:=&raquo; = (REF STRING a, STRING b) REF STRING: a := a + b; 
<a name=A23Br></a>
r) OP &laquo;PLUSTO , +=:&raquo; = (STRING a, REF STRING b) REF STRING: b := a + b; 
<a name=A23Bs></a>
s) OP &laquo;PLUSAB, +:=&raquo; = (REF STRING a, CHAR b) REF STRING: a +:= STRING (b); 
<a name=A23Bt></a>
t) OP &laquo;PLUSTO , +=:&raquo; = (CHAR a, REF STRING b) REF STRING: STRING (a) +=: b; 
<a name=A23Bu></a>
u) OP &laquo;TIMESAB, &times;:=, *:=&raquo; = (REF STRING a, INT b) REF STRING: a := a &times; b;
</pre>  

<h3>
<a name=A23C></a>10.2.3.12. Standard mathematical constants and functions
</h3>

<a name=A23Ca></a>
<pre>
a) <b><i>L</i></b>  REAL <i>L</i> pi = <b>C</b> a <i>L</i> real value close to &pi; see 
      Math. of Comp. V. 16, 1962, pp. 80-99 <b>C</b>;  
<a name=A23Cb></a>
b) PROC <i>L</i> sqrt = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> if x &ge; <i>L</i> 0, a <i>L</i> real value close to
      the square root of  'x' <b>C</b>; 
<a name=A23Cc></a>
c) PROC <i>L</i> exp = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value, if one exists, close to 
      the exponential function of 'x' <b>C</b>; 
<a name=A23Cd></a>
d) PROC <i>L</i> ln = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value, if one exists, close to 
      the natural logarithm of x <b>C</b>; 
<a name=A23Ce></a>
e) PROC <i>L</i> cos = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value close to the cosine
      of 'x' <b>C</b>;  
<a name=A23Cf></a>
f) PROC <i>L</i> arccos = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> if ABS x &le; <b><i>L</i></b> 1, a <i>L</i> real value close
      to the inverse cosine of 'x', <i>L</i> 0 &le; <i>L</i> arccos (x) &le; <i>L</i> pi <b>C</b>; 
<a name=A23Cg></a>
g) PROC <i>L</i> sin = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value close to the sine of 
      x <b>C</b>;  
<a name=A23Ch></a>
h) PROC <i>L</i> arcsin = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> if ABS x &le; <b><i>L</i></b> 1, a <i>L</i> real value close
      to the inverse sine of 'x', ABS <i>L</i> arcsin (x) &le; <i>L</i> pi / <i>L</i> 2 <b>C</b>; 
<a name=A23Ci></a>
i) PROC <i>L</i> tan = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value, if one exists, close to 
      the tangent of 'x' <b>C</b>; 
<a name=A23Cj></a>
j) PROC <i>L</i> arctan = (<b><i>L</i></b>  REAL x) <b><i>L</i></b>  REAL: <b>C</b> a <i>L</i> real value close to the 
      inverse tangent of 'x', ABS <i>L</i> arctan (x) &le; <i>L</i> pi / <i>L</i> 2 <b>C</b>;  
<a name=A23Ck></a>
k) PROC <i>L</i> next random = (REF <b><i>L</i></b> INT a) <i>L</i>  REAL: 
      (a := <b>C</b> the next pseudo-random <i>L</i> integral value after 'a' from a 
         uniformly distributed sequence on the interval
        [<i>L</i> 0, maxint] <b>C</b>; 
      <b>C</b> the real value corresponding to 'a' according to some mapping 
         of integral values [<i>L</i> 0, max int] into real values  [<i>L</i> 0, <b><i>L</i></b> 1) 
         {i.e., such that 0 &le; x &lt; 1} such that the sequence of real values
         so produced preserves the properties of pseudo-randomness
         and uniform distribution of the sequence of integral values <b>C</b>); 
</pre>

<h3>
<a name=A24></a>10.2.4. Synchronization operations
</h3>

<p>
The elaboration of a <b>parallel-clause</b> <i>P</i> {<a href="report_2.html#331c">3.3.1.c</a>} in an environ <i>E</i> is termed a "parallel action". The elaboration of a constituent <b>unit</b> of <i>P</i> in <i>E</i> is termed a "process" of that parallel action.  

<p>
Any elaboration <i>A</i> {in some environ} of either of the <b>ENCLOSED-clauses</b> delineated by the <b>pragmats</b> {<a href="report_4.html#921b">9.2.1.b</a>} <tt>PR start of incompatible part PR</tt> and <tt>PR finish of incompatible part PR</tt> in the forms <a href="#A24d">10.2.4.d</a>  and <a href="#A24e">10.2.4.e</a>  is incompatible with {<a href="report_1.html#2142e">2.1.4.2.e</a>} any elaboration <i>B</i> of either of those <b>ENCLOSED-clauses</b> if <i>A</i> and <i>B</i> are descendent actions {<a href="report_1.html#2142b">2.1.4.2.b</a>} of different processes of some same parallel action.  

<a name=A24a></a>
<pre>
a) MODE SEMA = STRUCT (REF INT <b>F</b>); 
<a name=A24b></a>
b) OP LEVEL = (INT a) SEMA: (SEMA s; <b>F</b> OF s := HEAP INT := a; s); 
<a name=A24c></a>
c) OP LEVEL = (SEMA a) INT: <b>F</b> OF a;  
<a name=A24d></a>
d) OP DOWN = (SEMA edsger) VOID:
   BEGIN REF INT dijkstra = <b>F</b> OF edsger;
      WHILE
         PR start of incompatible part PR
            IF dijkstra &ge; 1 THEN dijkstra -:= 1; FALSE
            ELSE
               <b>C</b> let P be the process such that the elaboration
               of this pseudo-comment {<a href="#A13s7">10.1.3.Step 7</a>} is a descendent
               action of P, but not of any other process descended 
               from P; the process P is halted {<a href="report_1.html#2143f">2.1.4.3.f</a>} <b>C</b>;
               TRUE
            FI
         PR finish of incompatible part PR
      DO SKIP OD
   END;
<a name=A24e></a>
e) OP UP = (SEMA edsger) VOID:
      PR start of incompatible part PR
         IF REF INT dijkstra = <b>F</b> OF edsger; (dijkstra +:= 1) &ge; 1
         THEN
            <b>C</b> all processes are resumed {<a href="report_1.html#2143g">2.1.4.3.g</a>} which are halted 
            because the integer referred to by the name yielded by
            'dijkstra' was smaller than one <b>C</b>
         FI
      PR finish of incompatible part PR;
</pre>
  
<h3>
<a name=A3></a>10.3. Transput declarations
</h3>

<p>
<div align=right> {"So it does!" said Pooh, "It goes in!"<br>
"So it does!" said Piglet, "And it comes out!"<br>
"Doesn't it? " said Eeyore, "It goes in and out like anything,"<br>
Winnie-the-Pooh, A.A. Milne.}
</div>
 
<p>
{Three ways of "transput" (i.e., input and output) are provided by the <b>standard-prelude</b>, viz., formatless transput {<a href="#A33">10.3.3</a>}, formatted transput {<a href="#A35">10.3.5</a>} and binary transput {<a href="#A36">10.3.6</a>}.}   

<h3>
<a name=A31></a>10.3.1. Books, channels and files
</h3>

<p>
{"Books", "channels"  and "files" model the transput devices of the physical machine used in the implementation.}  

<h3>
<a name=A311></a>10.3.1.1. Books and backfiles
</h3>

<p>
{<a name=A311aa></a>aa) All information within the system is to be found in a number of "books". A book {a} is a structured value including a field <tt>text</tt> of the mode specified by <tt>FLEXTEXT</tt> {b} which refers to information in the form of characters. The <tt>text</tt> has a variable number of pages, each of which may have a variable number of lines, each of which may have a variable number of characters. Positions within the <tt>text</tt> are indicated by a page number, a line number and a character number. The book includes a field <tt>lpos</tt> which indicates the "logical end" of the book, i.e., the position up to which it has been filled with information, a string <tt>idf</tt>, which identifies the book and which may possibly include other information, e.g., ownership, and fields <tt>putting</tt> and <tt>users</tt>  which permit the book to be opened {<a href="#A314d">10.3.1.4.d</a>} on more than one file simultaneously only if putting is not possible on any of them.  

<p>
<a name=A311bb></a>bb) The books in the system are accessed via a chain of backfiles. The chain of books available for opening {<a href="#A314dd">10.3.1.4.dd</a>} is referenced by <tt>chainbfile</tt>. A given book may be referenced by more than one backfile on this chain, thus allowing simultaneous access to a single book by more than one process {<a href="#A24">10.2.4</a>}. However such access can only be for reading a book, since only one process may access a book such that it may be written to {aa}. The chain of books which have been locked {<a href="#A314o">10.3.1.4.o</a>} is referenced by <tt>lockedbfile</tt>.  

<p>
<a name=A311cc></a>cc) Simultaneous access by more than one process to the chain of backfiles is prevented by use of the semaphore <tt>bfileprotect</tt>, which provides mutual exclusion between such processes.  

<p>
<a name=A311dd></a>dd) Books may be created (e.g., by input) or destroyed (e.g., after output) by tasks (e.g., the operating system) in the <b>system-task-list</b> {<a href="#A42">10.4.2</a>}, such books being then added to or removed from the chain of backfiles.}  

<a name=A311a></a> 
<pre>
a) MODE ? BOOK=
     STRUCT (FLEXTEXT text,
        POS lpos &cent; logical end of book &cent;,
        STRING idf &cent; identification &cent;,
        BOOL putting &cent; TRUE if the book may be written to &cent;,
        INT users &cent; the number of times the book is opened &cent;);
<a name=A311b></a>
b) MODE ? TEXT = REF [ ] [ ] [ ] CHAR, MODE ? FLEXTEXT = REF FLEX [ ] FLEX [ ] FLEX [ ] CHAR;
<a name=A311c></a>
c) MODE ? POS = STRUCT (INT p, l, c);
<a name=A311d></a>
d) PRIO ? BEYOND=5,
   OP BEYOND = (POS a, b) BOOL:
      IF p OF a &lt; p OF b THEN FALSE
      ELIF p OF a &gt; p OF b THEN TRUE
      ELIF l OF a &lt; l OF b THEN FALSE
      ELIF l OF a &gt; l OF b THEN TRUE
      ELSE c OF a &gt; c OF b
      FI;
<a name=A311e></a>
e) MODE ? BFILE = STRUCT (REF BOOK book, REF BFILE next);  
<a name=A311f></a>
f) REF BFILE ? chainbfile := NIL;  
<a name=A311g></a>
g) REF BFILE ? lockedbfile := NIL;
<a name=A311h></a>
h) SEMA ? bfileprotect = (SEMA s; <b>F</b> OF s := PRIM INT := 1; s);
</pre>

<h3>
<a name=A312></a>10.3.1.2. Channnels
</h3>

<p>
{<a name=A312aa></a>aa) A "channel" corresponds to one or more physical devices (e.g., a card reader, a card punch or a line printer, or even to a set up in nuclear physics the 
results of which are collected by the computer) , or to a filestore maintained by the operating system. A channel is a structured value whose fields are routines returning truth values which determine the available methods of access to a book linked via that channel, Since the methods of access to a book may well depend on the book as well as on the channel (e.g., a certain book may have been trapped so that it may be read, but not written to) , most of these properties depend on both the channel and the book. These properties may be examined by use of the environment enquiries provided for files {<a href="#A313ff">10.3.1.3.ff</a>}. Two environment enquiries are provided for channels. These are:  

<p>
&bull; <tt>estab possible</tt>, which returns <tt>true</tt> if another file may be  "established" {<a href="#A314cc">10.3.1.4.cc</a>} on the channel;  

<p>
&bull; <tt>standconv</tt>, which may be used to obtain the default "conversion key" {bb} for the channel, 

<p>
<a name=A312bb></a>bb) A "conversion key" is a value of the mode specified by <tt>CONV</tt> which is used to convert characters to and from the values as stored in "internal" form and as stored in "external" form in a book. It is a structured value comprising a row of structures, each of which contains a value in internal form and its corresponding external value. The implementation may provide additional conversion keys in its <b>library-prelude</b>.  

<p>
<a name=A312cc></a>cc) Three standard channels are provided, with properties as defined below (e,f,g); the implementation may provide additional channels in its <b>library-prelude</b>. The channel number field is provided in order that different channels with otherwise identical possibilities may be distinguished.}   

<a name=A312a></a>
<pre>
a) MODE CHANNEL =
      STRUCT (PROC (REF BOOK) BOOL ? reset, ? set, ? get, ? put, ? bin, ? compress, ? reidf,
         PROC BOOL ? estab, PROC POS ? max pos,
         PROC (REF BOOK) CONV ? standconv, INT ? channel number);
<a name=A312b></a>
b) MODE ? CONV = STRUCT ([1: INT (SKIP) ] STRUCT (CHAR internal, external) <b>F</b>);
<a name=A312c></a>
c) PROC estab possible = (CHANNEL chan) BOOL: estab OF chan;
<a name=A312d></a>
d) PROC standconv = (CHANNEL chan) PROC (REF BOOK) CONV: standconv OF chan; 
<a name=A312e></a>
e) CHANNEL stand in channel = <b>C</b> a channel value whose field selected by 
      'get' is a routine which always returns <tt>true</tt>, and whose other
      fields are some suitable values <b>C</b>;
<a name=A312f></a>
f) CHANNEL stand out channel = <b>C</b> a channel value whose field selected by 
      'put' is a routine which always returns <tt>true</tt>, and whose other
      fields are some suitable values <b>C</b>;
<a name=A312g></a>
g) CHANNEL stand back channel = <b>C</b> a channel value whose fields selected by 
      'set', 'reset', 'get', 'put' and 'bin' are routines which always
      return <tt>true</tt>, and whose other fields are some suitable values <b>C</b>;
</pre>

<h3>
<a name=A313></a>10.3.1.3. Files
</h3>

<p>
{<a name=A313aa></a>aa) A "file" is the means of communication between a <b>particular-program</b> and a book which has been opened on that file via some channel. It is a structured value which includes a reference to the book to which it has been linked {<a href="#A314bb">10.3.1.4.bb</a>} and a separate reference to the <tt>text</tt> of the book. The file also contains information necessary for the transput routines to work with the book, including its current position <tt>cpos</tt> in the <tt>text</tt>, its current  "state" {bb}, its current "format" {<a href="#A34">10.3.4</a>} and the channel on which it has been opened.  

<ul>
<a name=A313bb></a>bb) The "state" of a file is determined by five fields:  
<li><tt>read mood</tt>, which is <tt>true</tt> if the file is being used for input:  
<li><tt>write mood</tt>, which is <tt>true</tt> if the file is being used for output:  
<li><tt>char mood</tt>, which is <tt>true</tt> if the file is being used for character transput;  
<li><tt>bin mood</tt>, which is <tt>true</tt> if the file is being used for binary transput:  
<li><tt>opened</tt>, which is <tt>true</tt> if the file has been linked to a book. 
</ul>

<p>
<a name=A313cc></a>cc) A file includes some "event routines", which are called when certain conditions arise during transput. After opening a file, the event routines provided by default return <tt>false</tt> when called, but the programmer may provide other event routines. Since the fields of a file are not directly accessible to the user, the event routines may be changed by use of the "on routines" (l,m,n,o,p,q,r) . The event routines are always given a reference to the file as a parameter. If the elaboration of an event routine is terminated, then the transput routine which called it can take no further action: otherwise, if it returns <tt>true</tt>, then it is assumed that the condition has been mended in some way, and, if possible, transput continues, but if it returns <tt>false</tt>, then the system continues with its default action. The on routines are:  

<p>
&bull; <tt>on logical file end</tt>. The corresponding event routine is called when, during input from a book or as a result of calling <tt>set</tt>, the logical end of the book is reached (see <a href="#A316dd">10.3.1.6.dd</a>) .  

<p>
Example: The programmer wishes to count the number of integers on his input tape. The file <tt>intape</tt> was opened in a surrounding <b>range</b>. If he writes:
<pre>
BEGIN INT n := 0;
   on logical file end (intape, (REF FILE file) BOOL: GOTO f);
   DO get (intape, LOC INT); n +:= 1 OD;
   f: print (n) 
 END,
</pre>
then the assignment to the field of <tt>intape</tt> violates the scope restriction, since the scope of the routine <tt> (REF FILE file) BOOL: GOTO f</tt> is smaller than the scope of <tt>intape</tt>, so he has to write:
<pre>
BEGIN INT n := 0; FILE auxin := intape;
   on logical file end (auxin, (REF FILE file) BOOL: GOTO f);
   DO get (auxin, LOC INT); n +:= 1 OD;
   f: print (n) 
 END.
</pre>

</p>
&bull; <tt>on physical file end</tt>. The corresponding event routine is called when the current page number of the file exceeds the number of pages in the book and further transput is attempted (see <a href="#A316dd">10.3.1.6.dd</a>) ,  

<p>
&bull; <tt>on page end</tt>. The corresponding event routine is called when the current line number exceeds the number of lines in the current page and further transput is attempted (see <a href="#A316dd">10.3.1.6.dd</a>) .  

<p>
&bull; <tt>on line end</tt>. The corresponding event routine is called when the current character number of the file exceeds the number of characters in the current line and further transput is attempted (see <a href="#A316dd">10.3.1.6.dd</a>) ,  

<p>
Example: The programmer wishes automatically to give a heading at the start of each page on his file <tt>f</tt>:
<pre>
on page end (f, (REF FILE file) BOOL:
     (put (file, (newpage, "page number ", whole (i +:= 1, 0) ,
         newline)); TRUE) 
         &cent; it is assumed that i has been declared elsewhere &cent;) 
</pre>

<p>
&bull; <tt>on char error</tt>. The corresponding event routine is called when a character conversion was unsuccessful or when, during input, a character is read which was not "expected" {<a href="#A3411ll">10.3.4.1.ll</a>}. The event routine is called with a reference to a character suggested as a replacement. The event routine provided by the programmer may assign some character other than the suggested one. If the event routine returns <tt>true</tt>, then that suggested character as possibly modified is used,  

<p>
Example: The programmer wishes to read sums of money punched as <tt>"$123.45"</tt>, <tt>" $23.45"</tt>, <tt>"  $3.45"</tt>, etc.:
<pre>
on char error (stand in, (REF FILE f, REF CHAR sugg) BOOL:
   IF sugg = "0"
   THEN CHAR c; backspace (f); get (f, c);
      (c = "$" | get (f, sugg); TRUE | FALSE) 
   ELSE FALSE
   FI);
INT cents; readf (($3z"."dd$, cents)) 
</pre>

<p>
&bull; <tt>on value error</tt>. The corresponding event routine is called when:   
<ol type=i>
<li> during formatted transput an attempt is made to transput a value under the control of a "picture" with which it is incompatible, or when the number of    "frames" is insufficient. If the routine returns <tt>true</tt>, then the current value and picture are skipped and transput continues; if the routine returns <tt>false</tt>,    then first, on output, the value is output by put, and next <tt>undefined</tt>    is called; 

<li> during input it is impossible to convert a string to a value of some given mode (this would occur if, for example, an attempt were made to read an integer larger than <tt>max int</tt> (<a href="report_5.html#A21c">10.2.1.c</a>)) . 
</ol>

<p>
&bull; <tt>on format end</tt>. The corresponding event routine is called when, during formatted transput, the format is exhausted while some value still remains to be transput. If the routine returns <tt>true</tt>, then <tt>undefined</tt> is called if a new format has not been provided for the file by the routine; otherwise, the current format is repeated.  

<p>
<a name=A313dd></a>dd) The <tt>conv</tt> field of a file is its current conversion key (<a href="#A312bb">10.3.1.2.bb</a>) . After opening a file, a default conversion key is provided. Some other conversion key may be provided by the programmer by means of a call of <tt>make conv</tt> {j}. Note that such a key must have been provided in the <b>library-prelude</b>. 

<p>
<a name=A313ee></a>ee) The routine <tt>make term</tt> is used to associate a string with a file. This string is used when inputting a variable number of characters, any of its characters serving as a terminator. 

<p>
<a name=A313ff></a>ff) The available methods of access to a book which has been opened on a file may be discovered by calls of the following routines (note that the yield of such a call may be a function of both the book and the channel, and of other environmental factors not defined by this Report):  
<br>
&bull; <tt>get possible</tt>, which returns <tt>true</tt> if the file may be used for input;  
<br>
&bull; <tt>put possible</tt>, which returns <tt>true</tt> if the file may be used for output;  
<br>
&bull; <tt>bin possible</tt>, which returns <tt>true</tt> if the file may be used for binary transput;  
<br>
&bull; <tt>compressible</tt>, which returns <tt>true</tt> if lines and pages will be compressed {<a href="#A316aa">10.3.1.6.aa</a>} during output, in which case the book is said to be "compressible";  
<br>
&bull; <tt>reset possible</tt>, which returns <tt>true</tt> if the file may be reset, i.e., its current position set to (1, 1, 1);  
<br>
&bull; <tt>set possible</tt>, which returns <tt>true</tt> if the file may be set, i.e., the current position changed to some specified value; the book is then said to be a  "random access" book and, otherwise, a "sequential access" book:  
<br>
&bull; <tt>reidf possible</tt>, which returns <tt>true</tt> if the <tt>idf</tt> field of the book may be changed:  
<br>
&bull; <tt>chan</tt>, which returns the channel on which the file has been opened {this may be used, for example, by a routine assigned by <tt>on physical file end</tt>, in order to open another file on the same channel}. 

<p>
<a name=A313gg></a>gg) On sequential access books, <tt>undefined</tt> (<a href="#A314a">10.3.1.4.a</a>) is called if binary and character transput is alternated, i.e., after opening or resetting (<a href="#A316j">10.3.1.6.j</a>) , either is possible but, once one has taken place, the other may not until after another reset.  

<p>
<a name=A313hh></a>hh) On sequential access books, output immediately causes the logical end of the book to be moved to the current position (unless both are in the same line); thus input may not follow output without first resetting (<a href="#A316j">10.3.1.6.j</a>) . 

<p>
Example:
<pre>
BEGIN FILE f1, t2; [1: 10000] INT x; INT n := 0;
   open (f1, "", channel 2);
   f2 := f1;
      &cent; now f1 and f2 can be used interchangeably &cent;
   make conv (f1, flexocode); make conv (f2, telexcode);
      &cent; now f1 and f2 use different codes; flexocode and telexcode are 
      defined in the library-prelude for this implementation &cent;
   reset (f1);
      &cent; consequently, f2 is reset too &cent;
   on logical file end (f1, (REF FILE f) BOOL: GOTO done);
   FOR i DO get (f1, x [i]); n := i OD;
      &cent; too bad if there are more than 10000 integers in the input &cent;
done:   
   reset (f1); FOR i TO n DO put (f2, x [i]) OD;
   close (f2) &cent; f1 is now closed too &cent;
END
</pre>
}  

<p>
<a name=A313a></a>
<pre>
a) MODE FILE =
      STRUCT (REF BOOK ? book, UNION (FLEXTEXT, TEXT) ? text, CHANNEL ? chan,
         REF FORMAT ? format, REF INT ? forp,
         REF BOOL ? read mood, ? write mood, ? char mood, ? bin mood, ? opened,
         REF POS ? cpos &cent; current position &cent;,
         STRING ? term &cent; string terminator &cent;,
         CONV ? conv &cent; character conversion key &cent;,
         PROC (REF FILE) BOOL ? logical file mended, ? physical file mended,
         ? page mended, ? line mended, ? format mended,
         ? value error mended,
         PROC (REF FILE, REF CHAR) BOOL ? char error mended);
<a name=A313b></a>
b) PROC get possible = (REF FILE f) BOOL:
      (opened OF f | (get OF chan OF f) (book OF f) | undefined; SKIP); 
<a name=A313c></a>
c) PROC put possible = (REF FILE f) BOOL:
      (opened OF f | (put OF chan OF f) (book OF f) | undefined; SKIP); 
<a name=A313d></a>
d) PROC bin possible = (REF FILE f) BOOL:
      (opened OF f |  (bin OF chan OF f) (book OF f) | undefined; SKIP); 
<a name=A313e></a>
e) PROC compressible = (REF FILE f) BOOL:
      (opened OF f | (compress OF chan OF f) (book OF f) | undefined; SKIP); 
<a name=A313f></a>
f) PROC reset possible = (REF FILE f) BOOL:
      (opened OF f  | (reset OF chan OF f) (book OF f) | undefined; SKIP); 
<a name=A313g></a>
g) PROC set possible = (REF FILE f) BOOL:
      (opened OF f |  (set OF chan OF f) (book OF f) | undefined; SKIP);
<a name=A313h></a>
h) PROC reidf possible = (REF FILE f) BOOL:
      (opened OF f  | (reidf OF chan OF f) (book OF f) | undefined; SKIP);
<a name=A313i></a>
i) PROC chan = (REF FILE f) CHANNEL:
      (opened OF f | chan OF f | undefined; SKIP);
<a name=A313j></a>
j) PROC make conv = (REF FILE f, PROC (REF BOOK) CONV c) VOID:
      (opened OF f | conv OF f := c (book OF f) | undefined);
<a name=A313k></a>
k) PROC make term = (REF FILE f, STRING t) VOID: term OF f := t;
<a name=A313l></a>
l) PROC on logical file end = (REF FILE f, PROC (REF FILE) BOOL p) VOID:
      logical file mended OF f := p; 
<a name=A313m></a>
m) PROC on physical file end = (REF FILE f, PROC ( REF FILE) BOOL p) VOID:
      physical file mended OF f:= p; 
<a name=A313n></a>
n) PROC on page end = (REF FILE f, PROC (REF FILE) BOOL p) VOID:
      page mended OF f := p; 
<a name=A313o></a>
o) PROC on line end = (REF FILE f, PROC (REF FILE) BOOL p) VOID:
      line mended OF f := p; 
<a name=A313p></a>
p) PROC on format end = (REF FILE f, PROC (REF FILE) BOOL p) VOID:
      format mended OF f := p; 
<a name=A313q></a>
q) PROC on value error = (REF FILE f, PROC (REF FILE) BOOL p) VOID:
      value error mended OF f := p; 
<a name=A313r></a>
r) PROC on char error = (REF FILE f, PROC (REF FILE , REF CHAR) BOOL p) VOID: 
      char error mended OF f := p; 
<a name=A313s></a>
s) PROC reidf = (REF FILE f, STRING idf) VOID:
      IF opened OF f AND reidf possible (f) AND idf ok (idf) 
      THEN idf OF book OF f := idf
      FI;
</pre>   

<h3>
<a name=A314></a>10.3.1.4. Opening and closing files
</h3>

<p>
{<a name=A314aa></a>aa) When, during transput, something happens which is left undefined, for example by explicitly calling <tt>undefined</tt> (a) , this does not imply that the elaboration is catastrophically and immediately interrupted (<a href="report_1.html#2143h">2.1.4.3.h</a>) , but only that some sensible action is taken which is not or cannot be described by this Report alone and is generally implementation-dependent.  

<p>
<a name=A314bb></a>bb) A book is "linked" with a file by means of <tt>establish</tt> (b) , <tt>create</tt> (c) or <tt>open</tt> (d) . The linkage may be terminated by means of <tt>close</tt> (n), <tt>lock</tt> (o) or <tt>scratch</tt> (p) .  

<p>
<a name=A314cc></a>cc) When a file is "established" on a channel, then a book is generated {<a href="report_2.html#523">5.2.3</a>}  with a <tt>text</tt> of the given size, the given identification string, with <tt>putting</tt> set to <tt>true</tt>, and the logical end of the book at (1, 1, 1) . An implementation may require (g) that the characters forming the identification string should be taken from a limited set and that the string should be limited in length, it may also prevent two books from having the same string. If the establishing is completed successfully, then the value 0 is returned; otherwise, some nonzero integer is returned (the value of this integer might indicate why the file was not established successfully). When a file is "created" on a channel, then a file is established with a book whose <tt>text</tt> has the default size for the channel and whose identification string is undefined.  

<p>
<a name=A314dd></a>dd) When a file is "opened", then the chain of backfiles is searched for the first book which is such that <tt>match</tt> (h) returns <tt>true</tt>. (The precise method of matching is not defined by this Report and will, in general, be implementation dependent. For example, the string supplied as parameter to open may include a password of some form.) If the end of the chain of backfiles is reached or if a book has been selected, but <tt>putting</tt> of the book yields <tt>true</tt>, or if putting to the book via the channel is possible and the book is already open, then the further elaboration is undefined. If the file is already open, an <tt>UP gremlins</tt> provides an opportunity for an appropriate system action on the book previously linked (in case no other copy of the file remains to preserve that linkage) .  

<p>
<a name=A314ee></a>ee) The routine <tt>associate</tt> may be used to associate a file with a value of the mode specified by either <tt>REF [ ]  CHAR</tt>, <tt>REF [ ] [ ] CHAR</tt> or <tt>REF [ ] [ ] [ ] CHAR</tt>, thus enabling such variables to be used as the book of a file,  

<p>
<a name=A314ff></a>ff) When a file is "closed", its book is attached to the chain of backfiles referenced by <tt>chainbfile</tt>. Some <b>system-task</b> is then activated by means of an <tt>UP gremlins</tt>. (This may reorganize the chain of backfiles, removing this book, or adding further copies of it. It may also cause the book to be output on some external device.)  

<p>
<a name=A314gg></a>gg) When a file is "locked", its book is attached to the chain of backfiles referenced by <tt>lockedbfile</tt>. Some <b>system-task</b>  is then activated by means of an <tt>UP gremlins</tt>. A book which has been locked cannot be re-opened until some subsequent <b>system-task</b> has re-attached the book to the chain of backfiles available for opening.  

<p>
<a name=A314hh></a>hh) When a file is "scratched", some <b>system-task</b> is activated by means of an <tt>UP gremlins</tt>. (This may cause the book linked to the file to be disposed of in some manner.) }  

<pre>
<a name=A314a></a>
a) PROC ? undefined = INT: <b>C</b> some sensible system action yielding an 
      integer to indicate what has been done; it is presumed that the 
      system action may depend on a knowledge of any values 
      accessible {<a href="report_1.html#212c">2.1.2.c</a>} inside the locale of any environ which is older
      than that in which this pseudo-comment is being elaborated 
      {notwithstanding that no ALGOL 68 construct written here could
      access those values} <b>C</b>;
<a name=A314b></a>
b) PROC establish =
      (REF FILE file, STRING idf, CHANNEL chan, INT p, l, c) INT:
      BEGIN
         DOWN bfileprotect;
         PRIM BOOK book :=
            (PRIM FLEX [1 : p] FLEX [1 : l] FLEX [1 : c] CHAR, (1, 1, 1) , idf, TRUE, 1);
         IF file available (chan) AND (put OF chan) (book) 
           AND estab OF chan AND NOT (POS (p, l, c) BEYOND max pos OF chan) 
           AND NOT (POS (1, 1, 1) BEYOND POS (p, l, c)) AND idfok (idf) 
         THEN   
            (opened OF file | UP gremlins | UP bfileprotect);
            file :=
               (book, text OF book, chan, SKIP, SKIP,
                &cent; state: &cent; HEAP BOOL := FALSE, HEAP BOOL := TRUE,
                HEAP BOOL := FALSE, HEAP BOOL := FALSE, HEAP BOOL := TRUE,
                HEAP POS := (1, 1, 1) , "", (standconv OF chan) (book) ,
                &cent; event routines: &cent; <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>,  
                (REF FILE f, REF CHAR a) BOOL: FALSE);
            (NOT bin possible (file) | set char mood (file));
            0
         ELSE UP bfileprotect; undefined
         FI
      END;
<a name=A314c></a>
c) PROC create = (REF FILE file, CHANNEL chan) INT:
      BEGIN POS max pos = max pos OF chan;
         establish (file, SKIP, chan, p OF max pos, l OF max pos, c OF max pos) 
      END;
<a name=A314d></a>
d) PROC open = (REF FILE file, STRING idf, CHANNEL chan) INT:
      BEGIN
         DOWN bfileprotect;
         IF file available (chan) 
         THEN REF REF BFILE bf := chainbfile; BOOL found := FALSE;
            WHILE (REF BFILE (bf) :&ne;: NIL) AND NOT found 
            DO
               IF match (idf, chan, book OF bf) 
               THEN found := TRUE
               ELSE bf := next OF bf
               FI
            OD;
            IF NOT found
            THEN UP bfileprotect; undefined
            ELSE REF BOOK book := book OF bf;
               IF putting OF book OR (put OF chan) (book) AND users OF book &gt; 0
               THEN
                   UP bfileprotect; undefined &cent; in this case opening is
                      inhibited by other users - the system may either
                      wait, or yield nonzero (indicating unsuccessful
                      opening) immediately &cent;
                ELSE
                   users OF book +:= 1;
                   ((put OF chan) (book) | putting OF book := TRUE);
                   REF REF BFILE (bf) := next OF bf; &cent; remove bfile from chain &cent;
                   ( opened OF file | UP gremlins | UP bfileprotect);
                   file :=
                     (book, text OF book, chan, SKIP, SKIP,
                      &cent; state: &cent; HEAP BOOL := FALSE, HEAP BOOL := FALSE,
                      HEAP BOOL := FALSE, HEAP BOOL := FALSE,
                      HEAP BOOL := TRUE,
                      HEAP POS := (1, 1, 1) , "", (standconv OF chan) (book) ,
                      &cent; event routines: &cent; <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>,
                      <tt>false</tt>, (REF FILE f, REF CHAR a) BOOL: FALSE);
                   (NOT bin possible (file) | set char mood (file));
                   (NOT get possible (file) | set write mood (file));
                   (NOT put possible (file) | set read mood (file));
                   0
                FI
            FI
         ELSE UP bfileprotect; undefined
         FI
      END;
<a name=A314e></a>
e) PROC associate =
      (REF FILE file, REF [ ][ ][ ] CHAR sss) VOID:
      IF {{ANW - this fails when UPB sss < 1 or UPB sss[1] < 1}}
         INT p = LWB sss; INT l = LWB sss [p]; INT c = LWB sss[p][l];
         p = 1 AND l = 1 AND c = 1
      THEN
         PROC t = (REF BOOK a) BOOL: TRUE;
         PROC f = (REF BOOK a) BOOL: FALSE;
         CHANNEL chan = (t, t, t, t, f, f, f, BOOL: FALSE,
            POS: (max int, max int, max int) , SKIP, SKIP);
         (opened OF file | DOWN bfileprotect; UP gremlins);
         file :=
            (HEAP BOOK := (SKIP, ( UPB sss + 1, 1, 1) , SKIP, TRUE, 1) , sss, chan,
             SKIP, SKIP,
             &cent; state: &cent; HEAP BOOL := FALSE, HEAP BOOL := FALSE,
             HEAP BOOL := TRUE, HEAP BOOL := FALSE, HEAP BOOL := TRUE,
             HEAP POS := (1, 1, 1) , "", SKIP,
             &cent; event routines: &cent; <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>, <tt>false</tt>,
             (REF FILE f, REF CHAR a) BOOL: FALSE) 
      ELSE undefined
      FI;
<a name=A314f></a>
f) PROC ? file available = (CHANNEL chan) BOOL: 
      <b>C</b> <tt>true</tt> if another file, at this instant of time, may be opened on 
         'chan' and <tt>false</tt> otherwise <b>C</b>;
<a name=A314g></a>
g) PROC ? idf ok = (STRING idf) BOOL: 
      <b>C</b> <tt>true</tt> if 'idf' is acceptable to the implementation as the 
         identification of a new book and <tt>false</tt> otherwise <b>C</b>;
<a name=A314h></a>
h) PROC ? match = (STRING idf, CHANNEL chan, REF BOOK book name) BOOL: 
      <b>C</b> <tt>true</tt> if the book referred to by 'book name' may be identified by
         'idf', and if the book may legitimately be accessed through
         'chan', and <tt>false</tt> otherwise <b>C</b>;
<a name=A314i></a>
i) PROC ? <tt>false</tt> = (REF FILE file) BOOL: FALSE
      &cent; this is included for brevity in 'establish', 'open' and 'associate' &cent;;  
<a name=A314j></a>
j) PROC ? set write mood = (REF FILE f) VOID:
      IF NOT put possible (f) OR
         NOT set possible (f) AND bin mood OF f AND read mood OF f
      THEN undefined
      ELSE REF BOOL (read mood OF f) := FALSE; REF BOOL (write mood OF f) := TRUE
      FI;
<a name=A314k></a>
k) PROC ? set read mood = (REF FILE f) VOID: 
      IF NOT get possible (f) OR
         NOT set possible (f) AND bin mood OF f write mood OF f 
      THEN undefined 
      ELSE REF BOOL (read mood OF f) := TRUE; REF BOOL (write mood OF f) := FALSE 
      FI;
<a name=A314l></a>
l) PROC ? set char mood = (REF FILE f) VOID: 
      IF NOT set possible (f) AND bin mood OF f 
      THEN undefined 
      ELSE REF BOOL (char mood OF f) := TRUE; REF BOOL (bin mood OF f) := FALSE 
      FI;
<a name=A314m></a>
m) PROC ? set bin mood = (REF FILE f) VOID: 
      IF NOT bin possible (f) OR NOT set possible (f) AND char mood OF f 
      THEN undefined 
      ELSE REF BOOL (char mood OF f) := FALSE; REF BOOL (bin mood OF f) := TRUE 
      FI;
<a name=A314n></a>
n) PROC close = (REF FILE file) VOID:
      IF opened OF file 
      THEN
         DOWN bfileprotect;
            REF BOOL (opened OF file) := FALSE;
            REF BOOK book = book OF file;
            putting OF book := FALSE; users OF book -:= 1;
            (text OF file | (FLEXTEXT): chainbfile := 
                PRIM BFILE := (book, chainbfile));
         UP gremlins
      FI;
<a name=A314o></a>
o) PROC lock (REF FILE file) VOID:
      IF opened OF file
      THEN DOWN bfileprotect;
              REF BOOL (opened OF file) := FALSE;
              REF BOOK book = book OF file;
              putting OF book := FALSE; users OF book -:= 1;
              (text OF file | (FLEXTEXT): lockedbfile := PRIM BFILE = (book, lockedbfile));
           UP gremlins
      FI;
<a name=A314p></a>
p) PROC scratch = (REF FILE file) VOID:
      IF opened OF file 
      THEN 
         DOWN bfileprotect;
            REF BOOL (opened OF file) := FALSE;
            putting OF book OF file := FALSE;
            users OF book OF file -:= 1;
         UP gremlins
      FI;
</pre>   

<h3>
<a name=A315></a>10.3.1.5. Position enquiries
</h3>

<p>
{<a name=A315aa></a>aa) The "current position" of a book opened on a given file is the value referred to by the <tt>cpos</tt> field of that file. It is advanced by each transput operation in accordance with the number of characters written or read.  

<p>
If <i>c</i> is the current character number and <i>lb</i> is the length of the current line, then at all times 1 &le; c &le; lb + 1. c = 1 implies that the next transput operation will be to the first character of the line and c =  lb + 1 implies that the line has overflowed and that the next transput operation will call an event routine. If lb = 0, then the line is empty and is therefore always in the overflowed state. Corresponding restrictions apply to the current line and page numbers. Note that, if the page has overflowed, the current line is empty and, if the book has overflowed, the current page and line are both empty (e).  

<p>
<a name=A315bb></a>bb) The user may determine the current position by means of the routines <tt>char number</tt>, <tt>line number</tt> and <tt>page number</tt> (a, b, c) .  

<p>
<a name=A315cc></a>cc) If the current position has overflowed the line, page or book, then it is said to be outside the "physical file" (f, g, h) .  

<p>
<a name=A315dd></a>dd) If, on reading, the current position is at the logical end, then it is said to be outside the "logical file" (i).} 
<p>
{Each routine in this section calls <tt>undefined</tt> if the file is not open on entry.}  

<a name=A315a></a><pre>
a) PROC char number = (REF FILE f) INT: 
      (opened OF f | c OF cpos OF f | undefined); 
<a name=A315b></a>
b) PROC line number = (REF FILE f) INT:
      (opened OF f | l OF cpos OF f | undefined); 
<a name=A315c></a>
c) PROC page number = (REF FILE f) INT:
      (opened OF f | p OF cpos OF f | undefined); 
<a name=A315d></a>
d) PROC ? current pos = (REF FILE f) POS:
      (opened OF f | cpos OF f | undefined; SKIP);
<a name=A315e></a>
e) PROC ? book bounds = (REF FILE f) POS: 
      BEGIN POS cpos = current pos (f); 
            INT p = p OF cpos, l = l OF cpos; 
            CASE text OF f IN 
               (TEXT t1): 
                   (INT pb = UPB t1; 
                    INT lb = (p &le; 0 OR p &gt; pb | 0 | UPB t1 [p]); 
                    INT cb =  (l &le; 0 OR l &gt; lb | 0 | UPB t1[p][l]); 
                    (pb, lb, cb)) , 
               (FLEXTEXT t2): 
                   (INT pb  = UPB t2; 
                    INT lb = (p &le; 0 OR p &gt; pb | 0 | UPB t2[p]); 
                    INT cb = (l &le; 0 OR l &gt; lb | 0 | UPB t2[p][l]); 
                    (pb, lb, cb)) 
            ESAC 
      END; 
<a name=A315f></a>
f) PROC ? line ended = (REF FILE f) BOOL:
      (INT c = c OF current pos (f); c &gt; c OF book bounds (f));
<a name=A315g></a>
g) PROC ? page ended = (REF FILE f) BOOL:
      (INT l = l OF current pos (f); l &gt; l OF book bounds (f));
<a name=A315h></a>
h) PROC ? physical file ended = (REF FILE f) BOOL:
      (INT p = p OF current pos (f); p &gt; p OF book bounds (f));
<a name=A315i></a>
i) PROC ? logical file ended = (REF FILE f) BOOL:
      (lpos OF book OF f BEYOND current pos (f));
</pre>  

<h3>
<a name=A316></a>10.3.1.6. Layout routines
</h3>

<p>
{<a name=A316aa></a>aa) A book input from an external medium by some <b>system-task</b> may contain lines and pages not all of the same length. Contrariwise, the lines and pages of a book which has been established (<a href="#A314cc">10.3.1.4.cc</a>) are all initially of the size specified by the user. However if, during output to a compressible book (<a href="#A313ff">10.3.1.3.ff</a>), <tt>newline</tt> (<tt>newpage</tt>) is called with the current position in the same line (page) as the logical end of the book, then that line (the page containing that line) is shortened to the character number (line number) of the logical end. Thus <tt>print (("abcde", newline)) </tt> could cause the current line to be reduced to 5 characters in length. Note that it is perfectly meaningful for a line to contain no characters and for a page to contain no lines.  

<p>
Although the effect of a channel whose books are both compressible and of random access (<a href="#A313ff">10.3.1.3.ff</a>) is well defined, it is not anticipated that such a combination is likely to occur in actual implementations.  

<p>
<a name=A316bb></a>bb) The routines <tt>space</tt> (a), <tt>newline</tt>  (c) and <tt>newpage</tt> (d) serve to advance the current position to the next character, line or page, respectively. They do not, however, (except as provided in cc below) alter the contents of the positions skipped over. Thus <tt>print (("a", backspace, space)) </tt> has a different effect from <tt>print (("a", backspace, blank)) </tt>.  

<p>
The current position may be altered also by calls of <tt>backspace</tt> (b),  <tt>set char number</tt> (k) and, on appropriate channels, of <tt>set</tt>  (i) and <tt>reset</tt> (j).  

<p>
<a name=A316cc></a>cc) The contents of a newly established book are undefined and both its current position and its logical end are at (1, 1, 1) . As output proceeds, it is filled with characters and the logical end is moved forward accordingly. If, during character output with the current position at the logical end of the book, <tt>space</tt> is called, then a space character is written (similar action being taken in the case of <tt>newline</tt> and <tt>newpage</tt> if the book is not compressible) .  

<p>
A call of <tt>set</tt> which attempts to leave the current position 
beyond the logical end results in a call of <tt>undefined</tt> (a sensible system action might then be to advance the logical end to the current position, or even to the physical end of the book) . There is thus no defined way in which the current position can be made to be beyond the logical end, nor in which any character within the logical file can remain in its initial undefined state.  

<p>
<a name=A316dd></a>dd) A reading or writing operation, or a call of <tt>space</tt>, <tt>newline</tt>, <tt>newpage</tt>, <tt>set</tt> or <tt>set char number</tt>, may bring the current position outside the physical or logical file (<a href="#A315cc">10.3.1.5.cc, dd</a>), but this does not have any immediate consequence. However, before any further transput is attempted, or a further call of <tt>space</tt>,  <tt>newline</tt> or <tt>newpage</tt> (but not of <tt>set</tt> or <tt>set char number</tt>) is made, the current position must be brought to a "good" position. The file is "good" if, on writing (reading) , the current position is not outside the physical (logical) file (<a href="#A315cc">10.3.1.5.cc, dd</a>). The page (line) is "good" if the line number (character number) has not overflowed. The event routine (<a href="#A313cc">10.3.1.3.cc</a>) corresponding to <tt>on logical file end</tt>, <tt>on physical file end</tt>,  <tt>on page end</tt> or <tt>on line end</tt> is therefore called as appropriate. Except in the case of formatted transput (which uses <tt>check pos</tt>, <a href="#A332c">10.3.3.2.c</a>) , the default action, if the event routine returns <tt>false</tt>, is to call, respectively, <tt>undefined</tt>, <tt>undefined</tt>, <tt>newpage</tt> or <tt>newline</tt>. After this (or if <tt>true</tt> is returned) , if the position is still not good, an event routine (not necessarily the same one) is called again.  

<p>
<a name=A316ee></a>ee) The state of the file (<a href="#A313bb">10.3.1.3.bb</a>) controls some effects of the layout routines. If the read/write mood is reading, the effect of <tt>space</tt>, <tt>newline</tt> and <tt>newpage</tt>, upon attempting to pass the logical end, is to call the event routine corresponding to <tt>on logical file end</tt> with default action <tt>undefined</tt>; if it is writing, the effect is to output spaces (or, in bin mood, to write some undefined character) or to compress the current line or page (see cc) . If the read/write mood is not determined on entry to a layout routine,  <tt>undefined</tt> is called. On exit, the read/write mood present on entry is restored.)  

<a name=A316a></a>
<pre>
a) PROC space = (REF FILE f) VOID: 
      IF NOT opened OF f THEN undefined 
      ELSE 
         BOOL reading = (read mood OF f | TRUE |: write mood OF f |  FALSE | undefined; SKIP); 
         (NOT get good line (f, reading) | undefined); 
         REF POS cpos = cpos OF f; 
         IF reading THEN c OF cpos +:= 1 
         ELSE IF logical file ended (f) THEN 
                 IF bin mood OF f THEN 
                    (text OF f | (FLEXTEXT t2): t2[p OF cpos] [l OF cpos] [c OF cpos] := SKIP); 
                    c OF pos +:= 1; 
                    lpos OF book OF f := cpos 
                 ELSE put char (f, " ") 
                 FI 
              ELSE c OF cpos +:= 1 
              FI 
         FI 
      FI;
<a name=A316b></a>
b) PROC backspace = (REF FILE f) VOID: 
      IF NOT opened OF f THEN undefined 
      ELSE REF INT c = c OF cpos OF f; 
         (c&gt;1 | c-:= 1 | undefined)  
      FI;
<a name=A316c></a>
c) PROC newline = (REF FILE f) VOID: 
      IF NOT opened OF f THEN undefined 
      ELSE BOOL reading = (read mood OF f | TRUE |: write mood OF f |  FALSE | undefined; SKIP);
        (get good page (f, reading) | undefined); 
        REF POS cpos = cpos OF f, lpos = lpos OF book OF f; 
        IF p OF cpos = p OF lpos AND l OF cpos =  l OF lpos 
        THEN c OF cpos := c OF lpos; 
           IF reading THEN newline (f) 
           ELSE 
              IF compressible (f) 
              THEN REF INT pl = p OF lpos, ll = l OF lpos; 
                 FLEXTEXT text = (text OF f | (FLEXTEXT t2): t2); 
                 text [pl] [ll] := text [pl] [ll] [ : c OF lpos -  1] 
              ELSE WHILE NOT line ended (f) DO space (f) OD 
              FI; 
              cpos := lpos := (p OF cpos, l OF cpos + 1, 1) 
           FI 
        ELSE cpos := (p OF cpos, l OF cpos + 1, 1) 
        FI 
      FI; 
<a name=A316d></a>
d) PROC newpage = (REF FILE f) VOID: 
      IF NOT opened OF f THEN undefined 
      ELSE 
         BOOL reading = (read mood OF f) | TRUE |: write mood OF f |  FALSE | undefined; SKIP); 
         (get good file (f, reading) | undefined); 
         REF POS cpos = cpos OF f, lpos = lpos OF book OF f; 
         IF p OF cpos = p OF lpos 
         THEN cpos := lpos; 
            IF reading THEN newpage (f) 
            ELSE 
               IF compressible (f) AND l OF lpos &le; l OF book bounds (f) 
               THEN REF INT pl = p OF lpos, ll = l OF lpos; 
                  FLEXTEXT text =  (text OF f | (FLEXTEXT t2): t2); 
                  text[pl] [ll] := text [pl] [ll]t: c OF lpos - 1];  
                  text[pl] := text [pl] [ : (c OF lpos &gt; 1 | ll | ll - 1) ] 
               ELSE WHILE NOT page ended (f) DO newline (f) OD 
               FI; 
               cpos := lpos := (p OF cpos + 1, 1, 1) 
            FI 
         ELSE cpos  := (p OF cpos + 1, 1, 1) 
         FI 
      FI;
</pre>  

<p>
{Each of the following 3 routines either returns <tt>true</tt>, in which case the line, page or file is good (<a href="#A316dd">dd</a>), or it returns <tt>false</tt>, in which case the current position may be outside the logical file or the page number may have overflowed, or it loops until the matter is resolved, or it is terminated by a <b>jump</b>. On exit, the read/write mood is as determined by its <tt>reading</tt> parameter.}  

<a name=A316e></a>
<pre>
e) PROC ? get good line = (REF FILE f, BOOL reading) BOOL: 
      BEGIN BOOL not ended; 
         WHILE not ended := get good page (f, reading); 
            line ended (f) AND not ended 
         DO (NOT (line mended OF f) (f) | set mood (f, reading); newline (f)) OD; 
         not ended 
      END;
<a name=A316f></a>
f) PROC ? get good page = (REF FILE f, BOOL reading) BOOL: 
      BEGIN BOOL not ended; 
         WHILE not ended := get good file (f, reading); 
            page ended (f) AND not ended 
         DO (NOT (page mended OF f) (f) | set mood (f, reading); newpage (f)) OD; 
         not ended 
      END;
<a name=A316g></a>
g) PROC ? get good file = (REF FILE f, BOOL reading) BOOL:
      BEGIN BOOL not ended := TRUE; 
         WHILE set mood (f, reading); 
            not ended AND (reading | logical file ended | physical file ended) (f) 
         DO not ended := (reading  | logical file mended OF f | physical file mended OF f) (f) 
         OD;
         not ended
      END;
<a name=A316h></a>
h) PROC ? set mood = (REF FILE f, BOOL reading) VOID:
      (reading | set read mood (f) | set write mood (f));
<a name=A316i></a>
i) PROC set = (REF FILE f, INT p, l, c) VOID:
      IF NOT opened OF f OR NOT get possible (f) THEN undefined 
      ELSE BOOL reading = (read mood OF f | TRUE  |: write mood OF f | FALSE undefined; SKIP); 
         REF POS cpos = cpos OF f, lpos =  lpos OF book OF f; 
         POS ccpos = cpos; 
         IF (cpos := (p, l, c)) BEYOND lpos 
         THEN cpos := lpos; 
            (NOT (logical file mended OF f) (f) | undefined); 
            set mood (f, reading)  
         ELIF POS bounds = book bounds (f); 
            p &lt; 1 OR p &gt; p OF bounds + 1 
            OR l &lt; 1 OR  l &gt; l OF bounds + 1 
            OR c &lt; 1 OR c &gt; c OF bounds + 1 
         THEN cpos := ccpos; undefined 
         FI 
      FI;
<a name=A316j></a>
j) PROC reset = (REF FILE f) VOID:
      IF NOT opened OF f OR NOT reset possible (f) THEN undefined
      ELSE
         REF BOOL (read mood OF f) := NOT put possible (f);
         REF BOOL (write mood OF f) := NOT get possible (f);
         REF BOOL (char mood OF f) := NOT bin possible (f);
         REF BOOL (bin mood OF f) := FALSE;
         REF POS (cpos OF f)  := (1, 1, 1)
       <var>[[; DOWN bfileprotect; UP gremlins]]</var>
      FI;
<a name=A316k></a>
k) PROC set char number = (REF FILE f, INT c) VOID: 
      IF NOT opened OF f THEN undefined 
      ELSE REF REF POS cpos = cpos OF f; 
         WHILE c OF cpos &ne;  c 
         DO 
            IF c &lt; 1 OR c &gt; c OF book bounds (f) + 1
            THEN undefined
            ELIF c &gt; c OF cpos
            THEN space (f) 
            ELSE backspace (f) 
            FI
         OD
      FI;
</pre>   

<h3>
<a name=A32></a>10.3.2. Transput values
</h3>

<h3>
<a name=A321></a>10.3.2.1. Conversion routines
</h3>

<p>
{The routines <tt>whole</tt>, <tt>fixed</tt> and <tt>float</tt> are intended to be used with the formatless output routines <tt>put</tt>, <tt>print</tt> and <tt>write</tt>  when it is required to have a little extra control over the layout produced. Each of these routines has a <tt>width</tt> parameter whose absolute value specifies the length of the string to be produced by conversion of the arithmetic value <i>V</i> provided. Each of <tt>fixed</tt> and <tt>float</tt>  has an <tt>after</tt> parameter to specify the number of digits required after the decimal point, and an <tt>exp</tt> parameter in <tt>float</tt> specifies the width allowed for the exponent. If <i>V</i> cannot be expressed as a string within the given width, even when the value of <tt>after</tt>, if provided, has been reduced, then a string filled with <tt>errorchar</tt> (<a href="report_5.html#A21t">10.2.1.t</a>) is returned instead. Leading zeroes are replaced by spaces and a sign is normally included. The user can, however, specify that a sign is to be included only for negative values by specifying a negative width. If the width specified is zero, then the shortest possible string into which <i>V</i> can be converted, consistently with the other parameters, is returned. The following examples illustrate some of the possibilities: 
<ul>
<tt>print (whole (i, -4)) </tt> which might print <tt>"   0"</tt>, <tt>"  99"</tt>, <tt>" -99"</tt>, <tt>"9999"</tt> or, if <tt>i</tt> were greater than 9999, <tt>"****"</tt>, where <tt>"*"</tt> is the yield of <tt>errorchar</tt>; 
<br>
<tt>print (whole (i, 4)) </tt> which would print <tt>" +99"</tt> rather than <tt>" 99"</tt>;
<br>
<tt>print (whole (i, 0)) </tt> which might print <tt>"0"</tt>, <tt>"99"</tt>, <tt>"-99"</tt>, <tt>"9999"</tt> or <tt>"99999"</tt>; 
<br>
<tt>print (fixed (x, -6,3)) </tt> which might print <tt>"  2.718"</tt>, <tt>"27.183"</tt> or <tt>"271.83"</tt> (in which one place after the decimal point has 
been sacrificed in order to fit the number in);  
<br>
<tt>print (fixed (x, 0,3)) </tt> which might print <tt>"2.718"</tt>,  <tt>"27.183"</tt> or <tt>"271.823"</tt>; 
<br>
<tt>print (float (x, 9,3,2)) </tt> which might print <tt>"-2.718<sub>10</sub>+0"</tt>, <tt>"+2.718<sub>10</sub>-1"</tt>, or <tt>"+2.72<sub>10</sub>+11"</tt> (in which one place after the decimal point has been sacrificed in order to make room for the unexpectedly large exponent) .}
</ul>  

<a name=A321a></a>
<pre>
a) MODE ? NUMBER= UNION (&laquo;<b><i>L</i></b>  REAL&raquo;, &laquo;<b><i>L</i></b> INT &raquo;);
<a name=A321b></a>
b) PROC whole = (NUMBER v, INT width) STRING:
      CASE v IN  
         &laquo; (<b><i>L</i></b> INT x):
            (INT length := ABS width - (x &lt; <i>L</i> 0 OR width &gt; 0 | 1 | 0) ,
            <b><i>L</i></b> INT n := ABS x;
            IF width = 0 THEN 
               <b><i>L</i></b> INT m := n; length := 0; 
               WHILE m &divide;:= 10; length +:= 1; m &ne; <i>L</i> 0
               DO SKIP OD  
            FI;
            STRING s := subwhole (n, length); 
            IF length = 0 OR char in string (errorchar, LOC INT, s) 
            THEN <var>[[undefined;]]</var> ABS width&times;errorchar
            ELSE (x &lt; <i>L</i> 0 | "-" |:  width &gt; 0 | "+" | "") PLUSTO s; 
                 (width &ne; 0 | (ABS width - UPB s) &times; " " PLUSTO s);
                 s
            FI) &raquo;,  
         &laquo; (<b><i>L</i></b>  REAL x): fixed (x, width, 0) &raquo;
      ESAC;
<a name=A321c></a>
c) PROC fixed (NUMBER v, INT width, after) STRING:
      CASE v IN
         &laquo; (<b><i>L</i></b>  REAL x):
            IF INT length := ABS width - (x &lt; <i>L</i> 0 OR width &gt; 0 | 1 | 0);
               after &ge; 0 AND (length &gt; after OR width = 0) 
            THEN <b><i>L</i></b>  REAL y = ABS x;
                 IF width = 0
                 THEN length := (after = 0 | 1 | 0);
                    WHILE y + <i>L</i> .5 &times; <i>L</i> .1 &uarr; after &ge; <i>L</i>10.0 &uarr; length
                    DO length +:= 1 OD;
                    length +:= (after = 0 | 0 | after +  1) 
                 FI;
                 STRING s := sub fixed (y, length, after);
                 IF NOT char in string (errorchar, LOC INT, s) 
                 THEN (length &gt; UPB s AND y &lt; <b><i>L</i></b> 1.0 | "0" PLUSTO s);
               <var>[[above line should read
                 THEN (length &gt; UPB s AND y + L 0.5 + L .1 ^ after < <b><i>L</i></b> 1.0 | "0" PLUSTO s);]]</var>
                    (x &lt; <i>L</i> 0 |  "-" |: width &gt; 0 | "+" | "") PLUSTO s;
                    (width &ne; 0 | (ABS width - UPB s) &times; " "  PLUSTO s);
                    s
                 ELIF after &gt; 0
                 THEN fixed (v, width, after - 1) 
                 ELSE ABS width &times; errorchar 
                 FI
              ELSE undefined; ABS width &times; errorchar
            <var>[[above line should read
              ELIF undefined; width = 0 THEN errorchar ELSE ABS width &times; errorchar]]</var>
              FI&raquo;,
         &laquo; (<b><i>L</i></b> INT x): fixed (<b><i>L</i></b>  REAL (x) , width, after) &raquo;
         ESAC;
<a name=A321d></a>
d) PROC float = (NUMBER v, INT width, after, exp) STRING:
      CASE v IN 
         &laquo; (<b><i>L</i></b>  REAL x):
            IF INT before = ABS width - ABS exp - (after &ne; 0| after + 1| 0) -2;
               SIGN before + SIGN after &gt; 0
            THEN STRING s, <i>L</i>  REAL y := ABS x, INT p := 0;
                 <i>L</i> standardize (y, before, after, p);
                 s :=  fixed (SIGN x &times; y, SIGN width &times; (ABS width - ABS exp - 1) , after) + "<sub>10</sub>" + whole (p, exp);
                [[above line is debated]]
                 IF exp = 0 OR char in string (errorchar, LOC INT, s) 
                 THEN float (x, width, (after &ne; 0 | after - 1 | 0) , (exp &gt; 0 | exp + 1 |  exp - 1)) 
                 ELSE s 
                 FI
            ELSE undefined; ABS width &times; errorchar
            <var>[[above line should read
              ELIF undefined; width = 0 THEN errorchar ELSE ABS width &times; errorchar]]</var>
            FI&raquo;,
         &laquo; (<b><i>L</i></b> INT x): float (<b><i>L</i></b>  REAL (x) , width, after, exp) &raquo;
      ESAC;
<a name=A321f></a>
e) PROC ? subwhole = (NUMBER v, INT width) STRING: 
         &cent; returns a string of maximum length 'width' containing a 
             decimal representation of the positive integer 'v' &cent;
      CASE v IN 
         &laquo; (<b><i>L</i></b> INT x):
            BEGIN STRING s, <b><i>L</i></b> INT n := x;
               WHILE dig char (<b>S</b> (n MOD <b><i>L</i></b> 10)) PLUSTO s;
                  n &divide;:= <b><i>L</i></b> 10; n &ne; <i>L</i> 0
               DO SKIP OD;
               (UPB s &gt; width | width &times; errorchar | s) 
            END&raquo; 
      ESAC;
<a name=A321f></a>
f) PROC ? subfixed = (NUMBER v, INT width, after) STRING:
         &cent; returns a string of maximum length 'width' containing a 
             rounded decimal representation of the positive real number 
             'v'; if 'after' is greater than zero, this string contains a
             decimal point followed by 'after' digits &cent;
      CASE v IN
         &laquo; (<b><i>L</i></b>  REAL x):
            BEGIN STRING s, INT before := 0;
               <b><i>L</i></b>  REAL y := x +  <i>L</i> .5 &times; <i>L</i> .1 &uarr; after;
               PROC choosedig = (REF <b><i>L</i></b>  REAL y) CHAR:
                  dig char ((INT c :=  <b>S</b> ENTIER (y &times;:= <b><i>L</i></b> 10.0); (c &gt; 9 | c := 9);
                  y -:= <b>K</b> c; c));
               WHILE y &gt; <b><i>L</i></b> 10.0 &uarr; before DO before +:= 1 OD;
               y /:= <b><i>L</i></b> 10.0 &uarr; before;
               TO before DO s PLUSAB choosedig (y) OD;
               (after &gt; 0 | s PLUSAB ".");
               TO after DO s PLUSAB choosedig (y) OD;
               (UPB s &gt; width | width &times; errorchar | s) 
            END&raquo;
      ESAC;
<a name=A321g></a>
g) PROC ? <i>L</i> standardize = (REF <b><i>L</i></b>  REAL y, INT before, after, REF INT p) VOID: 
         &cent; adjusts the value of 'y' so that it may be transput according 
             to the format $n (before) d.n (after) d$ ; 'p' is set so that 
             y &times; 10 &uarr; p is equal to the original value of 'y' &cent; 
      BEGIN 
         <b><i>L</i></b>  REAL g = <b><i>L</i></b> 10.0 &uarr; before; <b><i>L</i></b>  REAL h = g &times; <i>L</i> .1;
         WHILE y &gt; g DO y &times;:= <i>L</i> .1; p +:= 1 OD;
         (y &ne; <i>L</i> 0.0| WHILE y &lt; h DO y &times;:= <b><i>L</i></b> 10.0; p -:= 1 OD);
         (y + <i>L</i> .5 &times; <i>L</i> .1  &uarr; after &ge; g | y := h; p +:= 1) 
      END;
<a name=A321h></a>
h) PROC ? dig char = (INT x) CHAR: "0123456789abcdef"[x  + 1];
<a name=A321i></a>
i) PROC ? string to <i>L</i> int = (STRING s, INT radix, REF <b><i>L</i></b> INT i) BOOL:
         &cent; returns <tt>true</tt> if the absolute value of the result is &le; <i>L</i> max int &cent;
      BEGIN 
         <b><i>L</i></b> INT lr = <b>K</b> radix; BOOL safe := TRUE; 
         <b><i>L</i></b> INT n := <i>L</i> 0, <b><i>L</i></b> INT m = <i>L</i> max int &divide; lr;
         <b><i>L</i></b> INT m1 = <i>L</i> max int - m &times; lr;
         FOR i FROM 2 TO UPB s
         WHILE <b><i>L</i></b> INT dig = <b>K</b> char dig (s[i]);
               safe := n &lt; m OR n = m AND dig &le; m1  
         DO n := n &times; lr + dig OD;
         IF safe THEN i := (s[l] = "+" | n | -n); TRUE ELSE FALSE FI
      END;
<a name=A321j></a>
j) PROC ? string to <i>L</i> real = (STRING s, REF <b><i>L</i></b>  REAL r) BOOL: 
         &cent; returns <tt>true</tt> if the absolute value of the result is &le; max real &cent;
      BEGIN
         INT e := UPB s + 1; 
         char in string ("<sub>10</sub>", e, s);
         INT p := e; char in string (".", p, s); 
         INT j := 1, length = 0, <b><i>L</i></b>  REAL x := <i>L</i> 0.0;
         &cent; skip leading zeroes: &cent;
         FOR i FROM 2 TO e -1
         WHILE s[i] = "0" OR s[i] = "." OR s[i] = " "
         DO j := i OD;
         FOR i FROM j + 1 TO e - 1 WHILE length &lt; <i>L</i> real width
         DO IF s [i] &ne; "."
            THEN x := x &times; <b><i>L</i></b> 10.0 + <b>K</b> char dig (s[j := i]); length +:= 1
            FI &cent; all significant digits converted &cent;
         OD;
         &cent; set preliminary exponent: &cent;
         INT exp := (p &gt; j | p - j - 1 | p - j) , expart  := 0;
         &cent; convert exponent part: &cent;
         BOOL safe := IF e &lt; UPB s THEN string to int (s[e + 1: ], 10, expart) ELSE TRUE FI;
         &cent; prepare a representation of <i>L</i> max real to compare with the 
            <b><i>L</i></b>  REAL value to be delivered: &cent;
         <b><i>L</i></b>  REAL max stag := <i>L</i> max real, INT max exp := 0;
         <i>L</i> standardize (max stag, length, 0, max exp); exp +:= expart;
         IF NOT safe OR (exp &gt; max exp OR exp = max exp AND x &gt; max stag) 
         THEN FALSE 
         ELSE r := (s[1] = "+" | x | -x) &times; <b><i>L</i></b> 10.0 &uarr; exp; TRUE
         FI
      END;
<a name=A321k></a>
k) PROC ? char dig = (CHAR x) INT:
      (x = " " | 0 | INT i; char in string (x, i, "0123456789abcdef"); i - 1);
<a name=A321l></a>
l) PROC char in string = (CHAR c, REF INT i, STRING s) BOOL:
      (BOOL found := FALSE;
       FOR k FROM LWB s TO UPB s WHILE NOT found 
       DO (c = s[k] | i := k; found := TRUE) OD;
       found);
<a name=A321m></a>
m) INT <i>L</i> int width = 
         &cent; the smallest integral value such that '<i>L</i> max int' may be 
            converted without error using the pattern n (<i>L</i> int width) d &cent;
      (INT c := 1;
       WHILE <b><i>L</i></b> 10 &uarr; (c-1) &lt; <i>L</i> .1 &times; <i>L</i> maxint DO c +:= 1  OD;
       c);
<a name=A321n></a>
n) INT <i>L</i> real width = 
         &cent; the smallest integral value such that different strings are 
            produced by conversion of '1.0' and of '1.0 + <i>L</i> small real' using 
            the pattern d.n (<i>L</i> real width - 1) d &cent;
      1 - <b>S</b> ENTIER (<i>L</i> ln (<i>L</i> small real) / <i>L</i> ln (<b><i>L</i></b> 10));
<a name=A321o></a>
o) INT <i>L</i> exp width = 
         &cent; the smallest integral value such that '<i>L</i> max real' may be
            converted without error using the pattern
            d.n (<i>L</i> real width - 1) d e n (<i>L</i> exp width) d &cent;
      1 + <b>S</b> ENTIER (<i>L</i> ln (<i>L</i> ln (<i>L</i> max real) /<i>L</i> ln (<b><i>L</i></b> 10)) /<i>L</i> ln (<b><i>L</i></b> 10));
</pre>

<h3>
<a name=A322></a>10.3.2.2. Transput modes
</h3>

<a name=A322a></a>
<pre>
a) MODE ? SIMPLOUT = UNION (&laquo;<b><i>L</i></b> INT&raquo; , &laquo;<b><i>L</i></b>  REAL&raquo;, &laquo;<b><i>L</i></b> COMPL&raquo;, BOOL,
      &laquo;<b><i>L</i></b> BITS&raquo;, CHAR, [ ]CHAR);
<a name=A322b></a>
b) MODE ? OUTTYPE = <b>C</b> an actual-declarer  specifying a mode united from 
      {<a href="report_1.html#2136a">2.1.3.6.a</a>} a sufficient set of modes none of which is <b>'void'</b> or 
      contains <b>'flexible'</b>, <b>'reference to'</b>, <b>'procedure'</b> or <b>'union of'</b> <b>C</b>;
<a name=A322c></a>
c) MODE ? SIMPLIN = UNION (&laquo;REF <b><i>L</i></b> INT&raquo;, &laquo;REF <i>L</i>  REAL&raquo;, &laquo;REF <b><i>L</i></b> COMPL&raquo;,
      REF BOOL, &laquo;REF <b><i>L</i></b> BITS&raquo;, REF CHAR, REF [ ] CHAR, REF STRING);  
<a name=A322d></a>
d) MODE ? INTYPE = <b>C</b> an actual-declarer specifying a mode united from 
      {<a href="report_1.html#2136a">2.1.3.6.a</a>} <b>'reference to flexible row of character'</b> together with a 
      sufficient set of modes each of which is <b>'reference to'</b> followed by
      a mode which does not contain <b>'flexible'</b>, <b>'reference to'</b>,
      <b>'procedure'</b> or <b>'union of'</b> <b>C</b>;
</pre>

<p>
{See the remarks after <a href="report_5.html#A231">10.2.3.1</a>  concerning the term "sufficient set".}

<h3>
<a name=A323></a>10.3.2.3. Straightening
</h3>

<a name=A323a></a>
<pre>
a) OP ? STRAIGHTOUT = (OUTTYPE x) [ ] SIMPLOUT: 
      <b>C</b> the result of "straightening" 'x' <b>C</b>;  
<a name=A323b></a>
b) OP ? STRAIGHTIN = (INTYPE x) [ ] SIMPLIN:
      <b>C</b> the result of straightening 'x' <b>C</b>;  
</pre>

<p>
<a name=A323c></a>c) The result of "straightening" a given value <i>V</i> is a multiple value <i>W</i> {of one dimension} obtained as follows:  
<br>
&bull; it is required that <i>V</i> (if it is a name) be not nil;  
<br>
&bull; a counter <i>i</i> is set to 0:  
<br>
&bull; <i>V</i> is "traversed" {d} using <i>i</i>
<br>
&bull; <i>W</i> is composed of, a descriptor ((1, i)) and the elements obtained by traversing <i>V</i>:  
<br>
&bull; if <i>V</i> is not (is) a name, then the mode of the result is the mode specified by <tt>[ ] SIMPLOUT</tt> (<tt>[ ] SIMPLIN</tt>) . 
<br>
<a name=A323d></a>d) A value <i>V</i> is "traversed", using a counter <i>i</i>, as follows:   
<br>
If <i>V</i> is (refers to) a value from whose mode that specified by <tt>SIMPLOUT</tt> is united,    
<br>
then    
<ul>
&bull; <i>i</i> is increased by one:    
<br>
&bull; the element of <i>W</i> selected by (<i>i</i>) is <i>V</i>: 
</ul>
otherwise,   
<ul>
<a name=A323cA></a>Case A: <i>V</i> is (refers to) a multiple value (of one dimension) having a descriptor ((l, u)):      
<ul>
&bull; for j = l, ..., u, the element (the subname) of <i>V</i> selected by (j) is traversed using <i>i</i>;
</ul>
<a name=A323cB></a>Case B: <i>V</i> is (refers to) a multiple value (of <i>n</i> dimensions, <i>n &ge; 2</i>) whose descriptor is ((l<sub>1</sub>,u<sub>1</sub>) , ...,      (l<sub>n</sub>,u<sub>n</sub>)) where <i>n &ge; 2</i>:      
<ul>
&bull; for j = l<sub>1</sub>, ... u<sub>1</sub>, the multiple value selected {<a href="report_1.html#2134i">2.1.3.4.i</a>} by (the name generated {<a href="report_1.html#2134j">2.1.3.4.j</a>} by) the trim (j, (l<sub>2</sub>, u<sub>2</sub>, 0) , ..., (l<sub>n</sub>,      u<sub>n</sub>, 0)) is traversed using <i>i</i>;     
</ul>
<a name=A323cC></a>Case C: <i>V</i> is (refers to) a structured value <i>V1</i>:      
<ul>
&bull; the fields (the subnames of <i>V</i> referring to the fields) of <i>V1</i>, taken in order, are traversed using <i>i</i>.
</ul>
</ul>  

<h3>
<a name=A33></a>10.3.3. Formatless transput
</h3>

<p>
{In formatless transput, the elements of a "data list" are transput, one after the other, via a specified file. Each element of the data list is either a layout routine of the mode specified by <tt>PROC (REF FILE) VOID</tt> (<a href="#A316">10.3.1.6</a>) or a value of the mode specified by <tt>OUTTYPE</tt> (on output) or <tt>INTYPE</tt> (on input) . On encountering a layout routine in the data list, that routine is called with the specified file as parameter. Other values in the data list are first straightened (<a href="#A323">10.3.2.3</a>) and the resulting values are then transput via the given file one after the other.  

<p>
Transput normally takes place at the current position but, if there is no room on the current line (on output) or if a readable value is not present there (on input) , then first, the event routine corresponding to <tt>on line end</tt>  (or, where appropriate, to <tt>on page end</tt>, <tt>on physical file end</tt>  or <tt>on logical file end</tt>) is called, and next, if this returns <b><tt>false</tt></b>, the next "good" character position of the book is found, viz., the first character position of the next nonempty line.}

<h3>
<a name=A331></a>10.3.3.1. Formatless output
</h3>

<p>
{For formatless output,  <tt>put</tt> (a) and <tt>print</tt> (or <tt>write</tt>) (<a href="#A51d">10.5.1.d</a>) may be used. Each straightened value <i>V</i> from the data list is output as follows:  

<p>
<a name=A331aa></a>aa) If the mode of <i>V</i> is specified by <tt><b><i>L</i></b> INT </tt>, then first, if there is not enough room for <tt><i>L</i> int width + 2</tt>  characters on the remainder of the current line, a good position is found on a subsequent line (see <a href="#A33">10.3.3</a>): next, when not at the beginning of a line, a space is given and then <i>V</i>  is output as if under the control of the <b>picture</b> <tt>n (<i>L</i> int width -  1) z + d</tt>.  

<p>
<a name=A331bb></a>bb) If the mode of <i>V</i> is specified by <tt><i>L</i>  REAL</tt> , then first, if there is not enough room for <tt><i>L</i> real width + <i>L</i>  exp width + 5</tt> characters on the current line, then a good position is found on a subsequent line: next, when not at the beginning of a line, a space is given and then <i>V</i> is output as if under control of the <b>picture</b>  
<br>
<tt>+d.n (<i>L</i> real width - 1) den (<i>L</i> exp width - 1) z+d.</tt>  

<p>
<a name=A331cc></a>cc) If the mode of <i>V</i> is specified by <tt><b><i>L</i></b> COMPL</tt> , then first, if there is not enough room for <tt>2 &times; (<i>L</i> real width  + <i>L</i> exp width) + 11</tt> characters on the current line, then a good position is found on a subsequent line: next, when not at the beginning of a line, a space is given and then <i>V</i> is output as if under control of the <b>picture</b>  
<br>
<tt>+d.n (<i>L</i> real width - 1) den (<i>L</i> exp width - 1) z+d" "i+d.n (<i>L</i> real width  - 1) den (<i>L</i> exp width - 1) z+d .</tt>  

<p>
<a name=A331dd></a>dd) If the mode of <i>V</i> is specified by <tt>BOOL</tt>, then first, if the current line is full, a good position is found on a subsequent line: next, if <i>V</i> is <tt>true</tt> (<tt>false</tt>) , the character yielded by <tt>flip</tt> (<tt>flop</tt>) is output (with no intervening space) .  

<p>
<a name=A331ee></a>ee) If the mode of <i>V</i> is specified by <tt><b><i>L</i></b> BITS </tt>, then the elements of the only field of <i>V</i> are output (as in dd) one after the other (with no intervening spaces, and with new lines being taken as required) ,  

<p>
<a name=A331ff></a>ff) If the mode of <i>V</i> is specified by <tt>CHAR</tt>, then first, if the current line is full, a good position is found on a subsequent line: next <i>V</i> is output (with no intervening space) .  

<p>
<a name=A331gg></a>gg) If the mode of <i>V</i> is specified by <tt>[ ] CHAR</tt>, then the elements of <i>
V</i> are output (as in ff) one after the other (with no intervening spaces, and with new lines being taken as required) .}   

<a name=A331a></a>
<pre>
a) PROC put = (REF FILE f, [ ] UNION (OUTTYPE, PROC (REF FILE) VOID) x) VOID:
      IF opened OF f THEN
         FOR i TO UPB x
         DO CASE set write mood (f); set char mood (f); x[i] IN
            (PROC (REF FILE) VOID pf): pf (f) ,
            (OUTTYPE ot):
            BEGIN [ ] SIMPLOUT y = STRAIGHTOUT ot;
                  &laquo;PROC <i>L</i> real conv = (<b><i>L</i></b>  REAL r) STRING:
                     float (r, <i>L</i> real width + <i>L</i> exp width + 4, 
                        <i>L</i> real width - 1, <i>L</i>  exp width + 1)&raquo;;
                  FOR j TO UPB y 
                  DO CASE y[j] IN
                     (UNION (NUMBER, &laquo;<b><i>L</i></b> COMPL&raquo;)  nc):
                        BEGIN STRING s :=
                           CASE nc IN
                              &laquo; (<b><i>L</i></b> INT k): whole (k, <i>L</i> int width + 1) &raquo;,
                              &laquo; (<b><i>L</i></b>  REAL r): <i>L</i> real conv (r) &raquo;,
                              &laquo; (<b><i>L</i></b> COMPL z): <i>L</i> real conv (RE z) + " I" + <i>L</i> real conv (IM z) &raquo;
                           ESAC;
                           REF REF POS cpos = cpos OF f, INT n = UPB s; 
                           WHILE nextpos (f);
                                 (n &gt; c OF book bounds (f) | undefined);
                                 c OF cpos + (c OF cpos = 1  | n | n + 1) &gt; c OF book bounds (f) + 1
                           DO (NOT (line mended OF f) (f) | put (f, newline));
                              set write mood (f) 
                           OD;
                           (c OF cpos &ne; 1 | " " PLUSTO s);
                           FOR k TO UPB s DO put char (f, s[k]) OD
                        END &cent; numeric &cent;,
                     (BOOL b): (next pos (f); put char (f, (b | flip | flop))) ,
                     &laquo; (<b><i>L</i></b> BITS lb):
                        FOR k TO <i>L</i> bits width
                        DO put (f, (<i>L</i>  <b>F</b> OF lb) [k]) OD&raquo;,
                     (CHAR k): (nextpos (f); put char (f, k)) ,
                     ([ ] CHAR ss):
                        FOR k FROM LWB ss TO UPB ss 
                        DO next pos (f); put char (f, ss[k]) OD
                     ESAC
                  OD
            END
            ESAC
         OD
      ELSE undefined
      FI;
<a name=A331b></a>
b) PROC ? put char = (REF FILE f, CHAR char) VOID:
      IF opened OF f AND NOT line ended (f) 
      THEN REF POS cpos = cpos OF f, lpos = lpos OF book OF f;
         set char mood (f); set write mood (f);
         REF INT p = p OF cpos, l = l OF cpos, c  = c OF cpos;
         CHAR k; BOOL found := FALSE;
         CASE text OF f IN
           (TEXT): (k := char; found := TRUE) ,
           (FLEXTEXT):
              FOR i TO UPB <b>F</b> OF conv OF f WHILE NOT found
              DO STRUCT (CHAR internal, external) key = (<b>F</b> OF conv OF f) [i];
                 (internal OF key = char | k := external OF key; found := TRUE) 
              OD
         ESAC;
         IF found THEN 
            CASE text OF f IN
               (TEXT t1): t1 [p] [l] [c] := k,
               (FLEXTEXT t2): t2[p] [l] [c] := k
            ESAC;
            c +:= 1;
            IF cpos BEYOND lpos THEN lpos :=  cpos
            ELIF NOT set possible (f) AND POS (p OF lpos, l OF lpos, 1) BEYOND cpos
            THEN lpos :=  cpos; 
               (compressible (f) | 
                  <b>C</b> the size of the line and page containing the logical
                     end of the book and of all subsequent lines and
                     pages may be increased {e.g., to the sizes with
                     which the book was originally established 
                     {<a href="#A314cc">10.3.1.4.cc</a>} or to the sizes implied by maxpos OF
                     chan OF f} <b>C</b>) 
            FI
         ELSE k := " ";
              IF NOT (char error mended OF f) (f, k) 
              THEN undefined; k := " "
              FI;
              check pos (f); put char (f, k) 
         FI
      ELSE undefined
      FI &cent; write mood is still set &cent; ;
<a name=A331c></a>
c) PROC ? next pos = (REF FILE f) VOID:
      (NOT get good line (f, read mood OF f) | undefined) 
         &cent; the line is now good {<a href="#A316dd">10.3.1.6.dd</a>} and the read/write mood is
         as on entry &cent; ;
</pre>

<h3>
<a name=A332></a>10.3.3.2. Formatless input
</h3>
 
<p>
{For formatless input,  <tt>get</tt> (a) and <tt>read</tt> (<a href="#A51e">10.5.1.e</a>) may be used. Values from the book are assigned to each straightened name <i>N</i> from the data list as follows:  

<p>
<a name=A332aa></a>aa) If the mode of <i>N</i> is specified by <tt>REF <i>L</i>  INT</tt> , then first, the book is searched for the first character that is not a space (finding good positions on subsequent lines as necessary); next, the largest string is read from the book that could be "indited" (<a href="#A3411kk">10.3.4.1.1.kk</a>) under the control of some <b>picture</b> of the form <tt>+n (k1) " "n (k2) dd</tt>  or <tt>n (k2) dd</tt> (where <tt>k1</tt> and <tt>k2</tt> yield arbitrary nonnegative integers): this string is converted to an integer and assigned to <i>N</i>; if the conversion is unsuccessful, the event routine corresponding to <tt>on value error</tt> is called.  

<p>
<a name=A332bb></a>bb) If the mode of <i>N</i> is specified by <tt>REF <i>L</i>  REAL</tt> , then first, the book is searched for the first character that is not a space (finding good positions on subsequent lines as necessary); next, the largest string is read from the book that could be indited under the control of some <b>picture</b> of the form <tt>+n (k1) " " n (k2) d</tt> or <tt>n (k2) d</tt>  followed by <tt>.n (k3) d d</tt> or by <tt>ds.</tt>, possibly followed again by <tt>e n (k4) " "+n (k5) " " n (k6) d d</tt> or by <tt>e n (k5) " "n (k6) d d</tt>;  this string is converted to a real number and assigned to <i>N</i>; if the conversion is unsuccessful, the event routine corresponding to <tt>on value error</tt> is called.  

<p>
<a name=A332cc></a>cc) If the mode of <i>N</i> is specified by <tt>REF <b><i>L</i></b> COMPL</tt> , then first, a real number is input (as in bb) and assigned to the first subname of <i>N</i>; next, the book is searched for the first character that is not a space; next, a character is input and, if it is not <tt>"I"</tt>  or <tt>"i"</tt>, then the event routine corresponding to <tt>on char error</tt>  (<a href="#A313cc">10.3.1.3.cc</a>) is called, the suggestion being <tt>"I"</tt>; finally, a real number is input and assigned to the second subname of <i>N</i>.  

<p>
<a name=A332dd></a>dd) If the mode of <i>N</i> is specified by <tt>REF BOOL</tt>, then first, the book is searched for the first character that is not a space (finding good positions on subsequent lines as necessary); next, a character is read: if this character is the same as that yielded by <tt>flip</tt> (<tt>flop</tt>) , then <tt>true</tt> (<tt>false</tt>) is assigned to <i>N</i>;  otherwise, the event routine corresponding to <tt>on char error</tt> is called, the suggestion being <tt>flop</tt>.  

<p>
<a name=A332ee></a>ee) If the mode of <i>N</i> is specified by <tt>REF <i>L</i>  BITS</tt> , then input takes place (as in dd) to the subnames of <i>N</i> one after the other (with new lines being taken as required) .  

<p>
<a name=A332ff></a>ff) If the mode of <i>N</i> is specified by <tt>REF CHAR</tt>, then first, if the current line is exhausted, a good position is found on a subsequent line; next, a character is read and assigned to <i>N</i>.  

<p>
<a name=A332gg></a>gg) If the mode of <i>N</i> is specified by <tt>REF [ ]  CHAR</tt>, then input takes place (as in ff) to the subnames of <i>N</i> one after the other (with new lines being taken as required) .  

<p>
<a name=A332hh></a>hh) If the mode of <i>N</i> is specified by <tt>REF STRING</tt>, then characters are read until either 
<ol type=i>   
<li>a character is encountered which is contained in the string associated with the file by a call of the routine <tt>make term</tt>, or 
<li>the current line is exhausted, whereupon the event routine corresponding to <tt>on line end</tt> (or, where appropriate, to <tt>on page end</tt>,    <tt>on physical file end</tt> or <tt>on logical file end</tt>) is called; if the event routine moves the current position to a good position (see <a href="#A33">10.3.3</a>) , then input of characters is resumed. 
</ol>
The string consisting of the characters read is assigned to <i>N</i> (note that, if the current line has already been exhausted, or if the current position is at the start of an empty line or outside the logical file, then an empty string is assigned to <i>N</i>) .}  

<a name=A332a></a>
<pre>
a) PROC get = (REF FILE f, [ ] UNION (INTYPE, PROC (REF FILE) VOID) x) VOID:
      IF opened OF f THEN
      FOR i TO UPB x 
      DO CASE set read mood (f);  set char mood (f); x[i] IN
         (PROC (REF FILE) VOID pf): pf (f) ,
         (INTYPE it) :
         BEGIN
            [ ] SIMPLIN y = STRAIGHTIN it; CHAR k; BOOL k empty;
            OP ? = (STRING s) BOOL: &cent; <tt>true</tt> if the next character, if any, in the current line
                                    is contained in 's' (the character is assigned to 'k') 
                                    and <tt>false</tt> otherwise &cent;
               IF k empty AND (line ended (f) OR  logical file ended (f)) 
               THEN FALSE
               ELSE (k empty | get char (f, k));
                  k empty := char in string (k, LOC INT, s) 
               FI;
            OP ? = (CHAR c) BOOL: ? STRING (c);
            PRIO ! = 8;
            OP !  = (STRING s, CHAR c) CHAR: 
                     &cent; expects a character contained in 's'; if the character
                     read is not in 's', the event routine corresponding to
                     'on char error'  is called with the suggestion 'c' &cent;
               IF (k empty | check pos (f); get char (f, k));
                  k empty := TRUE;
                  char in string (k, LOC INT, s) 
               THEN k 
               ELSE CHAR sugg := c; 
                  IF (char error mended OF f) (f, sugg) THEN
                     (char in string (sugg, LOC INT, s) | sugg | undefined; c) 
                  ELSE undefined; c
                  FI;
                  set read mood (f) 
                <var>[[above five lines should read
                  CHAR cc = IF (char error mended OF f) (f, sugg) THEN
                    (char in string (sugg, LOC INT, s) | sugg | undefined; c) 
                  ELSE undefined; c
                  FI;
                  set read mood (f); cc]]</var>
               FI;
            OP ! =  (CHAR s, c) CHAR: STRING (s) ! c;
            PROC skip initial spaces = VOID:
               WHILE (k empty |  next pos (f)); ? " " DO SKIP OD;
            PROC skip spaces = VOID: 
               WHILE ? " " DO SKIP OD;
            PROC read dig = STRING:
               (STRING t := "0123456789" ! "0";
                WHILE ? "0123456789" DO t PLUSAB k OD; t);
            PROC read sign = char:
               (CHAR t = (skipspaces; ? "+-" | k | "+");
                skip spaces; t);
            PROC read num = STRING:
               (CHAR t = read sign; t + read dig);
            PROC read real = STRING: 
               (STRING t := read sign;
               (NOT ? "." | t PLUSAB read dig | k empty := FALSE);
               (? "." | t PLUSAB "." + read dig);
               (? "<sub>10</sub>\e" | t PLUSAB "<sub>10</sub>" + read num); t);

            FOR j TO UPB y 
            DO BOOL incomp := FALSE;  k empty := TRUE;
               CASE y[j] IN 
               &laquo; (REF <b><i>L</i></b> INT ii) :
                  (skip initial spaces;
                     incomp  := NOT string to <i>L</i> int (read num, 10, ii)) &raquo;,
               &laquo; (REF <b><i>L</i></b>  REAL rr) :
                  (skip initial spaces; 
                     incomp := NOT string to <i>L</i> real (read real, rr)) &raquo;,
               &laquo; (REF <b><i>L</i></b> COMPL zz) :
                  (skip initial spaces;
                     incomp := NOT string to <i>L</i> real (read real, re OF zz);
                     skip spaces; "iI" ! "I;";
                     incomp := incomp OR string to <i>L</i> real (read real, im OF zz)) &raquo;
               (REF BOOL bb) :
                    (skip initial spaces;
                     bb := (flip + flop) ! flop = flip) ,
               &laquo; (REF <b><i>L</i></b> BITS lb) :
                  FOR i TO <i>L</i> bits width
                  DO get (f, (<i>L</i> <b>F</b> OF lb) [i]) OD&raquo;,
               (REF CHAR cc): (next pos (f); get char (f, cc)) ,
               (REF [ ]CHAR ss) :
                  FOR i FROM LWB ss TO UPB ss
                  DO next pos (f); get char (f, ss [i]) OD,
               (REF STRING ss): 
                  BEGIN STRING t;
                     WHILE check pos (f);
                        IF line ended (f) OR logical file ended (f) 
                        THEN FALSE
                        ELSE get char (f, k);
                             k empty := NOT char in string (k, LOC INT, term OF f) 
                        FI
                     DO t PLUSAB k OD;
                     ss := t 
                  END
               ESAC; 
               (NOT k empty | backspace (f));
               IF incomp 
               THEN (NOT (value error mended OF f) (f) | undefined);
                  set read mood (f) 
               FI
            OD 
         END 
         ESAC 
      OD      
      ELSE undefined 
      FI; 
<a name=A332b></a>
b) PROC ? get char = (REF FILE f, REF CHAR char) VOID:
      IF opened OF f AND NOT line ended (f) AND NOT logical file ended (f) 
      THEN REF POS cpos = cpos OF f;
         set char mood (f); set read mood (f);
         INT p = p OF cpos, l = l OF cpos, c = c OF cpos;
         c OF cpos +:= 1;
         char := CASE text OF f IN
            (TEXT t1): t1[p][l][c],
            (FLEXTEXT t2) :
               (CHAR k := t2[p][l][c];
                BOOL found := FALSE;
                FOR i TO UPB <b>F</b> OF conv OF f WHILE NOT found
                DO STRUCT (CHAR internal, external) key = (<b>F</b> OF conv OF f) [i];
                  (external OF key = k | k := internal OF key; found := TRUE) 
                OD;
                IF found THEN k
                ELSE k:= " ";
                     IF (char error mended OF f) (f, k) 
                     THEN k
                     ELSE undefined; " "
                     FI; set read mood (f);
                FI) 
            ESAC
      ELSE undefined
      FI &cent; read mood is still set &cent; ;
<a name=A332c></a>
c) PROC ? check pos = (REF FILE f) VOID:
      BEGIN BOOL reading = read mood OF f;
          BOOL not ended := TRUE;
          WHILE not ended := not ended AND get good page (f, reading);
                line ended (f) AND not ended
          DO not ended := (line mended OF f) (f) OD
      END;
</pre>  

<p>
{The routine <tt>check pos</tt> is used in formatted transput before each call of <tt>put char</tt> or <tt>get char</tt>. If the position is not good (<a href="#A316dd">10.3.1.6.dd</a>), it calls the appropriate event routine, and may call further event routines if <tt>true</tt> is returned. If the event routine corresponding to <tt>on page end</tt>  returns <tt>false</tt>, <tt>newpage</tt> is called but, if any other event routine returns <tt>false</tt>, no default action is taken and no more event routines are called. On exit, the read/write mood is as on entry, but the current position may not be good, in which case <tt>undefined</tt> will be called in the following <tt>put char</tt> or <tt>get char</tt>. However, <tt>check pos</tt> is also called when getting strings (<a href="#A332hh">hh</a>), in which case the string is then terminated if the current position is not good.}  

<h3>
<a name=A34></a>10.3.4. Format texts
</h3>
 
<p>
{In formatted transput, each straightened value from a data list (cf. <a href="#A33">10.3.3</a>) is matched against a constituent <b>picture</b> of a <b>format-text</b>  provided by the user. A <b>picture</b> specifies how a value is to be converted to or from a sequence of characters and prescribes the layout of those characters in the book. Features which may be specified include the number of digits, the position of the decimal point and of the sign, if any, suppression of zeroes and the insertion of arbitrary strings. For example, using the <b>picture</b> <tt>-d.3d " " 3d " " e z+d</tt>, the value <i>1234.567</i> would be transput as the string <tt>" 1.234 567<sub>10</sub>+3"</tt>.  

<p>
A "format" is a structured value (i.e., an internal object) of mode <b>'FORMAT'</b>, which mirrors the hierarchical structure of a <b>format-text</b> (which is an external object) . In this section are given the syntax of <b>format-texts</b> and the semantics for obtaining their corresponding formats. The actual formatted transput is performed by the routines given in section <a href="#A35">10.3.5</a>  but, for convenience, a description of their operation is given here, in association with the corresponding syntax.}

<h3>
<a name=A341></a>10.3.4.1. Collections and pictures
</h3>

<h3> 
<a name=A3411></a>10.3.4.1.1. Syntax
</h3> 

<p>
{The following <b>mode-declarations</b> (taken from <a href="#A35a">10.3.5.a</a>) are reflected in the metaproduction rules A to K below.  


<a name=A3411A></a>
<pre>
A) MODE FORMAT = STRUCT (FLEX [1 : 0] PIECE <b>F</b>);
<a name=A3411B></a>
B) MODE PIECE = STRUCT (INT cp, count, bp, FLEX [1: 0] COLLECTION c);
<a name=A3411C></a>
C) MODE COLLECTION =UNION (PICTURE, COLLITEM);
<a name=A3411D></a>
D) MODE COLLITEM = STRUCT (INSERTION i1, PROC INT rep, INT p, INSERTION i2);
<a name=A3411E></a>
E) MODE INSERTION = FLEX [1 : 0] STRUCT (PROC INT rep, UNION (STRING, CHAR) sa);
<a name=A3411F></a>
F) MODE PICTURE = STRUCT (UNION (PATTERN, CPATTERN, FPATTERN, GPATTERN, VOID) p, INSERTION i);
<a name=A3411G></a>
G) MODE PATTERN = STRUCT (INT type, FLEX [1 : 0] FRAME frames);
<a name=A3411H></a>
H) MODE FRAME = STRUCT (INSERTION i, PROC INT rep, BOOL supp, CHAR marker);
<a name=A3411I></a>
I) MODE CPATTERN = STRUCT (INSERTION i, INT type, FLEX  [1 : 0] INSERTION c);
<a name=A3411J></a>
J) MODE FPATTERN = STRUCT (INSERTION i, PROC FORMAT pf);
<a name=A3411K></a>
K) MODE GPATTERN = STRUCT (INSERTION i, FLEX [1 : 0]  PROC INT spec);} 
</pre> 

<p>
<a name=A3411A></a>A) <b>FORMAT :: structured with row of PIECE field letter aleph mode.</b> 
<br>
<a name=A3411B></a>B) <b>PIECE :: structured with integral field letter c letter p integral field letter c letter o letter u letter n letter t integral field letter b letter p row of COLLECTION field letter c mode.</b> 
<br>
<a name=A3411C></a>C) <b>COLLECTION :: union of PICTURE COLLITEM mode.</b> 
<br>
<a name=A3411D></a>D) <b>COLLITEM :: structured with INSERTION field letter i digit one procedure yielding integral field letter r letter e letter p integral field letter p INSERTION field letter i digit two mode.</b> 
<br>
<a name=A3411E></a>E) <b>INSERTION :: row of structured with procedure yielding integral field letter r letter e letter p union of row of character character mode field letter s letter a mode.</b> 
<br>
<a name=A3411F></a>F) <b>PICTURE :: structured with union of PATTERN CPATTERN FPATTERN GPATTERN void mode field letter p INSERTION field letter i mode.</b> 
<br>
<a name=A3411G></a>G) <b>PATTERN :: structured with integral field letter t letter y letter p letter e row of FRAME field letter f letter r letter a letter m letter e letter s mode.</b> 
<br>
<a name=A3411H></a>H) <b>FRAME :: structured with INSERTION field letter i procedure yielding integral field letter r letter e letter p boolean field letter s letter u letter p letter p character field letter m letter a letter r letter k letter e letter r mode.</b> 
<br>
<a name=A3411I></a>I) <b>CPATTERN :: structured with INSERTION field letter i integral field letter t letter y letter p letter e row of INSERTION field letter c mode.</b> 
<br>
<a name=A3411J></a>J) <b>FPATTERN :: structured with INSERTION field letter i procedure yielding FIVMAT field letter p letter f mode.</b> 
<br>
<a name=A3411K></a>K) <b>GPATTERN :: structured with INSERTION field letter i row of procedure yielding integral field letter s letter p letter e letter c mode.</b> 
<br>
<a name=A3411L></a>L) <b>FIVMAT :: mui definition of structured with row of structured with integral field letter c letter p integral field letter c letter o letter u letter n letter t integral field letter b letter p row of union of structured with union of PATTERN CPATTERN structured with INSERTION field letter i procedure yielding mui application field letter p letter f mode GPATTERN void mode field letter p INSERTION field letter i mode COLLITEM mode field letter c mode field letter aleph mode.</b> {<b>'FIVMAT'</b> is equivalent (<a href="report_1.html#2112a">2.1.1.2.a</a>) to <b>'FORMAT'</b>.}  
<br>
<a name=A3411M></a>M) <b>MARK :: sign ; point ; exponent ; complex ;  boolean.</b> 
<br>
<a name=A3411N></a>N) <b>COMARK :: zero ; digit ; character.</b> 
<br>
<a name=A3411O></a>O) <b>UNSUPPRESSETY :: unsuppressible ; EMPTY.</b> 
<br>
<a name=A3411P></a>P) <b>TYPE :: integral ; real ; boolean ; complex ; string  ; bits ; integral choice ; boolean choice ; format ; general.</b> 
<br>
<a name=A3411a></a>a) <b>FORMAT NEST format text</b> {<a href="report_2.html#51D">5D</a>} <b>:  formatter</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST collection</b> {b}<b> list, formatter</b> {<a href="report_4.html#941f">94f</a>}  <b>token.</b> 
<br>
<a name=A3411b></a>b) <b>NEST collection</b> {a,b}<b> : pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option, NEST picture</b> {c}<b>; pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option, NEST insertion</b> {d}<b>, NEST replicator</b> {g}<b>, NEST collection</b> {b}<b> list brief pack, pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option, NEST insertion</b> {d}<b>.</b> 
<br>
<a name=A3411c></a>c) <b>NEST picture</b> {b}<b> : NEST TYPE pattern</b> {<a href="#A3421a">A342a</a>  ,<a href="#A3431a">A343a</a>,<a href="#A3441a">A344a</a>,<a href="#A3451a">A345a</a>,<a href="#A3461a">A346a</a>,<a href="#A3471a">A347a</a>,<a href="#A3481a">A348a,b</a>,<a href="#A3491a">A349a</a>,<a href="#A34A1a">A34Aa</a>}  <b>option, NEST insertion</b> {d}<b>.</b> 
<br>
<a name=A3411d></a>d) <b>NEST insertion</b> {b,c,j,k,<a href="#A3471b">A347b</a>  ,<a href="#A3431a">A343a,b</a>,<a href="#A3491a">A349a</a>,<a href="#A34A1a">A34Aa</a>}  <b>: NEST literal</b> {i}<b> option, NEST alignment</b> {e}<b> sequence option.</b> 
<br>
<a name=A3411e></a>e) <b>NEST alignment</b> {d}<b> : NEST replicator</b> {g}<b>, alignment code</b> {f}<b>, NEST literal</b> {i}<b>  option.</b> 
<br>
<a name=A3411f></a>f) <b>alignment code</b> {e}<b> : letter k</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; letter x</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; letter y</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; letter l</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; letter p</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; letter q</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b> 
<br>
<a name=A3411g></a>g) <b>NEST replicator</b> {b,e,i,k}<b> : NEST unsuppressible replicator</b> {h}<b> option.</b> 
<br>
<a name=A3411h></a>h) <b>NEST unsuppressible replicator</b> {g,i}<b> : fixed point numeral</b> {<a href="report_4.html#8111b">811b</a>}  <b>; letter n</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol, meek integral NEST ENCLOSED clause</b> {<a href="report_2.html#311a">31a</a> ,<a href="report_2.html#341a">34a</a>,-}<b>, pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option.</b> 
<br>
<a name=A3411i></a>i) <b>NEST UNSUPPRESSETY literal</b> {d,e,i,<a href="#A3481c">A348c</a>} <b>: NEST UNSUPPRESSETY replicator</b> {g,h}<b>, strong row of character NEST denoter</b> {<a href="report_4.html#801a">80a</a>}  <b>coercee</b> {<a href="report_3.html#611a">61a</a>}  <b>, NEST unsuppressible literal</b> {i}<b> option.</b> 
<br>
<a name=A3411j></a>j) <b>NEST UNSUPPRESSETY MARK frame</b> {<a href="#A3421c">A342c</a>  ,<a href="#A3431b">A343b,c</a>,<a href="#A3441a">A344a</a>,<a href="#A3451a">A345a</a>}  <b>: NEST insertion</b> {d}<b>, 
UNSUPPRESSETY suppression</b><b> {l}</b><b>, MARK marker</b> {<a href="#A3421e">A342e</a>  ,<a href="#A3431d">A343d,e</a>,<a href="#A3441b">A344b</a>,<a href="#A3451b">A345b</a>}  <b>.</b> 
<br>
<a name=A3411k></a>k) <b>NEST UNSUPPRESSETY COMARK frame</b> {<a href="#A3421b">A342b,c</a>  ,<a href="#A3461a">A346a</a>}  <b>: NEST insertion</b> {d}<b>, NEST replicator</b> {g}<b>, 
UNSUPPRESSETY suppression</b><b> {l}</b><b>, COMARK marker</b> {<a href="#A3421d">A342d,f</a>  ,<a href="#A3461b">A346b</a>}  <b>.</b> 
<br>
<a name=A3411l></a>l) <b>UNSUPPRESSETY suppression</b> {j,k,<a href="#A3471b">A347b</a>} <b>: where (UNSUPPRESSETY) is (unsuppressible) , EMPTY ; where (UNSUPPRESSETY)  is (EMPTY) , letter s</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol option.</b> 
<br>
<a name=A3411m></a>m) <b>*frame : NEST UNSUPPRESSETY MARK frame</b> {j}<b>;  NEST UNSUPPRESSETY COMARK frame</b> {k}<b>; NEST RADIX frame</b> {<a href="#A3471b">A347b</a>} <b>.</b> 
<br>
<a name=A3411n></a>n) <b>*marker : MARK marker</b> {<a href="#A3421e">A342e</a>  ,<a href="#A3431d">A343d,e</a>,<a href="#A3441b">A344b</a>,<a href="#A3451b">A345b</a>}  <b>; COMARK marker</b> {<a href="#A3421d">A342d,f</a>  ,<a href="#A3461b">A346b</a>}  <b>; radix marker</b> {<a href="#A3471c">A347c</a>} <b>.</b> 
<br>
<a name=A3411o></a>o) <b>*pattern : NEST TYPE pattern</b> {<a href="#A3421a">A342a</a>  ,<a href="#A3431a">A343a</a>,<a href="#A3441a">A344a</a>,<a href="#A3451a">A345a</a>,<a href="#A3461a">A346a</a>,<a href="#A3471a">A347a</a>,<a href="#A3481a">A348a,h</a>,<a href="#A3491a">A349a</a>,<a href="#A34A1a">A34Aa</a>}  <b>.</b> 

<p>
<pre>
{Examples:  
a) $p "table of"x 10a,l n (lim-1) ("x=" 12z+d 2x, +.12de+2d 3q"+j&times;"3" "si+.10de+2d l) p$    
b) p"table of"x10a &bull; l n (lim - 1) ("x=" 12z+d 2x, +.12de+2d 3q"+j&times;"3" "si+.10de+2d l) p      
c) 120k c("mon", "tues", "wednes", "thurs", "fri", "satur", "sun") "day"
d) p"table of"x
e) p"table of"      
h) 10 &bull; n (lim -1)     
i) "+j&times;"3" "     
j) si      
k) "x="12z     
l) s }
</pre>


<p>
{The positions where pragments {<a href="report_4.html#921a">9.2.1.a</a>} may occur in <b>format-texts</b> are restricted. In general (as elsewhere in the language) , a pragment may not occur 
between two <b>DIGIT-</b> or <b>LETTER-symbols</b>.}  

<p>
<a name=A3411aa></a> {aa) For formatted output, <tt>putf</tt> {<a href="#A351a">10.3.5.1.a</a>} and <tt>printf</tt> (or <tt>writef</tt>) {<a href="#A51f">10.5.1.f</a>} may be used and, for formatted input, <tt>getf</tt> {<a href="#A352a">10.3.5.2.a</a>} and <tt>readf</tt> {<a href="#A51g">10.5.1.g</a>}. Each element in the data list (cf. <a href="#A33">10.3.3</a>) is either a format to be associated with the file or a value to be transput (thus a format may be included in the data list immediately before the values to be transput using that format) .  

<p>
<a name=A3411bb></a>bb) During a call of <tt>putf</tt> or <tt>getf</tt>  transput proceeds as follows: For each element of the data list, considered in turn,
<ul>
If it is a format,    
<br>
then it is made to be the current format of the file by <tt>associate format</tt> (<a href="report_5.html#A35k">10.3.5.k</a>):    
<br>
otherwise, the element is straightened (<a href="#A323c">10.3.2.3.c</a>) and each element of the resulting multiple value is output {<a href="#A3411hh">hh</a>} or input {<a href="#A3411ii">ii</a>} using the next "picture" {<a href="#A3411cc">cc</a>, <a href="#A3411gg">gg</a>} from the current format. 
</ul>

<p>
<a name=A3411cc></a>cc) A "picture" is the yield of a <b>picture</b>. It is composed of a "pattern"of some specific <b>'TYPE'</b> (according to the syntax of the <b>TYPE-pattern</b> of that <b>picture</b>) , followed by an "insertion"  {<a href="#A3411ee">ee</a>}. Patterns, apart from <b>'choice'</b>, <b>'format'</b> and <b>'general'</b>  patterns, are composed of "frames", possibly "suppressed", each of which has an insertion, a "replicator" {<a href="#A3411dd">dd</a>}, and a "marker" to indicate whether it is a <tt>"d"</tt>, <tt>"z"</tt>,  <tt>"i"</tt> etc. frame. The frames of each pattern may be grouped into "sign moulds", "integral moulds", etc., according to the syntax of the corresponding pattern.  

<p>
<a name=A3411dd></a>dd) A "replicator" is a routine, returning an integer, constructed from a <b>replicator</b> {<a href="#A3412c">10.3.4.1.2.c</a>}, For example, the <b>replicator</b> <tt>10</tt> gives rise to a routine composed from <tt>INT: 10;</tt> moreover, <tt>n (lim - 1) </tt> is a "dynamic"  <b>replicator</b> and gives rise to <tt>INT: (lim - 1) </tt>. Note that the scope of a replicator restricts the scope of any format containing it, and thus it may be necessary to take a local copy of a file before associating a format with it (see, e.g.. <a href="report_5.html#BD">11.D</a>) . A replicator which returns a negative value is treated as if it had returned zero (<tt>"k"</tt> alignments apart) .  

<p>
When a <b>picture</b> is "staticized", all of its replicators and other routines (including those contained in its insertions) are called collaterally. A staticized pattern may be said to "control" a string, and there is then a correspondence between the frames of that pattern, taken in order, and the characters of the string. Each frame controls <i>n</i> consecutive characters of the string, where <i>n</i> is <i>0</i> for an <tt>"r"</tt> frame and, otherwise, is the integer returned by the replicator of the frame (which is always <i>1</i>  for a <tt>"+"</tt>, <tt>"-"</tt>, <tt>"."</tt>, <tt>"e"</tt>, <tt>"i"</tt> or <tt>"b"</tt> frame) . Each controlled character must be one of a limited set appropriate to that frame.  

<p>
<a name=A3411ee></a>ee) An "insertion", which is the yield of an <b>insertion</b> {<a href="#A3412d">10.3.4.1.2.d</a>}, is a sequence of replicated "alignments" and strings: an insertion containing no alignments is termed a "literal". An insertion is "performed" by performing its alignments {<a href="#A3411ff">ff</a>} and on output (input) writing ("expecting" {<a href="#A3411ll">ll</a>}) each character of its replicated strings (a string is replicated by repeating it the number of times returned by its replicator) .  

<p>
<a name=A3411ff></a>ff) An "alignment" is the character yielded by an <b>alignment-code</b> {<a href="#A3412d">10.3.4.1.2.d</a>}. An alignment which has been replicated <i>n</i> times is performed as follows:  

<p>
&bull; <tt>"k"</tt> causes <tt>set char number</tt> to be called, with <i>n</i> as its second parameter:  
<br>
&bull; <tt>"x"</tt> causes <tt>space</tt> to be called <i>n</i> times:  
<br>
&bull; <tt>"y"</tt> causes <tt>backspace</tt> to be called <i>n</i> times:  
<br>
&bull; <tt>"l"</tt> causes <tt>newline</tt> to be called <i>n</i> times:  
<br>
&bull; <tt>"p"</tt> causes <tt>newpage</tt> to be called <i>n</i> times;  
<br>
&bull; <tt>"q"</tt> on output (input) causes the character <tt>blank</tt> to be written (expected) <i>n</i> times. 

<p>
<a name=A3411gg></a>gg) A format may consist of a sequence of <b>pictures</b>, each of which is selected in turn by <tt>get next picture</tt>  {<a href="#A35b">10.3.5.b</a>}. In addition, a set of pictures may be grouped together to form a replicated  "collection" (which may contain further such collections) . When the last picture in a collection has been selected, its first picture is selected again, and so on until the whole collection has been repeated <i>n</i> times, where <i>n</i>  is the integer returned by its replicator. A collection may be provided with two insertions, the first to be performed before the collection, the second afterwards.  

<p>
A format may also invoke other formats by means of <b>'format'</b> patterns {<a href="#A3491">10.3.4.9.1</a>}.  

<p>
When a format has been exhausted, the event routine corresponding to <tt>on format end</tt> is called; if this returns <tt>false</tt>, the format is repeated;  otherwise, if the event routine has failed to provide a new format,  <tt>undefined</tt> is called.  

<p>
<a name=A3411hh></a>hh) A value <i>V</i> is output, using a picture <i>P</i>, as follows:  
<br>
If the pattern <i>Q</i> of <i>P</i> is a <b>'choice'</b> or <b>'general'</b> pattern,    
<dd>
then <i>V</i> is output using <i>P</i> (See <a href="#A3431aa">10.3.4.3.1.aa,dd</a>    , <a href="#A34A1aa">10.3.4.10.1.aa</a>);    
<br>
otherwise, <i>V</i> is output as follows:
<ul>     
<li><i>P</i> is staticized;
<br>
If the mode of <i>V</i> is "output compatible" with <i>Q</i> (see the separate section dealing with each type of pattern) ,        
<br>
then
<ul>
&bull; <i>V</i> is converted into a string controlled {<a href="#A3411dd">dd</a>} by <i>Q</i> (See the appropriate section);
</ul>
If the mode is not output compatible, or if the conversion is unsuccessful,        
<br>
then        
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;        
<br>
&bull; if this returns <tt>false</tt>, <i>V</i> is output using <tt>put</tt> and <tt>undefined</tt> is called; 
</ul>
otherwise, the string is "edited" (<a href="#A3411jj">jj</a>) using <i>Q</i>:
<li>the insertion of <i>P</i> is performed. </li></ul>
</ul>
 
<p>
<a name=A3411ii></a>ii) A value is input to a name <i>N</i>, using a picture <i>P</i>, as follows:
<br>
If the pattern <i>Q</i> of <i>P</i> is a <b>'choice'</b> or <b>'general'</b> pattern,    
<br>
then a value is input to <i>N</i> using <i>P</i> (see <a href="#A3481bb">10.3.4.8.1.bb,ee</a>    , <a href="#A34A1bb">10.3.4.10.1.bb</a>);    
<br>
otherwise,    
<ul>     
<li><i>P</i> is staticized;      
<li>a string controlled by <i>Q</i> is "indited" {<a href="#A3411kk">kk</a>};      
<br>
If the mode of <i>N</i> is "input compatible" with <i>Q</i> (see the appropriate section) ,      
<br>
then      
<ul>
&bull; the string is converted to an appropriate value suitable for <i>N</i> using <i>Q</i> (see the appropriate section):      
<br>
&bull; if the conversion is successful, the value is assigned to <i>N</i>;
</ul>
If the mode is not input-compatible, or if the conversion is unsuccessful,        
<br>
then        
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;        
<br>
&bull; if this returns <tt>false</tt>, <tt>undefined</tt> is called;
</ul>
<li>the insertion of <i>P</i> is performed. 
</ul> 

<p>
<a name=A3411jj></a>jj) A string is "edited", using a pattern <i>P</i>, as follows:
<br>
In each part of the string controlled by a sign mould,  
<ul>
&bull; if the first character of the string (which indicates the sign) is <tt>"+"</tt> and the sign mould contains a <tt>"-"</tt> frame, then that character is replaced by <tt>" "</tt>  
<br>
&bull; the first character (i.e., the sign) is shifted to the right across all leading zeroes in this part of the string and these zeroes are replaced by spaces (for example, using the sign mould <tt>4z+</tt>, the string <tt>"+0003"</tt> becomes <tt>"+   3"</tt>
</ul>
In each part of the string controlled by an integral mould,  
<ul>
&bull; zeroes controlled by <tt>"z"</tt> frames are replaced by spaces as follows:   
<ul>
&bull; between the start of the string and the first nonzero digit;  
<br>
&bull; between each <tt>"d"</tt>, <tt>"e"</tt> or <tt>"i"</tt> frame and the next nonzero digit; 
<br>
 (for example, using the pattern <tt>zdzd2d</tt> the string <tt>"180168"</tt> becomes <tt>"18 168"</tt>;) 
</ul>
</ul>
For each frame <i>F</i> of <i>P</i>,  
<ul>
&bull; the insertion of <i>F</i> is performed.  
<br>
&bull; if <i>F</i> is not suppressed, the characters controlled by <i>F</i> are written;
<br>
(for example, the string <tt>"+0003.5"</tt>, when edited using the pattern <tt>4z+ s. "," d</tt>, causes the string <tt>"   +3,5"</tt> to be written and the string <tt>"180168"</tt>, using the pattern <tt>zd"-"zd"-19"2d</tt>, gives rise to <tt>"18- 1-1968"</tt>) .  
</ul>

<p>
<a name=A3411kk></a>kk) A string is "indited", using a pattern <i>P</i>, as follows: 
<br>
For each frame <i>F</i> of <i>P</i>,  
<ul>
&bull; the insertion of <i>F</i> is performed.
<br>
For each element of the string controlled by <i>F</i>, a character is obtained as follows:
<br>If <i>F</i> is contained in a sign mould, 
<br>
then  
<ul>
&bull; if a sign has been found, a digit is expected, with <tt>"0"</tt> as suggestion;  
<br>
&bull; otherwise, either a <tt>"+"</tt> or a <tt>"-"</tt> is expected, with <tt>"0"</tt> as suggestion, and, in addition, if the sign mould contains a frame, then a space 
preceding the first digit will be accepted as the sign (and replaced by <tt>"+"</tt>);
</ul>
otherwise, if <i>F</i> is contained in an integral mould,
<br>
then
<ul>
If <i>F</i> is suppressed,
<br> 
then "0" is supplied,
<br>
otherwise: 
<ul>
<a name=A3411cA></a>Case A: <i>F</i> is a <tt>"d"</tt> frame:  
<ul>
&bull; a digit is expected, with <tt>"0"</tt> as suggestion; 
</ul>
<a name=A3411cB></a>Case B: if <i>F</i> is <tt>"z"</tt> frame:  
<ul>
&bull; a digit or space is expected, with <tt>"0"</tt> as suggestion, but a space is only acceptable as follows:  
<ul>
&bull; between the start of the string and the first nonzero digit;  
<br>
&bull; between each <tt>"d"</tt>, <tt>"e"</tt> or <tt>"i"</tt> frame and the next nonzero digit;  
</ul>
<p>
&bull; such spaces are replaced by zeroes.
</ul>
</ul>
</ul>
otherwise, if <i>F</i> is an <tt>"a"</tt> frame, 
<br>
then if <i>F</i> is not suppressed, a character is read and supplied; otherwise <tt>" "</tt> is supplied;
<br>
otherwise, if <i>F</i> is not suppressed, 
<br>
then 
<ul>
if <i>F</i> is a <tt>"."</tt> (<tt>"e"</tt>, <tt>"i"</tt>,  <tt>"b"</tt>) frame, a <tt>"."</tt> (<tt>"<sub>10</sub>"</tt> or <tt>"\"</tt> or <tt>"e"</tt>, <tt>"I"</tt> or <tt>"i"</tt>, <tt>flip</tt> or <tt>flop</tt>) is expected, with <tt>"."</tt> (<tt>"<sub>10</sub>"</tt>, <tt>"I"</tt>,  <tt>flop</tt>) as suggestion;
</ul> 
otherwise, if <i>F</i> is a suppressed <tt>"."</tt> (<tt>"e"</tt>, <tt>"i"</tt>) frame, the character <tt>"."</tt> (<tt>"<sub>10</sub>"</tt>, <tt>"I"</tt>) is supplied. 
</ul>

<p>
<a name=A3411ll></a>ll) A member of a set of characters <i>S</i> is  "expected", with the character <i>C</i> as suggestion, as follows:  
<br>
&bull; a character is read;  
<br>
If that character is one of the expected characters (i.e., a member of <i>S</i>) , 
<br>
then that character is supplied;  
<br>
otherwise, 
<ul>
the event routine corresponding to <tt>on char error</tt> is called, with <i>C</i> as suggestion; if this returns <tt>true</tt> and <i>C</i>, as possibly replaced, is one of the expected characters, then that character is supplied; otherwise, <tt>undefined</tt> is called. }  
</ul>

<h3>
<a name=A3412></a>10.3.4.1.2. Semantics
</h3>  

<p>
{A format is brought into being by means of a <b>format-text</b>. A format is best regarded as a tree, with a collection at each node and a picture at each tip. In order to avoid violation of the scope restrictions, each node of this tree is, in this Report, packed into a value of mode <b>'PIECE'</b>. A format is composed of a row of such pieces and the pieces contain pointers to each other in the form of indices selecting from that row. An implementer will doubtless store the tree in a more efficient manner. This is possible because the <b>field-selector</b> of a format is hidden from the user in order that he may not break it open.  

<p>
Although a <b>format-text</b> may contain <b>ENCLOSED-clauses</b> (in <b>replicators</b> and <b>format-patterns</b>) or <b>units</b> (in <b>general-patterns</b>,) these are not elaborated at this stage but are, rather, turned into routines for subsequent calling as and when they are encountered during formatted transput. Indeed, the elaboration of a <b>format-text</b> does not result in any actions of any significance to the user.}  

<p>
<a name=A3412a></a>a) The yield of a <b>format-text</b> <i>F</i>, in an environ <i>E</i>, is a structured value whose only field is a multiple value <i>W</i>, whose mode is <b>'row of PIECE'</b>, composed of a descriptor ((1, n))  and <i>n</i> elements determined as follows:  
<br>
&bull; a counter <i>i</i> is set to <i>1</i>;  
<br>
&bull; <i>F</i> is "transformed" {b} in <i>E</i> into <i>W</i>, using <i>i</i>.  

<p>
<a name=A3412b></a>b) A <b>format-text</b> or a <b>collection-list-pack</b>  <i>C</i> is "transformed" in an environ <i>E</i> into a multiple value <i>W</i>  whose mode is <b>'row of PIECE'</b>, using a counter <i>i</i>, as follows:  
<br>
&bull; the element of <i>W</i> selected by (<i>i</i>) is a structured value, whose mode is <b>'PIECE'</b> and whose fields, taken in order, are  
<ul>
&bull; {<i>cp</i>} undefined;  
<br>
&bull; {<i>count</i>} undefined;  
<br>
&bull; {<i>bp</i>} undefined;  
<br>
&bull; {<i>c</i>} a multiple value <i>V</i> whose mode is "<b>row of COLLECTION</b>", having a descriptor ((1,m)) , where <i>m</i> is the number of constituent collections of <i>C</i>, and elements determined as follows: 
<br>
For j = 1, ... m, letting C<sub>j</sub> be the <i>j</i>-th constituent collection of <i>C</i>,  
<p>
<a name=A3412cA></a>Case A: The direct descendents of <i>C<sub>j</sub></i> include a <b>picture</b>  <i>P</i>.  
<ul>
&bull; the constituent <b>pattern</b> <i>P</i> if any and the <b>insertion</b> <i>I</i> of <i>P</i> are elaborated collaterally;  
<br>
&bull; the <i>j</i>-th element of <i>V</i> is a structured value, whose mode is <b>'PICTURE'</b> and whose fields, taken in order are  
<ul>
&bull; {<i>p</i>}; the yield of <i>T</i>, if any, {e, <a href="#A3482">10.3.4.8.2</a>  , <a href="#A3492">10.3.4.9.2</a>,  <a href="#A34A2">10.3.4.10.2</a>} and, otherwise, <tt>empty</tt>.  
<br>
&bull; {<i>i</i>} the yield of <i>I</i> {d}; 
</ul>
</ul>
<a name=A3412cB></a>Case B: 
<ul>
The direct descendents of <i>C<sub>j</sub></i>, include a first <b>insertion</b> <i>I1</i>, a <b>replicator</b> <i>REP</i>, a <b>collection-list-pack</b>  <i>P</i> and a second <b>insertion</b> <i>I2</i>:  
<br>
&bull; <i>i</i> is increased by <i>1</i>;  
<br>
&bull; <i>I1</i>, <i>REP</i> and <i>I2</i> are elaborated collaterally;  
<br>
&bull; the <i>j</i>-th element of <i>V</i> is a structured value whose mode is <b>'COLLITEM'</b> and whose fields, taken in order, are  
<ul>
&bull; {<i>i1</i>} the yield of <i>I1</i> {d};  
<br>
&bull; {<i>rep</i>} the yield of <i>REP</i> {c};  
<br>
&bull; {<i>p</i>} <i>i</i>;  
<br>
&bull; {<i>i2</i>} the yield of <i>I2</i>;  
</ul>
&bull; <i>P</i> is transformed in <i>E</i> into <i>W</i>, using <i>i</i>. 
</ul>
</ul>
<a name=A3412c></a>c) The yield, in an environ <i>E</i>, of a <b>NEST-UNSUPPRESSETY-replicator</b> <i>R</i> {<a href="#A3411g">10.3.4.1.1.g, h</a>} is a routine whose mode is <b>'procedure yielding integral'</b>, composed of a <b>procedure-yielding-integral-NEST-routine-text</b> whose <b>unit</b> is <i>U</i>, together with the environ necessary {<a href="report_3.html#722c">7.2.2.c</a>} for <i>U</i> in <i>E</i>, where <i>U</i> is determined as follows:  

<p>
<a name=A3412cA></a>Case A: <i>R</i> contains a <b>meek-integral-ENCLOSED-clause</b> <i>C</i>:  
<ul>
&bull; <i>U</i> is a new <b>unit</b> akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to <i>C</i>; 
</ul>
<p>
<a name=A3412cB></a>Case B: <i>R</i> contains a <b>fixed-point-numeral</b> <i>D</i>, but no <b>ENCLOSED-clause</b>:
<ul>
&bull; <i>U</i> is a new <b>unit</b> akin to <i>D</i>; 
</ul>
<p>
<a name=A3412cC></a>Case C: <i>R</i> is invisible:  
<ul>
&bull; <i>U</i> is a new <b>unit</b> akin to a <b>fixed-point-numeral</b>  which has an intrinsic value {<a href="report_4.html#8112">8.1.1.2</a>} of 1. 
</ul>

<p>
<a name=A3412d></a>d) The yield of an <b>insertion</b> <i>I</i> {<a href="#A3411d">10.3.4.1.1.d</a>} is a multiple value <i>W</i> whose mode is <b>'INSERTION'</b>, determined as follows:  
<br>
&bull; let U<sub>1</sub>, ... , U<sub>n</sub> be the constituent <b>UNSUPPRESSETY-replicators</b> of <i>I</i>, and let A<sub>i</sub>, i = 1, ... n, be the <b>denoter-coercee</b> or <b>alignment-code</b> {immediately}  following U<sub>i</sub>:  
<br>
&bull; let R<sub>1</sub>, ... , R<sub>n</sub> and D<sub>1</sub>, ... , D<sub>n</sub> the {collateral} yields of U<sub>1</sub>, ... , U<sub>n</sub> and A<sub>1</sub>, ... , A<sub>n</sub>, where the yield of an <b>alignment-code</b>  is the {character which is the} intrinsic value {<a href="report_4.html#8142b">8.1.4.2.b</a>} of its <b>LETTER-symbol</b>;  
<br>
&bull; the descriptor of <i>W</i> is ((1, n));  
<br>
&bull; the element of <i>W</i> selected by (i) , i = 1, ..., n, is a structured value {of the mode specified by <tt>STRUCT (PROC INT rep, UNION (STRING, CHAR)  sa) </tt>} whose fields, taken in order, are  
<ul>
&bull; {<i>rep</i>} R<sub>i</sub>;  
<br>
&bull; {<i>sa</i>} D<sub>i</sub>.  
</ul>

<a name=A3412e></a>e) The yield of an <b>integral-</b>, <b>real-</b>,  <b>boolean-</b>, <b>complex-</b>, <b>string-</b> or <b>
bits-pattern</b><i> P</i>  {<a href="#A3421a">10.3.4.2.1.a</a>  , <a href="#A3431a">10.3.4.3.1.a</a>  , <a href="#A3441a">10.3.4.4.1.a</a>,  <a href="#A3451a">10.3.4.5.1.a</a>  , <a href="#A3461a">10.3.4.6.1.a</a>,  <a href="#A3471a">10.3.4.7.1.a</a>} is a structured value <i>W</i> whose mode is <b>'PATTERN'</b>, determined as follows:  
<br>
&bull; let V<sub>1</sub>, ... , V<sub>n</sub> be the {collateral} yields of the constituent frames of <i>P</i> {f};  
<br>
&bull; the fields of <i>W</i>, taken in order, are  
<br>
&bull; {<i>type</i>} 1 (2, 3, 4, 5) if <i>P</i> is an <b>integral-</b> (<b>real-</b>,  <b>boolean-</b>, <b>complex-</b>, <b>string-</b>) <b>-pattern</b> and 6 (8, 12,  20) if <i>P</i> is a <b>bits-pattern</b> whose constituent <b>RADIX</b> is a <b>radix-two</b> (<b>-four</b>, <b>-eight</b>, <b>-sixteen</b>);  
<br>
&bull; {<i>frames</i>} a multiple value, whose mode is <b>'row of FRAME'</b>, having a descriptor ((1, n)) and <i>n</i> elements, that selected by (i) being <i>V<sub>i</sub></i>.  

<p>
<a name=A3412f></a>f) The yield of a <b>frame</b> <i>F</i> {<a href="#A3411m">10.3.4.1.1.m</a>} is a structured value <i>W</i> whose mode is <b>'FRAME'</b>, determined as follows:  
<br>
&bull; the <b>insertion</b> and the <b>replicator</b>, it any, of <i>F</i> are elaborated collaterally:  
<br>
&bull; the fields of <i>W</i>, taken in order, are  
<ul>
&bull; {<i>i</i>} the yield of its <b>insertion</b>;  
<br>
&bull; {<i>rep</i>} the yield of its <b>replicator</b> {c}, if any, and, otherwise, the yield of an invisible <b>replicator</b>:  
<br>
&bull; {<i>supp</i>} <tt>true</tt> if its first <b>UNSUPPRESSETY-suppression</b> contains a <b>letter-s-symbol</b> and, otherwise, <tt>false</tt>:  
<br>
&bull; {<i>marker</i>} (the character which is the intrinsic value {<a href="report_4.html#8142b">8.1.4.2.b</a>} of a <b>symbol</b> <i>S</i> determined as follows:  
<br>
<a name=A3412cA></a>Case A: <i>F</i> is a constituent <b>unsuppressible-zero-frame</b> of a <b>sign-mould</b> {such as <tt>3z+</tt>} whose constituent <b>sign-marker</b>  contains a <b>plus-symbol</b>:  
<ul>
&bull; S is a <b>letter-u-symbol</b>. 
</ul>
<a name=A3412cB></a>Case B: <i>F</i> is a constituent <b>unsuppressible-zero-frame</b> of a <b>sign-mould</b> {such as <tt>3z-</tt>} whose constituent <b>sign-marker</b>  contains a <b>minus-symbol</b>:  
<ul>
&bull; S is a <b>letter-v-symbol</b>. 
</ul>
Other cases:  
<ul>
&bull; <i>S</i> is the constituent <b>symbol</b> of the <b>marker</b> of <i>F</i>.  
</ul>
</ul>
{Thus the <b>zero-marker</b> <tt>z</tt> may be passed on as the character <tt>"u"</tt>, <tt>"v"</tt> or <tt>"z"</tt> according to whether it forms part of a <b>sign-mould</b> (with descendent <b>plus-symbol</b> or <b>minus-symbol</b>)  or of an <b>integral-mould</b>.}  

<h3>
<a name=A342></a>10.3.4.2. Integral patterns
</h3>

<h3>
<a name=A3421></a>10.3.4.2.1. Syntax
</h3> 

<p>
<a name=A3421a></a>a) <b>NEST integral pattern</b> {<a href="#A3411c">A341c</a>  ,<a href="#A3431c">A343c</a>}  <b>: NEST sign mould</b> {c}<b> option, NEST integral mould</b> {b}<b>.</b> 
<br>
<a name=A3421b></a>b) <b>NEST integral mould</b> {a,<a href="#A3431b">A343b,c</a>  ,<a href="#A3471a">A347a</a>}  <b>: NEST digit frame</b> {<a href="#A3411k">A341k</a>} <b>sequence.</b> 
<br>
<a name=A3421c></a>c) <b>NEST sign mould</b> {a,<a href="#A3431a">A343a</a>} <b>: NEST unsuppressible zero frame</b> {<a href="#A3411k">A341k</a>} <b>sequence option, NEST unsuppressible sign frame</b> {<a href="#A3411j">A341j</a>} <b>.</b> 
<br>
<a name=A3421d></a>d) <b>zero marker</b> {f,<a href="#A3411k">A341k</a>} <b>: letter z</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b> 
<br>
<a name=A3421e></a>e) <b>sign marker</b> {<a href="#A3411j">A341j</a>} <b>: plus</b> {<a href="report_4.html#941c">94c</a>}  <b>symbol ; minus</b> {<a href="report_4.html#941c">94c</a>}  <b>symbol.</b> 
<br>
<a name=A3421f></a>f) <b>digit marker</b> {<a href="#A3411k">A341k</a>} <b>: letter d</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol ; zero marker</b> {d}<b>.</b> 

<p>
<pre>
{Examples:  
a) "x=" 12z+d
b) d
c) "x=" 12z+ }
</pre>
{For the semantics of <b>integral-patterns</b> see <a href="#A3412e">10.3.4.1.2.e</a>  .}

<p>
<a name=A3421aa></a> {aa) The modes which are output (input) compatible with an <b>'integral'</b> pattern are those specified by <tt><b><i>L</i></b> INT</tt> (by <tt>REF <b><i>L</i></b> INT</tt>) .  

<p>
<a name=A3421bb></a>bb) A value <i>V</i> is converted to a string <i>S</i>  using an <b>'integral'</b> pattern <i>P</i> as follows:  
<br>
&bull; if <i>P</i> contains a sign mould, the <span lang="en-gb"></span>first character of <i>S</i> is the sign of <i>V</i>; otherwise, if V &lt; 0, the conversion is unsuccessful;  
<br>
&bull; the remainder of <i>S</i> contains a decimal representation of <i>V</i>  determined as follows:  
<ul>
&bull; the elements of <i>S</i> controlled by <tt>"d"</tt> and <tt>"z"</tt> frames are the appropriate digits (thus the pattern specifies the number of digits to be used);  
<br>
&bull; if <i>V</i> cannot be represented by such a string, the conversion is unsuccessful;  
</ul>
 (For example, the value 99 could be converted to a string using the pattern <tt>zzd</tt>, but 9999 and -99 could not.)  

<p>
<a name=A3421cc></a>cc) A string <i>S</i> is converted to an integer suitable for a name <i>N</i>, using an <b>'integral'</b> pattern, as follows:  
<br>
&bull; the integer <i>I</i> for which <i>S</i> contains a decimal representation {<a href="report_4.html#8112">8.1.1.2</a>} is considered;  
<br>
&bull; if <i>I</i> is greater than the largest value to which <i>N</i> can refer, the conversion is unsuccessful; otherwise, <i>I</i> is the required integer (e.g., if the mode of <i>N</i> is specified by <tt>REF SHORT INT</tt>, and the value of <tt>short max int</tt> is 65535, then no string containing a decimal representation of a value greater than 65535 may be converted) .}   

<h3>
<a name=A343></a>10.3.4.3. Real patterns
</h3>

<h3>
<a name=A3431></a>10.3.4.3.1. Syntax
</h3> 

<p>
<a name=A3431a></a>a) <b>NEST real pattern</b> {<a href="#A3411c">A341c</a>, <a href="#A3451a">A345a</a>}  <b>: NEST sign mould</b> {<a href="#A3421c">A342c</a>} <b>option, NEST variable point mould</b> {b}<b> or alternatively NEST floating point mould</b> {c}<b>.</b> 
<br>
<a name=A3431b></a>b) <b>NEST variable point mould</b> {a,c}<b> : NEST integral mould</b> {<a href="#A3421b">A342b</a>} <b>option ; NEST point frame</b> {<a href="#A3411j">A341j</a>}  <b>, NEST integral mould</b> {<a href="#A3421b">A342b</a>} <b>option.</b> 
<br>
<a name=A3431c></a>c) <b>NEST floating point mould {a} : NEST variable point mould</b> {b}<b> or alternatively NEST integral mould</b> {<a href="#A3421b">A342b</a>} <b>, NEST exponent frame</b> {<a href="#A3411j">A341j</a>} <b>, NEST integral pattern</b> {<a href="#A3421a">A342a</a>} <b>.</b> 
<br>
<a name=A3431d></a>d) <b>point marker</b> {<a href="#A3411j">A341j</a>} <b>: point</b> {<a href="report_4.html#941b">94b</a>}  <b>symbol.</b> 
<br>
<a name=A3431e></a>e) <b>exponent marker</b> {<a href="#A3411j">A341j</a>} <b>: letter e</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b> 

<p>
<pre>
{Examples:  
a) +zd.11d &bull; +.12de+2d
b) zd.11d &bull; +.12d
c) .12de+2d } 
</pre>
{For the semantics of <b>real-patterns</b> see <a href="#A3412e">10.3.4.1.2.e</a>  .}  

<p>
<a name=A3431aa></a> {aa) The modes which are output (input) compatible with a <b>'real'</b> pattern are those specified by <tt><b><i>L</i></b>  REAL</tt> and <tt><i>L</i>  INT</tt> (by <tt>REF <b><i>L</i></b>  REAL</tt>) .  

<p>
<a name=A3431bb></a>bb) A value <i>V</i> is converted to a string <i>S</i>  using a <b>'real'</b> pattern <i>P</i> as follows:  
<br>
&bull; if <i>P</i> contains a sign mould, the <span lang="en-gb"></span>first character of <i>S</i> is the sign of <i>V</i>; otherwise, if V &lt; 0, the conversion is unsuccessful;  
<p>
&bull; the remainder of <i>S</i> contains a decimal representation of <i>V</i>  determined as follows:  
<ul>
&bull; if necessary, <i>V</i> is widened to a real number;  
<br>
&bull; the element of <i>S</i> controlled by the <tt>"."</tt> (<tt>"e"</tt>)  frame, if any, of <i>P</i> is <tt>"."</tt> (<tt>"<sub>10</sub>"</tt>);  <DL compact>   
<br>
If <i>P</i> contains an <tt>"e"</tt> frame,    
<br>
then    
<br>
&bull; let <i>W</i> be the sequence of frames preceding, and <i>IP</i> be the <b>'integral'</b> pattern following, that <tt>"e"</tt> frame;    
<br>
&bull; an exponent <i>E</i> is calculated by standardizing <i>V</i> to the largest value convertible using <i>W</i> (see below);    
<br>
&bull; the part of <i>S</i> controlled by <i>IP</i> is obtained by converting <i>E</i> using <i>IP</i> (see <a href="#A3421bb">10.3.4.2.bb</a>) 
</ul>
otherwise,    
<ul>
&bull; let <i>W</i> be the whole of <i>P</i>;
</ul>
&bull; the elements of <i>S</i> controlled by the <tt>"d"</tt> and <tt>"z"</tt> frames of <i>W</i> are the appropriate digits to be used, and the number of digits to be placed after the decimal point, if any);  
<br>
&bull; if <i>V</i> cannot be represented by such a string, the conversion is unsuccessful. 

<p>
<a name=A3431cc></a>cc) A string <i>S</i> is converted to a real number suitable for a name <i>N</i>, using a <b>'real'</b> pattern <i>P</i>, as follows:  
<br>
&bull; the real number <i>R</i> for which <i>S</i> contains a decimal representation is considered;  
<br>
&bull; if <i>R</i> is greater than the largest value to which <i>N</i> can refer, the conversion is unsuccessful; otherwise, <i>R</i> is the required real number.}  

<h3>
<a name=A344>10.3.4.4. Boolean patterns
</h3>

<h3> 
<a name=A3441></a>10.3.4.4.1. Syntax
</h3>

<p> 
<a name=A3441a></a>a) <b>NEST boolean pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST unsuppressible boolean frame</b> {<a href="#A3411j">A341j</a>} <b>.</b> 
<br>
<a name=A3441b></a>b) <b>boolean marker</b> {<a href="#A3411j">A341j</a>  ,<a href="#A3481b">A348b</a>}  <b>: letter b</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b> 

<p>
<pre>
{Example:  
a) 14x b }
</pre>
{For the semantics of <b>boolean-patterns</b>  see <a href="#A3412e">10.3.4.1.2.e</a>  .}

<p>
<a name=A3441aa></a> {aa) The mode which is output (input) compatible with a <b>'boolean'</b> pattern is that specified by <tt>BOOL</tt> (<tt>REF BOOL</tt>)  

<p>
<a name=A3441bb></a>bb) A value <i>V</i> is converted to a string using a <b>'boolean'</b> pattern as follows:  
<br>
&bull; if <i>V</i> is <tt>true</tt> (<tt>false</tt>) , then the string is that yielded by <tt>flip</tt> (<tt>flop</tt>) .  

<p>
<a name=A3441cc></a>cc) A string <i>S</i> is converted to a boolean value, using a <b>'boolean'</b> pattern, as follows:  
<br>
&bull; if <i>S</i> is the same as the string yielded by <tt>flip</tt>  (<tt>flop</tt>) , then the required value is <tt>true</tt> (<tt>false</tt>) .}   

<h3>
<a name=A345></a>10.3.4.5. Complex patterns
</h3>

<h3>
<a name=A3451></a>10.3.4.5.1. Syntax
</h3>

<p>
<a name=A3451a></a>a) <b>NEST complex pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST real pattern</b> {<a href="#A3431a">A343a</a>} <b>, NEST complex frame</b> {<a href="#A3411j">A341j</a>}  <b>, NEST real pattern</b> {<a href="#A3431a">A343a</a>} <b>.</b> 
<br>
<a name=A3451b></a>b) <b>complex marker</b> {<a href="#A3411j">A341j</a>} <b>: letter i</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b> 

<p>
<pre>
{Example:  
a) +.12de+2d 3q"+j&times;"3" "si+.10de+2d }
</pre>

<p>
{For the Semantics of <b>complex-patterns</b> see <a href="#A3412e">10.3.4.1.2.e</a>  .}

<p>
{<a name=A3451aa></a>aa) The modes which are output (input) compatible with a <b>'complex'</b> pattern are those specified by <tt><b><i>L</i></b> COMPL </tt>, <tt><i>L</i>  REAL</tt> and <tt><b><i>L</i></b> INT</tt> (by <tt>REF <b><i>L</i></b> COMPL</tt>) .  

<p>
<a name=A3451bb></a>bb) A value <i>V</i> is converted to a string <i>S</i>  using a <b>'complex'</b> pattern <i>P</i> as follows:  
<br>
&bull; if necessary, <i>V</i> is widened to a complex number;  
<br>
&bull; the element of <i>S</i> controlled by the <tt>"i"</tt> frame of <i>P</i> is <tt>"&uarr;"</tt>;  
<br>
&bull; the part of <i>S</i> controlled by the first (second) <b>'real'</b> pattern of <i>P</i> is that obtained by converting the first (second) field of <i>V</i>  to a string using the first (second) <b>'real'</b> pattern of <i>P</i> {<a href="#A3431bb">10.3.4.3.1.bb</a>}  
<br>
&bull; if either conversion is unsuccessful, the conversion of <i>V</i> is unsuccessful.  
<br>
<a name=A3451cc></a>cc) A string is converted to a complex value <i>C</i>  suitable for a name <i>N</i>, using a <b>'complex'</b> pattern <i>P</i>, as follows:  
<br>
&bull; the part of the string controlled by the first (second) <b>'real'</b>  pattern of <i>P</i> is converted to a suitable real number {<a href="#A3431cc">10.3.4.3.1.cc</a>}, which then forms the first (second) field of <i>C</i>.  
<br>
&bull; if either conversion is unsuccessful, the conversion to <i>C</i> is unsuccessful.}  

<h3>
<a name=A346></a>10.3.4.6. String patterns
</h3>

<h3>
<a name=A3461></a>10.3.4.6.1. Syntax
</h3> 

<p>
<a name=A3461a></a>a) <b>NEST string pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST character frame</b> {<a href="#A3411k">A341k</a>} <b>sequence.</b> 
<br>
<a name=A3461b></a>b) <b>character marker</b> {<a href="#A3411k">A341k</a>} <b>: letter a</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b>

<pre>
{Example:  
a) p "table of"x 10a }
</pre>

{For the semantics of <b>string-patterns</b> see <a href="#A3412e">10.3.4.1.2.e</a>  .} { 

<p>
<a name=A3461aa></a>aa) The modes which are output (input) compatible with a <b>'string'</b> pattern are those specified by <tt>CHAR</tt> and <tt>[ ]  CHAR</tt> (by <tt>REF CHAR</tt>, <tt>REF [ ] CHAR</tt> and <tt>REF STRING</tt>) .   

<p>
<a name=A3461bb></a>bb) A value <i>V</i> is converted to a string using a <b>'string'</b> pattern <i>P</i> as follows:  
<br>
&bull; if necessary, <i>V</i> is rowed to a string:  
<br>
&bull; if the length of the string <i>V</i> is equal to the length of the string controlled by <i>P</i>, then <i>V</i> is supplied: otherwise, the conversion is unsuccessful,  

<p>
<a name=A3461cc></a>cc) A string <i>S</i> is converted to a character or a string suitable for a name <i>N</i>, using a <b>'string'</b> pattern, as follows:  
<br>
<a name=A3461cA></a>Case A: The mode of <i>N</i> is specified by <tt>REF CHAR</tt>:  
<ul>
&bull; if <i>S</i> does not consist of one character, the conversion is unsuccessful: otherwise, that character is supplied: 
</ul>
<a name=A3461cB></a>Case B: The mode of <i>N</i> is specified by <tt>REF [ ] CHAR</tt>:  
<ul>
&bull; if the length of <i>S</i> is not equal to the number of characters referred to by <i>N</i>, the conversion is unsuccessful: otherwise, <i>S</i> is supplied, 
</ul>
<a name=A3461cC></a>Case C: The mode of <i>N</i> is specified by <tt>REF STRING</tt>:  
<ul>
&bull; <i>S</i> is supplied.}
</ul>  

<h3>
<a name=A347></a>10.3.4.7. Bits patterns
</h3>

<h3>
<a name=A3471></a>10.3.4.7.1. Syntax
</h3>

<p> 
<a name=A3471a></a>a) <b>NEST bits pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST RADIX frame</b> {b}<b>, NEST integral mould</b> {<a href="#A3421b">A342b</a>} <b>.</b> 
<br>
<a name=A3471b></a>b) <b>NEST RADIX frame {a} : NEST insertion</b> {<a href="#A3411d">A341d</a>} <b>, RADIX</b> {<a href="report_4.html#821d">82d,e,f,g</a>} <b>, unsuppressible suppression</b> {<a href="#A3411l">A341l</a>}  <b>, radix marker</b> {c}<b>.</b> 
<br>
<a name=A3471c></a>c) <b>radix marker </b> {b}<b> : letter r</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol.</b>

<pre>
{Examples:
a) 2r6d26sd     
<a name=A3471b></a>b) 2r
}
</pre>

<p>
{For the semantics of <b>bits-patterns</b>, see <a href="#A3412e">10.3.4.1.2.e</a>  .}  

<p>
<a name=A3471aa></a> {aa) The modes which are output (input) compatible with a <b>'bits'</b>-pattern are those specified by <tt><b><i>L</i></b> BITS</tt> (<tt>REF <i>L</i>  BITS</tt>) .  

<p>
<a name=A3471bb></a>bb) A value <i>V</i> is converted to a string using a <b>'bits'</b> pattern <i>P</i> as follows:  
<br>
&bull; the integer <i>I</i> corresponding to <i>V</i> is determined, using the <b>operator</b> <tt>ABS</tt> {<a href="report_5.html#A238i">10.2.3.8.i</a>};
<br>
If the <tt>"r"</tt> frame of <i>P</i> was yielded by a <b>radix-two-</b>    (<b>-four-</b>, <b>-eight-</b>, <b>-sixteen-</b>) <b>-frame</b>,    
<br>
then
<ul> 
<i>I</i> is converted to a string, controlled by the integral mould of <i>P</i>, containing a binary (quaternary, octal, hexadecimal)    representation of <i>I</i> (cf. <a href="#A3421bb">10.3.4.2.1.bb</a>);    
<br>
&bull; if <i>I</i> cannot be represented by such a string, the conversion is unsuccessful.
</ul> 

<p>
<a name=A3471cc></a>cc) A string <i>S</i> is converted to a bits value suitable for a name <i>N</i>, using a <b>'bits'</b> pattern <i>P</i>, as follows:  
<br>
&bull; if the <tt>"r"</tt> frame of <i>P</i> was yielded by a <b>radix-two-</b>  (<b>-four-</b>, <b>-eight-</b>, <b>-sixteen-</b>) <b>-frame</b>, then the integer <i>I</i> for which <i>S</i> contains a binary (quaternary, octal, hexadecimal) representation is determined;  
<br>
&bull; the bits value <i>B</i> corresponding to <i>I</i> is determined, using the operator <tt>BIN</tt> (<a href="report_5.html#A238j">10.2.3.8.j</a>) :  
<br>
&bull; if the width of <i>B</i> is greater than that of the value to which <i>N</i> refers, the conversion is unsuccessful.}  

<h3>
<a name=A348></a>10.3.4.8. Choice patterns
</h3>
 
<h3>
<a name=A3481></a>10.3.4.8.1. Syntax
</h3> 

<p>
<a name=A3481a></a>a) <b>NEST integral choice pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST insertion</b> {<a href="#A3411d">A341d</a>} <b>, letter c</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol, NEST praglit</b> {c}<b> list brief pack,</b>
<b>pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option.</b>  
<br>
<a name=A3481b></a>b) <b>NEST boolean choice pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST insertion</b> {<a href="#A3411d">A341d</a>} <b>, boolean marker</b> {<a href="#A3441b">A344b</a>}  <b>, brief begin</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST praglit</b> {c}<b>, and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, NEST praglit</b> {c}<b>, brief end</b> {<a href="report_4.html#941f">94f</a>}  <b>token, pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option.</b> 
<br>
<a name=A3481c></a>c) <b>NEST praglit</b> {a,b}<b> : pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option, NEST literal</b> {<a href="#A3411i">A341i</a>} <b>.</b> 

<p>
<pre>
{Examples:  
a) 120kc ("mon", "tues", "wednes", "thurs", "fri", "satur", "sun")       
b) b ("","error")      
c) "mon" }
</pre>  

<p>
<a name=A3481aa></a> {aa) A value <i>V</i> is output using a <b>picture</b>  <i>P</i> whose pattern <i>Q</i> was yielded by an <b>integral-choice-pattern</b>  <i>C</i>, as follows:  
<br>
&bull; the <b>insertion</b> of <i>Q</i> is staticized {<a href="#A3411dd">10.3.4.1.1.dd</a>} and performed {<a href="#A3411ee">10.3.4.1.1.ee</a>};
<br>
If the mode of <i>V</i> is specified by <tt>INT</tt>, if <i>V &gt; 0</i>    and if the number of constituent <b>literal</b>s in the <b>praglit-list-pack</b> of <i>C</i> is at least <i>V</i>,    
<br>
then    
<ul>
&bull; the literal yielded by the <i>V</i>-th <b>literal</b> is staticized and performed; 
</ul>
otherwise,    
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;     
<br>
&bull; if this returns <tt>false</tt>, <i>V</i> is output using <tt>put</tt> and <tt>undefined</tt> is called;
</ul>
&bull; the <b>insertion</b> of <i>P</i> is staticized and performed.  

<p>
<a name=A3481bb></a>bb) A value is input to a name <i>N</i> using a picture <i>P</i> whose pattern <i>Q</i> was yielded by an <b>integral-choice-pattern</b> <i>C</i> as follows:  
<br>
&bull; the <b>insertion</b> of <i>Q</i> is staticized and performed,  
<br>
&bull; each of the literals yielded by the constituent <b>literal</b>s of the <b>praglit-list-pack</b> of <i>C</i> is staticized and "searched for" {<a href="#A3481cc">cc</a>} in turn:
<br>
If the mode of <i>N</i> is specified by <tt>REF INT</tt> and the <i>i</i>-th literal is the first one present.    
<br>
then <i>i</i> is assigned to <i>N</i>:    
<br>
otherwise,    
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;     
<br>
&bull; if this returns <tt>false</tt>, <tt>undefined</tt> is called;
</ul>
&bull; the <b>insertion</b> of <i>P</i> is staticized and performed.  

<p>
<a name=A3481cc></a>cc) A literal is "searched for" by reading characters and matching them against successive characters of the literal. If the end of the current line or the logical end of the file is reached, or if a character fails to match, the search is unsuccessful and the current position is returned to where it started from.  

<p>
<a name=A3481dd></a>dd) A value <i>V</i> is output using a picture  <i>P</i> whose pattern <i>Q</i> was yielded by a <b>boolean-choice-pattern</b>  <i>C</i> as follows:  
<br>
&bull; the insertion of <i>Q</i> is staticized and performed:
<br>
If the mode of <i>V</i> is specified by <tt>BOOL</tt>,    
<br>
then    
<br>
&bull; if <i>V</i> is <tt>true</tt> (<tt>false</tt>) , the literal yielded by the first (second) constituent <b>literal</b> of <i>C</i> is staticized and performed:    
<br>
otherwise,    
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;     
<br>
&bull; if this returns <tt>false</tt>, <i>V</i> is output using <tt>put</tt> and <tt>undefined</tt> is called;
</ul>
&bull; the insertion of <i>P</i> is staticized and performed.  

<p>
<a name=A3481ee></a>ee) A value is input to a name <i>N</i> using a picture <i>P</i> whose pattern <i>Q</i> was yielded by a <b>boolean-choice-pattern</b> <i>C</i> as follows:  
<br>
&bull; the insertion of <i>Q</i> is staticized and performed;  
<br>
&bull; each of the literals yielded by the constituent <b>literals</b> of <i>C</i> is staticized and searched for in turn:
<br>
If the mode of <i>N</i> is specified by <tt>REF BOOL</tt>, and the first second) insertion is present,    
<br>
then <tt>true</tt> (<tt>false</tt>) is assigned to <i>N</i>:    
<br>
otherwise,    
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;     
<br>
&bull; if this returns <tt>false</tt>, <tt>undefined</tt> is called;
</ul>
&bull; the insertion of <i>P</i> is staticized and performed.}
</ul>

<h3>
<a name=A3482></a>10.3.4.8.2. Semantics
</h3> 

<p>
The yield of a <b>choice-pattern</b> <i>P</i> is a structured value <i>W</i> whose mode is <b>'CPATTERN'</b>, determined as follows:  
<br>
&bull; let <i>n</i> be the number of constituent <b>NEST-literals</b> of the <b>praglit-list-pack</b> of <i>P</i>;  
<br>
&bull; let <i>S<sub>i</sub></i>, i = 1, ..., n, be a <b>NEST-insertion</b> akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to the <i>i</i>-th of those constituent <b>NEST-literals</b>:  
<br>
&bull; the <b>insertion</b> <i>I</i> of <i>P</i> and all of S<sub>1</sub>, S<sub>2</sub>, ... , S<sub>n</sub> are elaborated collaterally:  
<br>
&bull; the fields of <i>W</i>, taken in order, are  
<ul>
&bull; {<i>i</i>} the yield of <i>I</i>:  
<br>
&bull; {<i>type</i>} 1 (2) if <i>P</i> is a <b>boolean-</b> (<b>integral-</b>)  <b>-choice-pattern</b>;  
<br>
&bull; {<i>c</i>} a multiple value whose mode is <b>'row of INSERTION'</b>, having a descriptor ((1, n)) and <i>n</i> elements, that selected by (i) , i = 1, ... n, being the yield of <i>S<sub>i</sub></i>.  <a name=A349></a>  
</ul>

<h3>
<a name=A349>10.3.4.9. Format patterns
</h3>

<h3>
<a name=A3491></a>10.3.4.9.1. Syntax
</h3> 

<p>
<a name=A3491a></a>a) <b>NEST format pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST insertion</b> {<a href="#A3411d">A341d</a>} <b>, letter f</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol, meek FORMAT NEST ENCLOSED clause</b> {<a href="report_2.html#311a">31a</a> ,<a href="report_2.html#341a">34a</a>}  <b>, pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option.</b> 

<p>
<pre>
{Example:  
a) f (uir | (INT): $5d$, (REAL): $d.3d$) } 
</pre>

<p>
{A <b>format-pattern</b> may be used to provide formats dynamically for use in transput. When a <b>'format'</b> pattern is encountered during a call of <tt>get next picture</tt>, it is staticized and its insertion is performed. The first picture of the format returned by the routine of the pattern is supplied as the next picture, and subsequent pictures are taken from that format until it has been exhausted.} 

<h3> 
<a name=A3492></a>10.3.4.9.2. Semantics
</h3> 

<p>
The yield, in an environ <i>E</i>, of a <b>NEST-format-pattern</b> <i>P</i> is a structured value whose mode is <b>'FPATTERN'</b> and whose fields, taken in order, are  
<br>
&bull; {<i>i</i>} the yield of its <b>insertion</b>;  
<br>
&bull; {<i>pf</i>} a routine whose mode is <b>'procedure yielding FORMAT'</b>, composed of a <b>procedure-yielding-FORMAT-NEST-routine-text</b> whose <b>unit</b>  <i>U</i> is a new <b>unit</b> akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to the <b>meek-FORMAT-ENCLOSED-clause</b> of <i>P</i>, together with the environ necessary for <i>U</i> in <i>E</i>.  

<h3>
<a name=A34A></a>10.3.4.10. General patterns
</h3>
 
<h3>
<a name=A34A1></a>10.3.4.10.1. Syntax
</h3> 

<p>
<a name=A34A1a></a>a) <b>NEST general pattern</b> {<a href="#A3411c">A341c</a>} <b>: NEST insertion</b> {<a href="#A3411d">A341d</a>} <b>, letter g</b> {<a href="report_4.html#941a">94a</a>}  <b>symbol, NEST width specification</b> {b}<b> option.</b> 
<br>
<a name=A34A1b></a>b) <b>NEST width specification {a} : brief begin</b> {<a href="report_4.html#941f">94f</a>}  <b>token ; meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>, NEST after specification</b> {c}<b> option, brief end</b> {<a href="report_4.html#941f">94f</a>}  <b>token, pragment</b> {<a href="report_4.html#921a">92a</a>}  <b>sequence option.</b> 
<br>
<a name=A34A1c></a>c) <b>NEST after specification</b> {b}<b> : and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>, NEST exponent specification</b> {d}<b> option.</b> 
<br>
<a name=A34A1d></a>d) <b>NEST exponent specification</b> {c}<b> : and also</b> {<a href="report_4.html#941f">94f</a>}  <b>token, meek integral NEST unit</b> {<a href="report_2.html#321d">32d</a>}  <b>.</b> 

<p>
<pre>
{Examples:  
a) g &bull; g(-18, 12, -3)       
b) -18, 12, -3     
c) , 12, -3     
d) , -3 } 
</pre>

<p>
<a name=A34A1aa></a> {aa) A value <i>V</i> is output using a picture <i>P</i> whose pattern <i>Q</i> was yielded by a <b>general-pattern</b> <i>G</i>  as follows:  
<br>
&bull; <i>P</i> is staticized;  
<br>
&bull; the insertion of <i>Q</i> is performed;   
<br>
If <i>Q</i> is not parametrized (i.e., <i>Q</i> contains no <b>width-specification</b>) .    
<br>
then <i>V</i> is output using <tt>put</tt>;    
<br>
otherwise, if the mode of <i>V</i> is specified by <tt><b><i>L</i></b> INT</tt> or <tt><b><i>L</i></b>  REAL</tt> ,    
<br>
then    
<ul>
&bull; if <i>Q</i> contains one (two, three) parameter (s) , <i>V</i> is converted to a string using <tt>whole</tt> (<tt>fixed</tt>, <tt>float</tt>);    
<ul>
&bull; the string is written using <tt>put</tt>; 
</ul>
otherwise,    
<ul>
&bull; the event routine corresponding to <tt>on value error</tt> is called;     
<br>
&bull; if this returns <tt>false</tt>, <i>V</i> is output using <tt>put</tt>, and <tt>undefined</tt> is called;
</ul>
&bull; the insertion of <i>P</i> is performed.  
</ul>

<p>
<a name=A34A1bb></a>bb) A value is input to a name <i>N</i> using a <b>picture</b> <i>P</i> whose pattern is a <b>'general'</b> pattern as follows:  
<br>
&bull; <i>P</i> is staticized;  
<br>
&bull; (any parameters are ignored and) the value is input to <i>N</i> using <tt>get</tt>.}
 
<h3>
<a name=A34A2></a>10.3.4.10.2. Semantics
</h3> 

<p>
The yield, in an environ <i>E</i>, of a <b>NEST-general-pattern</b> <i>P</i> is a structured value whose mode is <b>'GPATTERN'</b> and whose fields, taken in order, are  
<br>
&bull; {<i>i</i>} the yield of the <b>insertion</b> of <i>P</i>:  
<br>
&bull; {<i>spec</i>} a multiple value <i>W</i> whose mode is <b>'row of procedure yielding integral'</b>, having a descriptor ((1, n)) , where <i>n</i> is the number of constituent <b>meek-integral-units</b> of the <b>width-specification-option</b> of <i>P</i>, and <i>n</i> elements determined as follows: For i = 1, ... n,  
<ul>
&bull; the <i>i</i>-th element of <i>W</i> is a routine, whose mode is <b>'procedure yielding integral'</b>, composed of a <b>procedure-yielding-integral-NEST-routine-text</b> whose <b>unit</b> <i>U</i>  is a new <b>unit</b> akin {<a href="report_1.html#1132k">1.1.3.2.k</a>} to the <i>i</i>-th of those <b>meek-integral-units</b>, together with the environ necessary for <i>U</i> in <i>E</i>.  
</ul>

<h3>
<a name=A35></a> 10.3.5. Formatted transput
</h3>

<a name=A35a></a>
<pre>
a) MODE FORMAT = STRUCT (FLEX [1: 0] PIECE <b>F</b>);
   MODE ? PIECE = STRUCT (INT cp &cent; pointer to current collection &cent;,
      count &cent; number of times piece is to be repeated&cent;,
      bp &cent; back pointer &cent;,
      FLEX [1 : 0] COLLECTION c);
   MODE ? COLLECTION = UNION (PICTURE, COLLITEM) :
   MODE ? COLLITEM = STRUCT (INSERTION i1,
      PROC INT rep; &cent; replicator &cent;,
      INT p &cent; pointer to another piece &cent;, INSERTION i2);
   MODE ? INSERTION = FLEX [1: 0] STRUCT (PROC INT rep &cent; replicator &cent;,
      UNION (STRING, CHAR) sa);
   MODE ? PICTURE =
      STRUCT (UNION (PATTERN, CPATTERN, FPATTERN, GPATTERN, VOID) p, INSERTION i);
   MODE ? PATTERN = STRUCT (INT type &cent; of pattern &cent;,   
      FLEX [1: 0] FRAME frames) ,
   MODE ? FRAME = STRUCT (INSERTION i,   
      PROC INT rep &cent; replicator &cent;,
      BOOL supp &cent; <tt>true</tt> if suppressed &cent;,
      CHAR marker);
   MODE ? CPATTERN = STRUCT (INSERTION i,
      INT type &cent; boolean or integral &cent;,
      FLEX [1 : 0] INSERTION c);
   MODE ? FPATTERN = STRUCT (INSERTION i, PROC FORMAT pf);
   MODE ? GPATTERN = STRUCT (INSERTION i, FLEX [1 : 0] PROC INT spec);
<a name=A35b></a>
b) PROC ? get next picture = (REF FILE f, BOOL read, REF PICTURE picture) VOID:
      BEGIN
      BOOL picture found := FALSE, format ended := FALSE;
      WHILE NOT picture found
      DO IF forp OF f = 0 THEN
            IF format ended
            THEN undefined
            ELIF NOT (format mended OF f) (f) 
            THEN REF INT (forp OF f) := 1;
               cp OF (<b>F</b> OF format OF f) [1] := 1;
               count OF (<b>F</b> OF format OF f) [1] := 1
            ELSE format ended := TRUE
            FI
         ELSE REF INT forp = forp OF f;
            REF FLEX [ ] PIECE aleph = <b>F</b> OF format OF f;
            CASE (c OF aleph [forp]) [cp OF aleph [forp]] IN
               (COLLITEM cl) :
                  ([1 : UPB (i1 OF cl) ] SINSERT si;
                   bp OF alph[p OF cl] := forp; forp := SKIP;
                   (staticize insertion ( i1 OF cl, si) ,
                      count OF aleph [p OF cl] := rep OF cl);
                   (aleph :&ne;: <b>F</b> OF format OF f | undefined);
                   (read | get insertion (f, si) | put insertion (f, si));
                   cp OF aleph[p OF cl] := 0;
                   forp := p OF cl) ,
               (PICTURE pict): (picture found := TRUE; picture := pict) 
            ESAC;
            WHILE
               (forp &ne; 0 | cp OF aleph[forp] = UPB c OF aleph[forp]) | FALSE) 
            DO IF (count OF aleph[forp] -:= 1) &le; 0
            THEN
               IF (forp := bp OF aleph [forp]) &ne; 0
               THEN
                  INSERTION extra =
                     CASE (c OF aleph [forp]) [cp OF aleph [forp]] IN
                     (COLLITEM cl) :
                        (bp OF aleph [p OF cl] := 0; i2 OF cl) ,
                     (PICTURE pict) :
                        CASE p OF pict IN
                           (FPATTERN fpatt):  
                              (INT k := forp;
                               WHILE bp OF aleph [k] &ne; forp DO k +:= 1 OD;
                               aleph := aleph [ : k - 1];
                               i OF pict) 
                        ESAC
                     ESAC;
                  INT m = UPB i OF picture, n = UPB extra;
                  [1 : m + n] STRUCT (PROC INT rep, UNION (STRING, CHAR) sa) c;
                  c[1 : m] := i OF picture; c[m + 1 : m + n] := extra;
                  i OF picture := c
                       FI
               ELSE cp OF aleph [forp] := 0
               FI OD;
               (forp &ne; 0 | cp OF aleph [forp] +:= 1) 
         FI OD
      END;
<a name=A35c></a>
c) MODE ? SINSERT = STRUCT (INT rep, UNION (STRING , CHAR) sa);
<a name=A35d></a>
d) PROC ? staticize insertion = (INSERTION ins, REF [ ] SINSERT sins) VOID:
      &cent; calls collaterally all the replicators in 'frames' &cent;
      IF UPB ins = 1  
      THEN
         rep OF sins[1] := rep OF ins[1];
         sa OF sins[1] := sa OF ins[1]
      ELIF UPB ins &gt; 1
      THEN (staticize insertion (ins[1], sins[1]) ,
              staticize insertion (ins[2 : ], sins[2 : ]) 
      FI;
<a name=A35e></a>
e) MODE ? SFRAME = STRUCT (FLEX [1 : 0 ] SINSERT si, INT rep, BOOL supp, CHAR marker);
<a name=A35f></a>
f) PROC ? staticize frames =
      ([ ] FRAME frames, REF [ ] SFRAME sframes) VOID:  
         &cent; calls collaterally all the replicators in 'frames' &cent;
      IF UPB frames = 1
      THEN
         [1 : UPB (i OF frames [1]) ] SINSERT si;
         (staticize insertion (i OF frames[1], si) ,
            rep OF sframes [1] := rep OF frames [1]);
         si OF sframes [1] := si;
         supp OF sframes [1] := supp OF frames [1];
         marker OF sframes [1] := marker OF frames[1]
      ELIF UPB frames &gt; 1
      THEN (staticize frames (frames[1], sframes[1]) .
              staticize frames (frames[2 : ], sframes[2 : ])) 
      FI;
<a name=A35g></a>
g) PROC ? put insertion = (REF FILE f, [ ] SINSERT si) VOID:
      BEGIN set write mood (f);
         FOR k TO UPB si
         DO
            CASE sa OF si[k] IN
               (CHAR a): alignment (f, rep OF si[k], a, FALSE) ,
               (STRING s) :
                  TO rep OF si[k]
                  DO
                     FOR i TO UPB s
                     DO checkpos (f); putchar (f, s[i]) OD
                  OD
            ESAC          
         OD
      END;
<a name=A35h></a>
h) PROC ? get insertion (REF FILE f, [ ] SINSERT si) VOID:
      BEGIN set read mood (f);
         FOR k TO UPB si
         DO
            CASE sa OF si[k] IN
               (CHAR a): alignment (f, rep OF si [k], a, TRUE) ,
               (STRING s) :
                  (CHAR c;
                   TO rep OF si[k]
                   DO
                      FOR i TO UPB s
                      DO checkpos (f); get char (f, c);
                         (c &ne; s[i]
                         | (NOT (char error mended OF f) (f, c := s[i]) 
                         | undefined);
                         set read mood (f)) 
                      OD
                   OD) 
            ESAC  
         OD
      END;
<a name=A35i></a>
i) PROC ? alignment = (REF FILE f, INT r, CHAR a, BOOL read) VOID:
      IF a = "x" THEN TO r DO space (f) OD
      ELIF a = "y" THEN TO r DO backspace (f) OD
      ELIF a = "l" THEN TO r DO newline (f) OD
      ELIF a = "p" THEN TO r DO newpage (f) OD
      ELIF a = "k" THEN set char number (f, r) 
      ELIF a = "q" 
      THEN TO r
         DO
            IF read
            THEN CHAR c; check pos (f); get char (f, c);
               (c &ne; blank
               | (NOT (char error mended OF f) (f, c := blank) 
               | undefined); set read mood (f)) 
            ELSE check pos (f); put char (f, blank) 
            FI
         OD 
      FI;
<a name=A35j></a>
j) PROC ? do fpattern = (REF FILE f, FPATTERN fpattern, BOOL read) VOID:
      BEGIN FORMAT pf;
         [1 : UPB (i OF fpattern) ] SINSERT si;
         (staticize insertion (i OF fpattern, si) , 
            pf := pf OF fpattern);
         (read | get insertion (f, si) | put insertion (f, si));
         REF INT forp = forp OF f;
         REF FLEX [ ] PIECE aleph = <b>F</b> OF format OF f;
         INT m = UPB aleph, n = UPB (<b>F</b> OF pf);
         [1 : m + n] PIECE c; c[1 : m] := aleph;
         c[m + 1 : m + n] := <b>F</b> OF pf;
         aleph := c; bp OF aleph[m + 1] := forp;
         forp := m + 1; cp OF aleph[forp] := 0;
         count OF aleph[forp] := 1;
         FOR i FROM m + 1 TO m + n
         DO
            FOR j TO UPB c OF aleph[i]
            DO
               CASE (c OF aleph[i]) [j] IN
                  (c OF aleph[i]) [j] := 
                     COLLITEM (i1 OF cl, rep OF cl, p OF cl + m, i2 OF cl) 
               ESAC
            OD
         OD
     END;
<a name=A35k></a>
k) PROC ? associate format = (REF FILE f, FORMAT format) VOID:
      BEGIN 
         format OF f :=
            <b>C</b> a newly created name which is made to refer to the yield
            of an actual-format-declarer and whose scope is equal to
            the scope of the value yielded by 'format' <b>C</b>
               := format;
         forp OF f := HEAP INT := 1;
         cp OF (<b>F</b> OF format OF f) [1] := 1;
         count OF (<b>F</b> OF format OF f) [1] := 1;
         bp OF OF (<b>F</b> OF format OF f) [1] := 1
      END;
</pre>  

<h3>
<a name=A351></a>10.3.5.1. Formatted output
</h3>

<a name=A351a></a>
<pre>
a) PROC putf = (REF FILE f, [ ] UNION (OUTTYPE, FORMAT) x) VOID:
      IF opened OF f THEN       
      FOR k TO UPB x
      DO CASE set write mood (f); set char mood (f); x[k] IN
         (FORMAT format): associate format (f, format) ,
         (OUTTYPE ot) :
         BEGIN INT j := 0;
            PICTURE picture, [ ] SIMPLOUT y = STRAIGHTOUT ot;
            WHILE (j +:= 1) &le; UPB y
            DO BOOL incomp := FALSE;
               get next picture (f, FALSE, picture);
               set write mood (f);
               [1 : UPB (i OF picture) ] SINSERT sinsert;
               CASE p OF picture IN
               (PATTERN pattern) :
               BEGIN INT rep, sfp := 1; 
                  [1 : UPB (frames OF pattern) ] SFRAME sframes;
                  (staticize frames (frames OF pattern, sframes) ,
                     staticize insertion (i OF picture, sinsert));
                  STRING s;
                  
                  OP ? = (STRING s) BOOL:
                     &cent; <tt>true</tt> if the next marker is one of the elements of 
                        's' and <tt>false</tt> otherwise &cent;
                     IF sfp &gt; UPB sframes
                     THEN FALSE
                     ELSE SFRAME sf = sframes[sfp];
                        rep := rep OF sf:
                        IF char in string (marker OF sf, LOC INT, s) 
                        THEN sfp +:= 1; TRUE
                        ELSE FALSE
                        FI
                     FI;

                  OP ? = (CHAR c) BOOL: ? STRING (c);

                  PROC int pattern (REF BOOL sign mould) INT:
                     (INT l := 0;
                      WHILE ? "zuv" DO (rep &ge; 0 | l +:= rep) OD;
                      sign mould := ? "+-";
                      WHILE ? "zd" DO (rep &ge; 0 | l +:= rep) OD; l);
                             
                  &laquo;PROC edit <i>L</i> int (<b><i>L</i></b> INT i) VOID:
                            (BOOL sign mould; INT l := int pattern (sign mould);
                             STRING t = subwhole (ABS i, l);
                             IF char in string (errorchar, LOC INT, t) OR l = 0
                                   OR NOT sign mould AND i &lt; <i>L</i> 0
                             THEN incomp := TRUE
                             ELSE t PLUSTO s;
                                (l - UPB t) &times; "0" PLUSTO s;
                                (sign mould | (i &lt; <i>L</i> 0 | "-" | "+") PLUSTO s) 
                             FI) &raquo;;
   
                  &laquo;PROC edit <i>L</i> real (<b><i>L</i></b>  REAL r) VOID:
                            (INT b := 0, a := 0, e := 0, exp := 0, <b><i>L</i></b>  REAL y := ABS r,
                             BOOL sign1, STRING point := "";
                             b := int pattern (sign1);
                             (? "." | a := int pattern (LOC BOOL); point := ".");
                             IF ? "e"
                             THEN <i>L</i> standardize (y, b, a, exp);
                                edit int (exp);
                                "<sub>10</sub>" PLUSTO s
                             FI;
                             STRING t = subfixed (y, b + a + (a &ne; 0 | 1 | 0) , a);
                             IF char in string (errorchar, LOC INT, t) OR a + b = 0
                                   OR NOT sign1 AND r &lt; <i>L</i> 0 AND exp &lt; 0
                             THEN incomp := TRUE
                             ELSE t[ : b] + point + t[b + 2 : ] PLUSTO s;
                                (b + a + (a &ne; 0 | 1 | 0) - UPB t) &times; "0" PLUSTO s;
                                (sign1 | (r &lt; <i>L</i> 0 | "-" | "+") PLUSTO s) 
                             FI) &raquo;;
                         
                  &laquo;PROC edit <i>L</i> compl = (<b><i>L</i></b> COMPL z) VOID:
                            (WHILE NOT ? "i" DO sfp +:= 1 OD; edit <i>L</i> real (IM z);
                             "I" PLUSTO s; sfp := 1; edit <i>L</i> real (RE z)) &raquo;;
                           
                  &laquo;PROC edit <i>L</i> bits (<b><i>L</i></b> BITS lb, INT radix) VOID:
                            (<b><i>L</i></b> INT n := ABS lb; ? "r"; INT l := intpattern (LOC BOOL);
                             WHILE dig char (<b>S</b> (n MOD <b>K</b> radix)) PLUSTO s;
                                 n %:= <b>K</b> radix; n &ne; <i>L</i> 0
                             DO SKIP OD;   
                             IF UPB s &le; l
                             THEN (l - UPB s) &times; "0" PLUSTO s
                             ELSE incomp := TRUE
                             FI) &raquo;;
                        
                  PROC charcount = INT: (INT l := 0; 
                     WHILE ? "a" DO (rep &ge; 0 | l +:= rep) OD; l);
                             
                  CASE type OF pattern IN
               &cent; integral &cent;
                     (y[j] |
                     &laquo; (<b><i>L</i></b> INT i): edit <i>L</i> int (i) &raquo;
                     | incomp := TRUE) ,
               &cent; real &cent;
                     (y[j] |
                     &laquo; (<b><i>L</i></b>  REAL r): edit <i>L</i> real (r) &raquo;
                     &laquo; (<b><i>L</i></b> INT i): edit <i>L</i> real (i) &raquo;
                     | incomp := TRUE) ,
               &cent; boolean &cent;
                     (y[j] |
                     (BOOL b): s := (b | flip | flop) 
                     | incomp := TRUE) ,
               &cent; complex &cent;
                     (y[j] |
                     &laquo; ( <b><i>L</i></b> COMPLEX z): edit <i>L</i> complex (z) &raquo;
                     &laquo; (<b><i>L</i></b>  REAL r): edit <i>L</i> complex (r) &raquo;
                     &laquo; (<b><i>L</i></b> INT i): edit <i>L</i> complex (i) &raquo;
                     | incomp := TRUE) ,
               &cent; string &cent;
                     (y[j] |
                     (CHAR c): (charcount = 1 | s := c | incomp := TRUE) ,
                     ([ ] CHAR t) :
                        (charcount = UPB t - LWB t + 1
                        | s := t[@1]
                        | incomp := TRUE) 
                             | incomp := TRUE)  
                  OUT
               &cent; bits &cent;
                     (y[j] |
                     &laquo; (<b><i>L</i></b> BITS lb): edit <i>L</i> bits (lb, type OF pattern - 4) &raquo;
                     | incomp := TRUE) 
                  ESAC;
                  IF NOT incomp
                  THEN edit string (f, s, sframes) 
                  FI
               END,
               (CPATTERN choice) :
               BEGIN
                  [1 : UPB (i OF choice)] SINSERT si;
                  staticize insertion (i OF choice, si) :
                  put insertion (f, si);
                  INT l =
                     CASE type OF choice IN
                  &cent; boolean &cent;
                        (y [j] |
                        (BOOL b): (b | 1 | 2) 
                        | incomp := TRUE; SKIP) ,
                  &cent; integral &cent;
                        (y [j] |
                        (INT i): i   
                        | incomp := TRUE; SKIP) 
                     ESAC;
                     IF NOT incomp
                     THEN
                        IF l &gt; UPB (c OF choice) OR l &le; 0
                        THEN incomp := TRUE
                        ELSE
                           [1 : UPB ((c OF choice) [l])) SINSERT ci:
                           staticize insertion ((c OF choice) [l], ci);
                           put insertion (f, ci) 
                        FI
                     FI;
                     staticize insertion (i OF picture, sinsert) 
               END,
               (FPATTERN fpattern:
               BEGIN
                  do fpattern (f, fpattern, FALSE);
                  FOR TO UPB sinsert DO sinsert[i] := (0, "") OD;
               END,
               (GPATTERN gpattern) :
               BEGIN
                  [1 : UPB (i OF gpattern) ] SINSERT si;
                  [ ] PROC INT spec = spec OF gpattern; INT n = UPB spec;
                  [1 : n] INT s;  
                  (staticize insertion (i OF gpattern, si) ,
                     staticize insertion (i OF picture, sinsert) ,
                     s := (n | spec[1], (spec[1], spec[2]) ,
                          (spec[1], spec[2], spec[3]) | ()));
                  put insertion (f, si);
                  IF n = 0 THEN put (f, y[j]) 
                  ELSE
                     NUMBER yj =
                        (y[j] | &laquo; (<b><i>L</i></b> INT i): i&raquo;, &laquo; (<b><i>L</i></b>  REAL r): r&raquo;
                        | incomp := TRUE; SKIP);
                     IF NOT incomp
                     THEN CASE n IN
                        put (f, whole (yj, s[1])) ,
                        put (f, fixed (yj, s[1], s[2])) ,
                        put (f, float (yj, s[1], s[2], s[3])) 
                        ESAC
                     FI
                  FI
               END,
               (VOID) :
                  (j -:= 1; staticize insertion (i OF picture, sinsert)) 
               ESAC;
               IF incomp
               THEN set write mood (f);
                  (NOT (value error mended OF f) (f) | put (f, y [j]) :
                     undefined) 
               FI;
               put insertion (f, sinsert) 
            OD
         END
      ESAC OD
      ELSE undefined
      FI;
<a name=A351b></a>
b) PROC ? edit string (REF FILE f, STRING s, [ ] SFRAME sf) VOID:
      BEGIN BOOL supp, zs := TRUE, signput := FALSE, again, INT j := 0, sign;
         PROC copy = (CHAR c) VOID:
            (NOT supp | check pos (f); put char (f, c));
         FOR k TO UPB sf
         DO SFRAME sfk = sf[k]; supp := supp OF sfk:
            put insertion (f, si OF sfk);
            TO rep OF sfk
            DO again := TRUE;
               WHILE again
               DO j +:= 1; again := FALSE;
                  CHAR sj = s[j], marker = marker OF sfk;
                  IF marker = "d"
                  THEN copy (sj); zs := TRUE
                  ELIF marker = "z" THEN
                       (sj = "0" | copy ((zs | " " | sj)) 
                       |: sj = "+" | again := TRUE
                       | zs := FALSE; copy (sj)) 
                  ELIF marker = "u" OR marker = "v" THEN
                       (sj = "+" | sign := 1; again := TRUE
                       |: sj = "-" | sign := 2; again := TRUE
                       |: sj = "0" | copy ((zs | " " | sj)) 
                       | (NOT signput |
                         copy ((sign | (marker = "u" | "+" | " ") , "-"));
                         signput := TRUE);
                         copy (sj); zs := FALSE) 
                  ELIF marker = "+" then
                       (sj = "+" OR sj = "-" | copy (sj) 
                       | (NOT signput | copy ((sign | "+", "-")));
                          j -:= 1) 
                  ELIF marker = "-" THEN
                       (sj = "+" | copy (" ") 
                       |: sj = "-" | copy (sj) 
                       | (NOT signput | copy ((sign | " ", "-")));
                          j -:= 1) 
                  ELIF marker = "." THEN
                       copy (".") 
                  ELIF marker = "e" OR marker = "i"  
                       OR marker = "a" OR marker = "b"
                  THEN copy (sj); zs := TRUE; signput := FALSE
                  ELIF marker = "r"
                  THEN j -:= 1
                  FI
               OD
            OD
         OD
      END;
</pre>

<h3>
<a name=A352></a> 10.3.5.2. Formatted input
</h3>

<a name=A352a></a>
<pre>
a) PROC getf = (REF FILE f, [ ] UNION (INTYPE, FORMAT) x) VOID:
      IF opened OF f THEN
         FOR k TO UPB x
         DO CASE set read mood (f); set char mood (f); x[k] IN
            (FORMAT format): associate format (f, format) ,
            (INTYPE it) :
            BEGIN INT j := 0;
               PICTURE picture, [ ] SIMPLIN y = STRAIGHTIN it;
               WHILE (j +:=- 1) &le; UPB y
               DO BOOL incomp := FALSE;
                  get next picture (f, TRUE, picture); set read mood (f);
                  [1 : UPB (i OF picture) ] SINSERT sinsert;
                  CASE p OF picture IN
                  (PATTERN pattern) :
                  BEGIN
                     [1 : UPB (frames OF pattern) ] SFRAME sframes;
                     (staticize frames (frames OF pattern, sframes) ,
                        staticize insertion (i OF picture, sinsert));
                     STRING s;
                     INT radix =
                        (type OF pattern &ge; 6 | type OF pattern - 4 | 10);
                     indit string (f, s, sframes, radix);
                     CASE type OF pattern IN
                  &cent; integral &cent;
                        (y[j] |
                        &laquo; (REF <b><i>L</i></b> INT ii) :
                        incomp := NOT string to <i>L</i> int (s, 10, ii) &raquo;
                        | incomp := TRUE) ,
                  &cent; real &cent;
                        (y[j] |
                        &laquo; (REF <b><i>L</i></b>  REAL rr) :
                           incomp := NOT string to <i>L</i> real (s, rr) &raquo;
                        | incomp := TRUE) ,
                  &cent; boolean &cent;
                        (y[j] |
                        (REF BOOL bb): bb := s = flip
                        | incomp := TRUE) ,
                  &cent; complex &cent;
                        (y[j] |
                        &laquo; (REF <b><i>L</i></b> COMPL zz) :
                           (INT i, BOOL bi, b2; char in string ("I", i, s);
                            b1 := string to <i>L</i> real (s [ : i - 1], re OF zz);
                            b2 := string to <i>L</i> real (s [i + 1 : ], im OF zz);
                            incomp := NOT (b1 AND b2)) &raquo;
                        | incomp := TRUE) ,
                  &cent; string &cent;
                        (y[j] |
                        (REF CHAR cc) :
                           (UPB s = 1 | cc := s[1] | incomp := TRUE) ,
                        (REF [ ] CHAR ss) :
                           (UPB ss - LWB ss + 1 = UPB s | ss[@1] := s
                           | incomp := TRUE) ,
                        (REF STRING ss): ss := s
                        | incomp := TRUE) 
                     OUT
                  &cent; bits &cent;
                        (y[j] |
                        &laquo; (REF <b><i>L</i></b> BITS lb) :
                           IF <b><i>L</i></b> INT i; string to <i>L</i> int (s, radix, i) 
                           THEN lb := BIN i
                           ELSE incomp := TRUE
                           FI&raquo;
                        | incomp := TRUE) 
                     ESAC
                  END, 
                  (CPATTERN choice) :
                  BEGIN
                     [1 : UPB (i OF choice) SINSERT si;
                     staticize insertion (i OF choice, si);
                     get insertion (f, si);
                     INT c = c OF cpos OF f, CHAR kk;
                     INT k := 0, BOOL found := FALSE;
                     WHILE k &lt; UPB (c OF choice) AND NOT found
                     DO k +:= 1;
                        [1 : UPB ((c OF choice) [k]) ] SINSERT si;
                        BOOL bool := TRUE;
                        staticize insertion ((c OF choice, [k], si);
                        STRING s;
                        FOR i TO UPB si
                        DO s PLUSAB
                           (sa OF si[i] | (STRING ss): ss) &times; rep OF si[i]
                        OD;   
                        FOR jj TO UPB s
                        WHILE bool := bool AND NOT line ended (f) 
                           AND NOT logical file ended (f) 
                        DO get char (f, kk); bool := kk = s[jj] OD;
                        (NOT (found := bool) | set char number (f, c)) 
                     OD; 
                     IF NOT found THEN incomp := TRUE
                     ELSE
                        CASE type OF choice IN
                     &cent; boolean &cent;
                           (y [j] |
                           (REF BOOL b): b := k = 1
                           | incomp := TRUE) ,
                     &cent; integral &cent;
                           (y [j] |
                           (REF INT i): i := k
                           | incomp := TRUE) 
                        ESAC
                     FI;
                     staticize insertion (i OF picture, sinsert) 
                  END,
                  (FPATTERN fpattern): 
                  BEGIN do fpattern (f, fpattern, TRUE);
                     FOR i TO UPB sinsert DO sinsert [i] := (0, "") OD;
                     j -:= 1
                  END,
                  (GPATTERN gpattern) :
                     ([1 : UPB (i OF gpattern) ] SINSERT si;
                     (staticize insertion (i OF gpattern, si) ,
                        staticize insertion (i OF picture, sinsert));
                     get insertion (f, si);
                     get (f, y[j])) ,
                  (VOID) :
                     (j -:= 1; staticize insertion (i OF picture, sinsert)) 
                  ESAC;
                  IF incomp
                  THEN set read mood (f);
                     (NOT (value error mended OF f) (f) | undefined) 
                  FI;
                  get insertion (f, sinsert) 
               OD
            END
         ESAC OD
      ELSE undefined
      FI;
<a name=A352b></a>
b) PROC ? indit string = (REF FILE f, REF STRING s, [ ] SFRAME sf, INT radix) VOID:
      BEGIN
         BOOL supp, zs := TRUE, sign found := FALSE, space found := FALSE,
            nosign := FALSE, INT sp := 1, rep;
         PRIO ! = 8;
                         
         OP ! = (STRING s, CHAR c) CHAR :
               &cent; expects a character contained in 's'; if the character
               read is not in 's', the event routine corresponding to 'on
               char error' is called with the suggestion 'c' &cent;
            IF CHAR k; checkpos (f); get char (f, k);
               char in string (k, LOC INT, s) 
            THEN k
            ELSE CHAR sugg := c;
               IF (char error mended OF f) (f, sugg) THEN
                   (char in string (sugg, LOC INT, s) | sugg | undefined; c) 
               ELSE undefined; c   
               FI;
               set read mood (f);
            <var>[[above five lines should read
               CHAR cc = IF (char error mended OF f) (f, sugg) THEN
                  (char in string (sugg, LOC INT, s) | sugg | undefined; c) 
                 ELSE undefined; c
                 FI;
               set read mood (f); cc]]</var>
            FI;

         OP ! = (CHAR s, c) CHAR: STRING (s) ! c;

         [ ] CHAR good digits = "0123456789abcdef"[ : radix];
         s := "+";
         FOR k TO UPB sf
         DO SFRAME sfk = sf[k]; supp := supp OF fsk;
            get insertion (f, si OF sfk);  
            TO rep OF sfk
            DO CHAR marker = marker OF sfk;
               IF marker = "d" THEN
                  s PLUSAB (supp | "0" | good digits ! "0"); zs := TRUE
                 ELIF marker = "z" THEN
                    s PLUSAB (supp | "0"   
                       | CHAR c = ((zs | " " | "") + good digits) ! "0";
                          (c &ne; " " | zs := FALSE); c) 
                 ELIF marker = "u" OR marker = "+" THEN
                      IF sign found
                      THEN zs := FALSE; a PLUSAB ("0123456789" ! "0") 
                      ELSE CHAR c = ("+-" + (marker = "u" | " " | "")) ! "+";
                         (c = "+" OR c = "-" | sign found := TRUE; s[sp] := c) 
                      FI
                 ELIF marker = "v" OR marker = "-" THEN
                      IF sign found
                      THEN zs := FALSE; z PLUSAB ("0123456789" ! "0") 
                      ELIF CHAR c; space found
                      THEN c := "+- 0123456789" ! "+";
                         (c = "+" OR c = "-" | sign found := TRUE; s[sp] := c
                         |: c &ne; " " | zs := FALSE; sign found := TRUE; s PLUSAB c) 
                      ELSE c := "+- " ! "+";
                         (c = "+" OR c = "-" | sign found := TRUE; s[sp] := c
                         | space found := TRUE) 
                      FI
                 ELIF marker ="." THEN
                      s PLUSAB (supp | "." | "."! ".") 
                 ELIF marker = "e" THEN
                      s PLUSAB (supp | "<sub>10</sub>" | "<sub>10</sub>\e" ! "<sub>10</sub>"; "<sub>10</sub>"); sign found := FALSE;
                      zs := TRUE; s PLUSAB "+"; sp := UPB s
                 ELIF marker = "i" THEN  
                      s PLUSAB (supp | "I" | "iI"! "I"; "I");
                      sign found := FALSE; zs := TRUE; s PLUSAB "+"; sp := UPB s
                 ELIF marker = "b" THEN  
                      s PLUSAB (flip + flop) ! flop; no sign := TRUE
                 ELIF marker = "a" THEN
                      s PLUSAB (supp | " " | CHAR c; check pos (f); get char (f, c);
                      c);
                      no sign := TRUE
                 ELIF marker = "r"
                 THEN SKIP
                 FI
            OD
         OD;
         IF no sign THEN s := s[2 : ] FI
      END;
</pre>  

<h3>
<a name=A36></a>10.3.6. Binary transput
</h3>

<p>
{In binary transput, the values obtained by straightening the elements of a data list (cf. <a href="#A33">10.3.3</a>) are transput, via the specified file, one after the other. The manner in which such a value is stored in the book is defined only to the extent that a value of mode <i>M</i> (being some mode from which that specified by <tt>SIMPLOUT</tt> is united) output at a given position may subsequently be re-input from that same position to a name of mode <b>'reference to <i>M</i>'</b>. Note that, during input to the name referring to a multiple value, the number of elements read will be the existing number of elements referred to by that name.  

<p>
The current position is advanced after each value by a suitable amount and, at the end of each line or page, the appropriate event routine is called, and next, if this returns <tt>false</tt>, the next good character position of the book is found (cf. <a href="#A33">10.3.3</a>) .  

<p>
For binary output, <tt>put bin</tt> (<a href="#A361a">10.3.6.1.a</a>) and <tt>write bin</tt> (<a href="#A51h">10.5.1.h</a>) may be used and, for binary input, <tt>get bin</tt> (<a href="#A362a">10.3.6.2.a</a>) and <tt>read bin</tt> (<a href="#A51i">10.5.1.i</a>).}  

<a name=A36a></a>
<pre>
a) PROC ? to bin = (REF FILE f, SIMPLOUT x) [ ] CHAR:
      <b>C</b> a value of mode 'row of character' whose lower bound is one
         and whose upper bound depends on the value of 'book OF f'
         and on the mode and the value of 'x';  furthermore,
         x = from bin (f, x, to bin (f, x)) <b>C</b>;  
<a name=A36b></a>
b) PROC ? from bin = (REF FILE f, SIMPLOUT y. [ ] CHAR c) SIMPLOUT: 
      <b>C</b> a value, if one exists, of the mode of the value yielded by 'y',
         such that c = to bin (f, from bin (f, y, c)) <b>C</b>;
</pre>

<h3>
<a name=A361></a> 10.3.6.1. Binary output
</h3>

<a name=A361a></a>
<pre>
a) PROC put bin = (REF FILE f, [ ] OUTTYPE ot) VOID:
      IF opened OF f THEN 
         set bin mood (f); 
         set write mood (f); 
         FOR k TO UPB ot DO 
             [ ] SIMPLOUT y = STRAIGHTOUT ot [k]; 
             FOR j TO UPB y DO 
                 [ ] CHAR bin = to bin (f, y[j]); 
                 FOR i TO UPB bin DO 
                     next pos (f); 
                     set bin mood (f); 
                     REF POS cpos = cpos OF f, lpos = lpos OF book OF f; 
                     CASE text OF f IN 
                        (FLEXTEXT t2): t2 [p OF cpos ] [l OF cpos] [c OF cpos] := bin [i] 
                     ESAC; 
                     c OF cpos+:= 1; 
                     IF cpos BEYOND lpos THEN 
                        lpos := cpos 
                     ELIF NOT set possible (f) AND POS (p OF lpos, l OF lpos, 1) BEYOND cpos THEN 
                          lpos := cpos; (compressible (f) | <b>C</b> the size of the line and page containing the
                                                               logical end of the book and of all
                                                               subsequent lines and pages may be
                                                               increased <b>C</b>) 
                     FI
                 OD
             OD
         OD 
      ELSE undefined
      FI;
</pre>
 
<h3>
<a name=A362></a>10.3.6.2. Binary input
</h3>

<a name=A362a></a>
<pre>
a) PROC get bin = (REF FILE f, [ ] INTYPE it) VOID:
      IF opened OF f THEN
         set bin mood (f); set read mood (f);  
         FOR k TO UPB it
         DO [ ] SIMPLIN y = STRAIGHTIN it [k];
            FOR j TO UPB y
            DO
               SIMPLOUT yj = CASE y[j] IN
                  &laquo; (REF <b><i>L</i></b> INT i): i&raquo;,
                  &laquo; (REF <b><i>L</i></b>  REAL r): r&raquo;,
                  &laquo; (REF <b><i>L</i></b> COMPL z): z&raquo;,
                  (REF BOOL b): b,
                  &laquo; (REF <b><i>L</i></b> BITS lb): lb&raquo;,
                  (REF CHAR c): c, 
                  (REF [ ] CHAR s): s,
                  (REF STRING ss): ss ESAC;
               [1 : UPB (to bin (f, yj)) ] CHAR bin;
               FOR i TO UPB bin
               DO next pos (f); set bin mood (f);
                  REF POS cpos = cpos OF f;
                  bin[i] :=
                     CASE text OF f IN
                        (FLEXTEXT t2) :
                           t2[p OF cpos][l OF cpos][c OF cpos]
                     ESAC;
                  c OF cpos +:= 1
               OD;
               CASE y[j] IN
                  &laquo; (REF <b><i>L</i></b> INT ii): (from bin (f, ii, bin) | (<b><i>L</i></b> INT i): ii := i) &raquo;,
                  &laquo; (REF <b><i>L</i></b>  REAL rr) :
                     (from bin (f, rr, bin) | (<b><i>L</i></b>  REAL r): rr := r) &raquo;,
                  &laquo; (REF <b><i>L</i></b> COMPL zz) :
                     (from bin (f, zz, bin) | (<b><i>L</i></b> COMPL z): zz := z) &raquo;,
                  (REF BOOL bb): (from bin (f, bb, bin) | (BOOL b): bb := b) ,
                  &laquo; (REF <b><i>L</i></b> BITS lb) :
                     (from bin (f, lb, bin) | (<b><i>L</i></b> BITS b): lb := b) &raquo;,  
                  (REF CHAR cc): ( from bin (f, cc, bin) | (CHAR c): cc := c) ,
                  (REF [ ]CHAR ss) :
                     (from bin (f, ss, bin) | ([ ] CHAR s): ss := s) ,
                  (REF STRING ssss) :
                     (from bin (f, ssss, bin) | ([ ] CHAR s): ssss := s) 
               ESAC
            OD
         OD
      ELSE undefined
      FI;
</pre>

<div align=right> 

<p>
{But Eeyore wasn't listening. He was taking<br>
  the balloon out, and putting it back again,<br>
  as happy as could be. ...<br>
  Winnie-the-Pooh, A.A.Milne.} 

<p>
{
<br>
<IMG alt=eeyore src="rr.eeyore.png" name=eeyore><p>
}
</div>
  
<h3>
<a name=A4></a>10.4. The system prelude and task list
</h3>

<h3>
<a name=A41></a> 10.4.1. The system prelude
</h3>

<p>
The representation of the <b>system-prelude</b> is obtained from the following form, to which may be added further forms not defined in this Report. {The syntax of <b>program-texts</b>  ensures that a <b>declaration</b> contained in the <b>system-prelude</b> may not contradict any <b>declaration</b> contained in the <b>standard-prelude</b>. It is intended that the further forms should contain declarations that are needed for the correct operation of any <b>system-tasks</b> that may be added (by the implementer, as provided in <a href="#A12d">10.1.2.d</a>) .}  

<a name=A41a></a>
<pre>
a) SEMA ? gremlins = (SEMA s; <b>F</b> OF s := PRIM INT :=  0; s);
</pre>  

<h3>
<a name=A42></a>10.4.2. The system task list
</h3>

<p>
The representation of the {first}  constituent <b>system-task</b> or the <b>system-task-list</b> is obtained from the following form. The other <b>system-tasks</b>, if any, are not defined by this Report {but may be defined by the implementer in order to account for the particular features of his operating environment, especially in so far as they interact with the running of <b>particular-programs</b> (see, e.g., <a href="#A311dd">10.3.1.1.dd</a>) } .  

<a name=A42a></a>
<pre>
a) DO DOWN gremlins; undefined; UP bfileprotect OD
</pre>   

<p>
{The intention is that this call of <tt>undefined</tt>, which is released by an <tt>UP gremlins</tt> whenever a book is closed, may reorganize the chain of backfiles and the chain of locked backfiles, such as by removing the book if it is not to be available for further opening, or by inserting it into the chain of backfiles several times over if it is to be permitted for several <b>particular-programs</b> to read it simultaneously. Note that, when an <tt>UP gremlins</tt> is given, <tt>bfileprotect</tt> is always down and remains so until such reorganization has taken place.}   

<div align=right> 
{From ghoulies and ghosties and long-leggety beasties<br>
and things that go bump in the night,<br>
Good Lord, deliver us!<br>
Ancient Cornish litany} 
</div>
  

<h3>
<a name=A5></a>10.5. The particular preludes and postludes
</h3>
 
<h3>
<a name=A51></a> 10.5.1. The particular preludes
</h3>

<p>
The representation of the <b>particular-prelude</b> of each <b>user-task</b> is obtained from the following forms, to which may be added such other forms as may be needed for the proper functioning of the facilities defined in the constituent <b>library-prelude</b> of the <b>program-text</b> {, e.g., <b>declarations</b>  and calls of <tt>open</tt> for additional standard files}. However, for each <b>QUALITY-new-new-PROPS1-LAYER2-defining-indicator-with-TAX</b> contained in such an additional form, the predicate <b>'where QUALITY TAX independent PROPS1'</b> (<a href="report_3.html#711a">7.1.1.a, c</a>) must hold {i.e., no <b>declaration</b> contained in the <b>standard-prelude</b> may be contradicted} . 

<a name=A51a></a>
<pre>
a) <b><i>L</i></b> INT <i>L</i> last random := ROUND (<i>L</i> maxint / <i>L</i>  2);  
<a name=A51b></a>
b) PROC <i>L</i> random = <b><i>L</i></b>  REAL: <i>L</i> next random (<i>L</i> last random);
<a name=A51c></a>
c) FILE stand in, stand out, stand back;
   open (stand in,  "", stand in channel);
   open (stand out, "", stand out channel);
   open (stand back,  "", stand back channel);
<a name=A51d></a>
d) PROC print = ([ ] UNION (OUTTYPE, PROC (REF FILE) VOID) x) VOID:
      put (stand out, x) , 
   PROC write = ([ ] UNION (OUTTYPE, PROC (REF FILE) VOID) x) VOID:
      put (stand out, x); 
<a name=A51e></a>
e) PROC read = ([ ] UNION (INTYPE, PROC (REF FILE) VOID) x) VOID:
      get (stand in, x); 
<a name=A51f></a>
f) PROC printf = ([ ] UNION (OUTTYPE, FORMAT) x) VOID:
      putf (stand out, x) , 
   PROC writef = ([ ] UNION (OUTTYPE, FORMAT) x) VOID:
      putf (stand out, x);
<a name=A51g></a>
g) PROC readf = ([ ] UNION (INTYPE, FORMAT) x) VOID:
      getf (stand in, x);  
<a name=A51h></a>
h) PROC write bin = ([ ] OUTTYPE x) VOID:
      put bin (stand back, x);  
<a name=A51i></a>
i) PROC read bin = ([ ] INTYPE x) VOID:
     get bin (stand back, x);
</pre>

<h3>
<a name=A52></a>10.5.2. The particular postludes
</h3>

<p>
The representation of the <b>particular-postlude</b> of each <b>user-task</b> is obtained from the following form, to which may be added such other forms as may be needed for the proper functioning of the facilities defined in the constituent <b>library-prelude</b> of the <b>program-text</b> {, e.g., <b>calls</b> of <tt>lock</tt> for additional standard files}.  

<a name=A52a></a>
<pre>
a) stop: lock (stand in); lock (stand out); lock (stand back)   
</pre>

<h3>
<a name=B></a>11. Examples
</h3>

<h3>
<a name=B1></a>11.1. Complex square root
</h3>

<pre>
PROC compsqrt = (COMPL z) COMPL :
   &cent; the square root whose real part is nonnegative of the complex number 'z' &cent;
   BEGIN REAL x = RE z, y = IM z;
       REAL rp = sqrt ((ABS x + sqrt (x &uarr; 2 + y &uarr; 2)) / 2);
       REAL ip = (rp = 0 | 0 | y / (2 &times; rp));
       IF x &ge; 0 THEN rp I ip ELSE ABS ip I (y &ge; 0 | rp | -rp) FI
   END
</pre>

<p>
<b>Calls</b> {<a href="report_2.html#543">5.4.3</a>} using <tt>compsqrt</tt>:  
<pre>
compsqrt (w) 
compsqrt (-3.14) 
compsqrt (-1) 
</pre>  

<h3>
<a name=B2></a>11.2. Innerproduct 1
</h3>

<pre>
PROC innerproduct1 = INT n, PROC INT) REAL x, y) REAL :
      &cent; the innerproduct of two vectors, each with 'n' components, x (i) ,
      y (i) , i = 1, ..., n, where 'x' and 'y' are arbitrary mappings
      from integer to real numbers &cent;
   BEGIN LONG REAL s := LONG 0;
       FOR i TO n DO s +:= LENG x (i) &times; LENG y (i) OD;
       SHORTEN s
   END
</pre>

<p>
<b>Real-calls</b> using <tt>innerproduct 1</tt>:
 
<pre>
innerproduct1 (m, (INT j) REAL: x1[j], (INT j) REAL: y1[j]) 
innerproduct1 (n, nsin, ncos) 
</pre>

<h3>
<a name=B3></a>11.3. Innerproduct 2
</h3>
 
<pre>
PROC innerproduct 2 = (REF [ ] REAL a, b) REAL:
   IF UPB a - LWB a = UPB b - LWB b
   THEN &cent; the innerproduct of two vectors 'a' and 'b' with equal numbers
      of elements &cent; 
      LONG REAL s := LONG 0;
      REF [ ] REAL a1 = a[@1], b1 = b[@1];
      &cent; note that the bounds of 'a[@1]' are [1 : UPB a - LWB a + 1] &cent;
      FOR i TO UPB a1 DO s +:= LENG a1[i] &times; LENG b1[i] OD;
      SHORTEN s
   FI
</pre>

<p>
<b>Real-calls</b> using <tt>innerproduct 2</tt>:
 
<pre>
innerproduct2 (x1, y1) 
innerproduct2 (y2[2, ], y2[, 3]) 
</pre>

<h3>
<a name=B4></a>11.4. Largest element
</h3>

<pre>
PROC absmax = (REF [, ] REAL a, &cent; result &cent; REF REAL y, 
   &cent; subscripts &cent; REF INT i, k) VOID:
      &cent; the absolute value of the element of greatest absolute value of
      the matrix 'a' is assigned to 'y', and the subscripts of this
      element to 'i' and 'k'&cent;
    BEGIN y := -1;
       FOR p FROM 1 LWB a TO 1 UPB a
       DO
          FOR q FROM 2 LWB a TO 2 UPB a
          DO
             IF ABS a[p, q] &gt; y THEN y := ABS a[i := p, k := q] FI
          OD
      OD
   END
</pre>

<p>
<b>Calls</b> using <tt>absmax</tt>: 

<pre>
absmax (x2, x, i, j) 
absmax (x2, x, LOC INT, LOC INT) 
</pre>
 
<h3>
<a name=B5></a>11.5. Euler summation
</h3>

<pre>
PROC euler = (PROC (INT) REAL f, REAL eps, INT tim) REAL:
      &cent; the sum for 'i' from 1 to infinity of 'f (i) ', computed by means of
      a suitably refined Euler transformation. The summation is
      terminated when the absolute values of the terms of the
      transformed series are found to be less than 'eps' 'tim' times in
      succession. This transformation is particularly efficient in the
      case of a slowly convergent or divergent alternating series &cent;
   BEGIN INT n := 1, t; REAL mn, ds := eps; [1 : 16] REAL m;
      REAL sum := (m[1] := f (1)) / 2;
      FOR i FROM 2 WHILE (t := ABS ds &lt; eps | t + 1 | 1)) &le; tim
      DO mn := f (i);
         FOR k TO n DO mn := ((ds := mn)) + m[k]) / 2; m[k] := ds OD;
         sum +:= (ds := (ABS mn &lt; ABS m[n] AND n &lt; 16 | n +:= 1; m[n] := mn;
            mn / 2 | mn)) 
      OD;
      sum
   END
</pre>
<p>
A call using <tt>euler</tt>: 

<pre>
euler ((INT i) REAL: (ODD i | -1 / i | 1 / i) , 1.e-5, 2) 
</pre> 

<h3>
<a name=B6></a>11.6. The norm of a vector
</h3>

<pre>
PROC norm = (REF [ ] REAL a) REAL :
      &cent; the euclidean norm of the vector 'a' &cent;
   (LONG REAL s := LONG 0;
    FOR k FROM LWB a TO UPB a DO s +:= LENG a[k] &uarr; 2 OD;
    SHORTEN long sqrt (s)) 
</pre>

</pre>
For a use of <tt>norm</tt> in a call, see <a href="report_5.html#B7">11.7</a> . 

<h3>
<a name=B7></a> 
11.7. Determinant of a matrix
</h3>
 
<pre>
PROC det = (REF [, ] REAL x, REF [ ] INT p) REAL :
   IF REF [, ] REAL a = x[@1, @1];
         1 UPB a = 2 UPB a AND 1 UPB a = UPB p - LWB p + 1
   THEN INT n = 1 UPB a;
         &cent; the determinant of the square matrix 'a' of order 'n' by the
         method of Crout with row interchanges: 'a' is replaced by its
         triangular decomposition, l &times; u, with all u[k, k] = 1.
         The vector 'p' gives as output the pivotal row indices; the k-th
         pivot is chosen in the k-th column of T such that
         ABS l[i, k] / row norm is maximal &cent;
      [1 : n] REAL v; REAL d := 1, s, pivot;
      FOR i TO n DO v[i] := norm (a[i, ]) OD;
      FOR k TO n
      DO INT k1 = k - 1; REF INT pk = p[@1][k]; REAL r := -1;
         REF [, ] REAL al = a[, 1 : k1], au = a[1 : k1,];
         REF [ ] REAL ak = a[k, ], ka = a[, k], alk = al[k, ], kau = au[, k];
         FOR i FROM k TO n
         DO REF REAL aik = ka[i];
            IF (s := ABS (aik -:= innerproduct2 (al[i, ], kau)) / v[i]) &gt; r
            THEN r := s; pk := i
            FI
         OD;
         v[pk] := v[k]; pivot := ka[pk]; REF [ ] REAL apk = a[pk, ];
         FOR j TO n
         DO REF REAL akj = ak[j], apkj = apk[j];
            r := akj;
            akj := IF j &le; k THEN apkj
               ELSE (apkj - innerproduct2 (alk, au[, j])) / pivot FI;
            IF pk &ne; k THEN apkj := -r FI
         OD;
         d &times;:= pivot
      OD;
      d
   FI
</pre><p>
A call using <tt>det</tt>:
<pre>
det (y2,i1)
</pre>

<h3>
<a name=B8></a>11.8. Greatest common divisor
</h3>

<pre>
PROC gcd = (INT a, b) INT:
      &cent; the greatest common divisor of two integers &cent;
   (b = 0 | ABS a | gcd (b, a MOD b))
</pre>

<p>
A call using <tt>gcd</tt>:
<pre>
gcd (n, 124)
</pre>
 
<h3>
<a name=B9></a>
11.9. Continued fraction
</h3>

<pre>
OP / = ([ ] REAL a, [ ] REAL b) REAL:
      &cent; the value of a / b is that of the continued fraction
      a1 / (b1 + a2 / (b2 + ... an / bn) ...) &cent;
   IF LWB a = 1 AND LWB b = 1 AND UPB a = UPB b
   THEN (UPB a = 0 | 0 | a[1] / (b[1] + a[2 : ] / b[2 : ]))
   FI
</pre><p>
A <b>formula</b> using <tt>/</tt>:
<pre>
x1 / y1
</pre><p>
{The use of recursion may often be elegant rather than efficient as in the recursive procedure <a href="report_5.html#B8">11.8</a>  and the recursive operation <a href="report_5.html#B9">11.9</a> . See, however, <a href="report_5.html#BA">11.10</a> and <a href="report_5.html#BD">11.13</a>  for examples in which recursion is of the essence.} 

<h3>
<a name=BA></a>11.10. Formula manipulation
</h3>
 
<pre>
BEGIN
   MODE FORM = UNION (REF CONST, REF VAR, REF TRIPLE, REF CALL);
   MODE CONST = STRUCT (REAL value);
   MODE VAR = STRUCT (STRING name, REAL value);
   MODE TRIPLE = STRUCT (FORM left operand, INT operator, FORM right operand);
   MODE FUNCTION = STRUCT (REF VAR bound var, FORM body);
   MODE CALL = STRUCT (REF FUNCTION function name, FORM parameter);
   INT plus = 1, minus = 2, times = 3, by = 4, to = 5;
   HEAP CONST zero, one; value OF zero := 0; value OF one := 1;
   OP = = (FORM a, REF CONST b) BOOL: (a | (REF CONST ec): ec :=: b | FALSE);
   OP + = (FORM a, b) FORM:
      a = zero | b |: b = zero | a | HEAP TRIPLE := (a, plus, b));
   OP - = (FORM a, b) FORM: (b = zero | a | HEAP TRIPLE := (a, minus, b));
   OP &times; = (FORM a, b) FORM: (a = zero OR b = zero | zero |: a = one | b |: b = one | a |
         HEAP TRIPLE := (a, times, b));
   OP / = (FORM a, b) FORM: (a = zero AND NOT (b = zero) | zero |: b = one | a |
         HEAP TRIPLE := (a, by, b));
   OP &uarr; = (FORM a, REF CONST b) FORM:
      (a = one OR (b :=: zero) | one |: b :=: one | a | HEAP TRIPLE := (a, to, b));
   PROC derivative of = (FORM e, &cent; with respect to &cent; REF VAR x) FORM:
      CASE e IN
         (REF CONST): zero,
         (REF VAR ev): (ev :=: x | one | zero) ,
         (REF TRIPLE et) :
            CASE FORM u = left operand OF et, v = right operand OF et;
                 FORM udash = derivative of (u, &cent; with respect to &cent; x) ,
                 vdash = derivative of (v, &cent; with respect to &cent; x);
                 operator OF et
            IN
                 udash + vdash,
                 udash - vdash,
                 u &times; vdash + udash &times v,
                 (udash - et &times; vdash) / v,
                 (v | (REF CONST ec): v &times; u &uarr; (HEAP CONST c;
                    value OF c := value OF ec - 1; c) &times; udash)
            ESAC,
         (REF CALL ef) :
            BEGIN REF FUNCTION f = function name OF ef;
               FORM g = parameter OF ef; REF VAR y = bound var OF f;
               HEAP FUNCTION fdash := (y, derivative of (body OF f, y));
               HEAP CALL := (fdash, g)) &times derivative of (g, x)
            END
      ESAC;
   PROC value of = (FORM e) REAL:
      CASE e IN
         (REF CONST ec): value OF ec,
         (REF VAR ev): value OF ev,
         (REF TRIPLE et) :
            CASE REAL u = value of (left operand OF et) ,
                 v = value of (right operand OF et);
                 operator OF et
            IN u + v, u - v, u &times; v, u / v, exp (v &times; ln (u))
            ESAC,
         (REF CALL ef) :
            BEGIN REF FUNCTION f = function name OF ef;
               value OF bound var OF f := value of (parameter OF ef);
               value of (body OF f)
            END
      ESAC;
   HEAP FORM f, g;
   HEAP VAR a := ("a", SKIP) , b := ("b", SKIP) , x := ("x", SKIP);
&cent; start here &cent;
   read ((value OF a, value OF b, value OF x));
   f := a + x / (b + x);
   g := (f + one) / (f - one);
   print ((value OF a, value OF b, value OF x,
      value of (derivative of (g, &cent; with respect to &cent; x))))
END &cent; example of formula manipulation &cent;
</pre><h3>
<a name=BB></a>11.11. Information retrieval
</h3>
 
<pre>
BEGIN
   MODE RA = REF AUTH, RB = REF BOOK;
   MODE AUTH = STRUCT (STRING name, RA next, RB book) ,
   BOOK = STRUCT (STRING title, RB next);
   RA auth, first auth := NIL, last auth;
   RB book; STRING name, title; INT i; FILE input, output;
   open (input, "", remote in); open (output, "", remote out);
   putf (output, ($p
      "to enter a new author, type ""author"", a space,"x
      "and his name."l
      "to enter a new book, type ""book"", a space,"x
      "the name of the author, a new line, and the title."l
      "for a listing of the books by an author, type ""list"","x
      "a space, and his name."l
      "to find the author of a book, type ""find"", a new line,"x
      "and the title."l
      "to end, type ""end"""al$, "."));

   PROC update = VOID:
      IF RA (first auth) :=: NIL
      THEN auth := first auth := last auth := HEAP AUTH := (name, NIL, NIL)
      ELSE auth := first auth;
           WHILE RA (auth) :&ne;: NIL
           DO
              (name = name OF auth | GO TO known | auth := next OF auth)
           OD;
           lastauth := next OF lastauth := auth :=
              HEAP AUTH := (name, NIL, NIL);
    known: SKIP
      FI;

   DO
   try again:
      getf (input, ($c ("author", "book", "list", "find", "end", "") ,x30al,
         80al$, i));

      CASE i IN

         &cent; author&cent;
         getf (input, name); update) ,

         &cent; book &cent;
         BEGIN getf (input, (name, title)); update;
            IF RB (book OF auth) :=: NIL
            THEN book OF auth := HEAP BOOK := (title, NIL)
            ELSE book := book OF auth;
               WHILE RB (next OF book) :&ne;: NIL
               DO
                  (title = title OF book
                  | GO TO try again | book := next OF book)
               OD;
               (title &ne; title OF book
               | next OF book := HEAP BOOK := (title, NIL))
            FI
         END,

         &cent; list &cent;
         BEGIN getf (input, name); update;
            putf (output, ($p"author: "30all$, name));
            IF RB (book := book OF auth) :=: NIL
            THEN put (output, ("no publications", newline))
            ELSE on page end (output,
               (REF FILE f) BOOL:
                  (putf (f, ($p"author: "30a41k"continued"ll$, name));
                   TRUE));
               WHILE RB (book) :&ne;: NIL
               DO putf (output, ($l80a$, title OF book)); book := next OF book
               OD;
               on page end (output, (REF FILE f) BOOL: FALSE)
            FI
         END,

         &cent; find &cent;
         BEGIN getf (input, (LOC STRING, title)); auth := first auth;
            WHILE RA (auth) :&ne;: NIL
            DO book := book OF auth;
               WHILE RB (book) :&ne;: NIL
               DO
                  IF title = title OF book
                  THEN putf (output, ($l"author: "30a$, name OF auth));
                     GO TO try again
                  ELSE book := next OF book
                  FI
               OD;
               auth := next OF auth
            OD;
            put (output, (newline, "unknown", newline))
         END,

         &cent; end &cent;
         (put (output, (new page, "signed off", close)); close (input);
          GOTO stop) ,

         &cent; error &cent;
         (put (output, (newline, "mistake, try again")); newline (input))
      ESAC
   OD
END
</pre><h3>
<a name=BC></a>11.12. Cooperating sequential processes
</h3>
 
<pre>
BEGIN INT nmb magazine slots, nmb producers, nmb consumers;
   read ((nmb magazine slots, nmb producers, nmb consumers));
   [1 : nmb producers] FILE in file; [1 : nmb consumers] FILE out file;
   FOR i TO nmb producers DO open (in file[i], "", inchannel[i]) OD;
      &cent; 'inchannel' and 'outchannel' are defined in a surrounding range &cent;
      FOR i TO nmb consumers
      DO open (out file[i], "", outchannel[i]) OD;
      MODE PAGE = [1 : 60, 1 : 132] CHAR ;
      [1 : nmb magazine slots] REF PAGE magazine;
      INT &cent; pointers of a cyclic magazine &cent; index:= 1, exdex := 1;
      SEMA full slots = LEVEL 0, free slots = LEVEL nmb magazine slots,
      in buffer busy = LEVEL 1, out buffer busy = LEVEL 1;
      PROC par call = (PROC (INT) VOID p, INT n) VOID:
         &cent; call 'n' incarnations of 'p' in parallel &cent;
         (n &gt; 0 | PAR (p (n) , par call (p, n - 1)));
      PROC producer = (INT i) VOID:
         DO HEAP PAGE page;
            get (in file[i], page);
            DOWN free slots; DOWN in buffer busy;
            magazine[index] := page;
            index MODAB nmb magazine slots PLUSAB 1;
            UP full slots; UP in buffer busy
         OD;
      PROC consumer = (INT i) VOID:
         DO PAGE page;
            DOWN full slots; DOWN out buffer busy;
            page := magazine[exdex];
            exdex MODAB nmb magazine slots PLUSAB 1;
            UP free slots; UP out buffer busy;
            put (out file[i], page)
        OD;
      PAR (par call (producer, nmb producers) ,
         par call (consumer, nmb consumers))
 END
</pre><h3>
<a name=BD></a>11.13. Towers of Hanoi
</h3>

<pre>
FOR k TO 8
DO FILE f := stand out;
   PROC p = (INT me, de, ma) VOID:
      IF ma &gt; 0 THEN
           p (me, 6 - me - de, ma - 1);
           putf (f, (me, de, ma));
           &cent; move from peg 'me' to peg 'de' piece 'ma' &cent;
           p (6-me-de, de, ma -1)
      FI ;
   putf (f, ($l"k = "dl,n ((2 &uarr; k + 15) &divide; 16) (2(2(4(3(d)x)x)x)l)$, k));
   p (1, 2, k)
OD
</pre><!-- RRFooter -->
<p>
<div style="border: 1px solid red">
<table cellpadding=6>
<tr>
<td>
<p style="font-size: 8pt; font-color: black;">
Text from the <i>Revised Report on the Algorithmic
Language Algol 68</i> is reproduced under the condition specified in
that report: <i>Reproduction of the Report, for any purpose, but only
of the whole text, is explicitly permitted without formality</i>. The
appendix <i>Specification of partial parametrization proposal</i> is
not a part of the Algol 68 Revised Report, and is distributed with
Algol 68 Genie with kind permission of C.H. Lindsey.
<p style="font-size: 8pt; font-color: black;">
Copyright &copy; 2001-2008 J. Marcel van der Veer.<br>
Algol 68 Genie Mark 14.1 (November 2008)
</td>
</tr>
</table>
</div>
</body>
</html>
