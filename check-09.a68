PR echo "[9] Synthetic benchmark after Curnow & Wichmann" PR

# After HJ Curnow and BA Wichmann, Computer Journal 19(1) 43 [1976] 
  Free versions for other languages are available on the i-net.
#

[1 : 4] REAL e1, REAL x1, x2, x3, x4, x, y, z, INT j, k, l;
    
PROC pa = (REF [] REAL e) VOID:
     TO 6
     DO e[1] := (e[1] + e[2] + e[3] - e[4]) * t;
        e[2] := (e[1] + e[2] - e[3] + e[4]) * t;
        e[3] := (e[1] - e[2] + e[3] + e[4]) * t;
        e[4] := (- e[1] + e[2] + e[3] + e[4]) / t2
     OD;

PROC po = VOID:
     BEGIN e1[j] := e1[k]; 
           e1[k] := e1[l]; 
           e1[l] := e1[j]    
     END;

PROC p3 = (REF REAL x, y, z) VOID:
     BEGIN x := t * (x + y); 
           y := t * (x + y); 
           z := (x + y) / t2 
     END;
  
# weight = 10 means 1e6 whetstone instructions per loop #

INT weight = 100, duration = 5, INT cycles := 0;

INT n2 = 12 * weight, n3 = 14 * weight, n4 = 345 * weight, 
    n6 = 210 * weight, n7 = 32 * weight, n8 = 899 * weight, 
    n9 = 616 * weight, n11 = 93 * weight;

REAL t = 0.499975, t1 = 0.50025, t2 = 2.0, cpu1 = seconds;

WHILE (seconds - cpu1) < duration
DO cycles +:= 1;

   # MODULE 1. Simple identifiers #

   x1 := 1.0; 
   x2 := x3 := x4 := -1.0;
  
   # MODULE 2. Array elements #

   e1[1] := 1.0; 
   e1[2] := e1[3] := e1[4] := -1.0;

   TO n2
   DO e1[1] := (e1[1] + e1[2] + e1[3] - e1[4]) * t;
      e1[2] := (e1[1] + e1[2] - e1[3] + e1[4]) * t;
      e1[3] := (e1[1] - e1[2] + e1[3] + e1[4]) * t;
      e1[4] := (- e1[1] + e1[2] + e1[3] + e1[4]) * t
   OD;
    
   # MODULE 3. Array parameters #

   TO n3 
   DO pa(e1)
   OD;

   # MODULE 4. Conditional jumps #
  
   j := 1;
   TO n4 
   DO IF j = 1
      THEN j := 2
      ELSE j := 3
      FI;

      IF j > 2
      THEN j := 0
      ELSE j := 1
      FI;

      IF j < 1
      THEN j := 1
      ELSE j := 0
      FI
   OD;
        
   # MODULE 5. Omitted #

   # MODULE 6. Integers #
     
   j := 1; k := 2; l := 3;
   TO n6
   DO j := j * (k - j) * (l - k);
      k := l * k - (l - j) * k;
      l := (l - k) * (k + j);
      e1[l - 1] := j + k + l;
      e1[k - 1] := j * k * l
   OD;

   # MODULE 7. Trigonometry #

   x := y := 0.5;

   TO n7
   DO x := t * arctan(t2 * sin(x) * cos(x) / (cos (x + y) + cos(x - y) - 1.0));
      y := t * arctan(t2 * sin(y) * cos(y) / (cos (x + y) + cos(x - y) - 1.0))
   OD;

   # MODULE 8. Calls #
    
   x := y := z := 1.0;

   TO n8 
   DO p3(x, y, z)
   OD;
     
   # MODULE 9. Array references #

   j := 1; 
   k := 2; 
   l := 3;

   e1[1] := 1.0; 
   e1[2] := 2.0; 
   e1[3] := 3.0;

   TO n9 
   DO po
   OD;
    
   # MODULE 10. Zero frequency #

   # MODULE 11. Standard functions #

   x := 0.75;

   TO n11 
   DO x := sqrt(exp(ln(x) / t1))
   OD
OD;

REAL time = (seconds - cpu1) / cycles;
printf (($x3z-d.d" MWhets"$, 1 / (time / (weight / 10))))
