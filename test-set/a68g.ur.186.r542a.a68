# This program is part of the Rennes Test Set, 
  automatically generated from the Algol 68 grammar 
  using a formalism of B. Houssais (University of Rennes, 1975).
 
  This test set is available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

# r542a #
(print (("monadic formulas", newline));
 INT vf = 18 * (8 + 2) + 33 * (8 + 2 + 5);
 
 INT ctrt := 0, ctr := 0, ctrloc;
 
 PROC ctrl = (INT inc) VOID:
      (ctr /= ctrloc + inc | print (("count er in test", ctrt, ctr, ctrloc + inc, newline)));
 
 MODE R = INT;
 
 PROC test = (INT a) VOID:
      (a = 1 | ctr +:= 1 | print (("er", ctrt, ctr - ctrloc, newline)));
 
 OP ?=:= = (INT x) INT:
    (test (x);
     x);
 
 # servitudes pour secondaires #
 INT b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8, i = 9, j = 10;
 
 STRUCT (INT d2, d3, d4, d5, d6, d7, d8, d9, d0) str = (2, 3, 4, 5, 6, 7, 8, 9, 10);
 
 [, ] INT t = ((0, b, c, d, e, f, g, h, i, j), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)),
 PROC call = (INT a) INT:
      (a = 0 | 10 | a),
 OP & = (BOOL a, INT b) STRUCT (INT a, b):
    (b, 0),
     & = (CHAR a, STRUCT (INT a, b) b) INT: a OF b;
 
 PRIO & = 3;
 
 # contextes demandant un mode : ent #
 (# definition des operateurs #
  OP M = (INT a) INT:
     (ctr +:= 1; a - 1);
  
  # nombre de monadiques : 1 #
  (ctrt := 1;
   ctrloc := ctr;
   test (M 2);
   FOR ident FROM M 2 BY M 2 TO M 2 
   WHILE 1 = (M 2)
   DO [M 2 : 4, -1 : M 2] R ent;
      
      ent[M 2, 0] := ent[1, M 2] := M 2;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M 2;
            REAL pi = 0.12345;
            
            M 2);
   
   test (par);
   alfa := ?=:=M 2;
   R ident = M 2,
   R loc := CASE M 2
   IN M 2, SKIP
   ESAC, tas := M 2;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M 2,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M 2, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M 2, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M 2);
   
   UNION (R, CHAR) union := pr (proc, M 2, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M 2 END), ?=:=(union; 1 = (M 2) | M 2), M 2, test ((BOOL bool = FALSE; union | (R): M 2, (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 2;
   ctrloc := ctr;
   test (M b);
   FOR ident FROM M b BY M b TO M b 
   WHILE 1 = (M b)
   DO [M b : 4, -1 : M b] R ent;
      
      ent[M b, 0] := ent[1, M b] := M b;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M b;
            REAL pi = 0.12345;
            
            M b);
   
   test (par);
   alfa := ?=:=M b;
   R ident = M b,
   R loc := CASE M b
   IN M b, SKIP
   ESAC, tas := M b;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M b,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M b, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M b, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M b);
   
   UNION (R, CHAR) union := pr (proc, M b, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M b END), ?=:=(union; 1 = (M b) | M b), M b, test ((BOOL bool = FALSE; union | (R): M b, (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 3;
   ctrloc := ctr;
   test (M d2 OF str);
   FOR ident FROM M d2 OF str BY M d2 OF str TO M d2 OF str 
   WHILE 1 = (M d2 OF str)
   DO [M d2 OF str : 4, -1 : M d2 OF str] R ent;
      
      ent[M d2 OF str, 0] := ent[1, M d2 OF str] := M d2 OF str;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M d2 OF str;
            REAL pi = 0.12345;
            
            M d2 OF str);
   
   test (par);
   alfa := ?=:=M d2 OF str;
   R ident = M d2 OF str,
   R loc := CASE M d2 OF str
   IN M d2 OF str, SKIP
   ESAC, tas := M d2 OF str;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M d2 OF str,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M d2 OF str, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M d2 OF str, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M d2 OF str);
   
   UNION (R, CHAR) union := pr (proc, M d2 OF str, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M d2 OF str END), ?=:=(union; 1 = (M d2 OF str) | M d2 OF str), M d2 OF str, test ((BOOL bool = FALSE; union | (R): M d2 OF str, (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 4;
   ctrloc := ctr;
   test (M t[, b][2]);
   FOR ident FROM M t[, b][2] BY M t[, b][2] TO M t[, b][2] 
   WHILE 1 = (M t[, b][2])
   DO [M t[, b][2] : 4, -1 : M t[, b][2]] R ent;
      
      ent[M t[, b][2], 0] := ent[1, M t[, b][2]] := M t[, b][2];
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M t[, b][2];
            REAL pi = 0.12345;
            
            M t[, b][2]);
   
   test (par);
   alfa := ?=:=M t[, b][2];
   R ident = M t[, b][2],
   R loc := CASE M t[, b][2]
   IN M t[, b][2], SKIP
   ESAC, tas := M t[, b][2];
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        M t[, b][2],
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M t[, b][2], (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M t[, b][2], proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M t[, b][2]);
   
   UNION (R, CHAR) union := pr (proc, M t[, b][2], proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M t[, b][2]
          END), ?=:=(union; 1 = (M t[, b][2]) | M t[, b][2]), M t[, b][2], test ((BOOL bool = FALSE; union | (R): M t[, b][2], (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 5;
   ctrloc := ctr;
   test (M call (2));
   FOR ident FROM M call (2) BY M call (2) TO M call (2) 
   WHILE 1 = (M call (2))
   DO [M call (2) : 4, -1 : M call (2)] R ent;
      
      ent[M call (2), 0] := ent[1, M call (2)] := M call (2);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M call (2);
            REAL pi = 0.12345;
            
            M call (2));
   
   test (par);
   alfa := ?=:=M call (2);
   R ident = M call (2),
   R loc := CASE M call (2)
   IN M call (2), SKIP
   ESAC, tas := M call (2);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M call (2),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M call (2), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M call (2), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M call (2));
   
   UNION (R, CHAR) union := pr (proc, M call (2), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M call (2)
          END), ?=:=(union; 1 = (M call (2)) | M call (2)), M call (2), test ((BOOL bool = FALSE; union | (R): M call (2), (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 6;
   ctrloc := ctr;
   test (M PROC INT IF 2 = 0
         THEN INT: 10
         ELSE INT: 2
         FI);
   FOR ident FROM M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI BY M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI TO M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI 
   WHILE 1 = (M PROC INT IF 2 = 0
              THEN INT: 10
              ELSE INT: 2
              FI)
   DO [M PROC INT IF 2 = 0
       THEN INT: 10
       ELSE INT: 2
       FI : 4, -1 : M PROC INT IF 2 = 0
       THEN INT: 10
       ELSE INT: 2
       FI] R ent;
      
      ent[M PROC INT IF 2 = 0
          THEN INT: 10
          ELSE INT: 2
          FI, 0] := ent[1, M PROC INT IF 2 = 0
                        THEN INT: 10
                        ELSE INT: 2
                        FI] := M PROC INT IF 2 = 0
      THEN INT: 10
      ELSE INT: 2
      FI;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M PROC INT IF 2 = 0
            THEN INT: 10
            ELSE INT: 2
            FI;
            REAL pi = 0.12345;
            
            M PROC INT IF 2 = 0
            THEN INT: 10
            ELSE INT: 2
            FI);
   
   test (par);
   alfa := ?=:=M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI;
   R ident = M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI,
   R loc := CASE M PROC INT IF 2 = 0
                 THEN INT: 10
                 ELSE INT: 2
                 FI
   IN M PROC INT IF 2 = 0
      THEN INT: 10
      ELSE INT: 2
      FI, SKIP
   ESAC, tas := M PROC INT IF 2 = 0
   THEN INT: 10
   ELSE INT: 2
   FI;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M PROC INT IF 2 = 0
THEN INT: 10
ELSE INT: 2
FI, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M PROC INT IF 2 = 0
               THEN INT: 10
               ELSE INT: 2
               FI, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M PROC INT IF 2 = 0
         THEN INT: 10
         ELSE INT: 2
         FI);
   
   UNION (R, CHAR) union := pr (proc, M PROC INT IF 2 = 0
                                THEN INT: 10
                                ELSE INT: 2
                                FI, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M PROC INT IF 2 = 0
                  THEN INT: 10
                  ELSE INT: 2
                  FI
          END), ?=:=(union; 1 = (M PROC INT IF 2 = 0
                                 THEN INT: 10
                                 ELSE INT: 2
                                 FI) | M PROC INT IF 2 = 0
    THEN INT: 10
    ELSE INT: 2
    FI), M PROC INT IF 2 = 0
    THEN INT: 10
    ELSE INT: 2
    FI, test ((BOOL bool = FALSE; union | (R): M PROC INT IF 2 = 0
              THEN INT: 10
              ELSE INT: 2
              FI, (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 7;
   ctrloc := ctr;
   test (M (INT x := b; x));
   FOR ident FROM M (INT x := b; x) BY M (INT x := b; x) TO M (INT x := b; x) 
   WHILE 1 = (M (INT x := b; x))
   DO [M (INT x := b; x) : 4, -1 : M (INT x := b; x)] R ent;
      
      ent[M (INT x := b; x), 0] := ent[1, M (INT x := b; x)] := M (INT x := b; x);
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M (INT x := b; x);
            REAL pi = 0.12345;
            
            M (INT x := b; x));
   
   test (par);
   alfa := ?=:=M (INT x := b; x);
   R ident = M (INT x := b; x),
   R loc := CASE M (INT x := b; x)
   IN M (INT x := b; x), SKIP
   ESAC, tas := M (INT x := b; x);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        M (INT x := b; x),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M (INT x := b; x), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M (INT x := b; x), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M (INT x := b; x));
   
   UNION (R, CHAR) union := pr (proc, M (INT x := b; x), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M (INT x := b; x)
          END), ?=:=(union; 1 = (M (INT x := b; x)) | M (INT x := b; x)), M (INT x := b; x), test ((BOOL bool = FALSE; union | (R): M (INT x := b; x), (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  (ctrt := 8;
   ctrloc := ctr;
   test (M ("#" & (TRUE & 2)));
   FOR ident FROM M 2 BY M 2 TO M 2 
   WHILE 1 = (M 2)
   DO [M 2 : 4, -1 : M 2] R ent;
      
      ent[M 2, 0] := ent[1, M 2] := M 2;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M 2;
            REAL pi = 0.12345;
            
            M 2);
   
   test (par);
   alfa := ?=:=M 2;
   R ident = M 2,
   R loc := CASE M 2
   IN M 2, SKIP
   ESAC, tas := M 2;
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M 2,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M 2, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M 2, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M 2);
   
   UNION (R, CHAR) union := pr (proc, M 2, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M 2 END), ?=:=(union; 1 = (M 2) | M 2), M 2, test ((BOOL bool = FALSE; union | (R): M 2, (CHAR car): SKIP)));
   ctrl (17 + 28 * 1));
  # nombre de monadiques : 2 #
  (ctrt := 9;
   ctrloc := ctr;
   test (M M c);
   FOR ident FROM M M call (3) BY M M t[, c][2] TO M M t[, c][2] 
   WHILE 1 = (M M d3 OF str)
   DO [M M 3 : 4, -1 : M M ("#" & (TRUE & c))] R ent;
      
      ent[M M (INT x := c; x), 0] := ent[1, M M 3] := M M PROC INT IF 3 = 0
      THEN INT: 10
      ELSE INT: 3
      FI;
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M M c;
            REAL pi = 0.12345;
            
            M M PROC INT IF 3 = 0
            THEN INT: 10
            ELSE INT: 3
            FI);
   
   test (par);
   alfa := ?=:=M M d3 OF str;
   R ident = M M t[, c][2],
   R loc := CASE M M call (3)
   IN M M c, SKIP
   ESAC, tas := M M (INT x := c; x);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R:
        M M (INT x := c; x),
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M M PROC INT IF 3 = 0
THEN INT: 10
ELSE INT: 3
FI, (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M M PROC INT IF 3 = 0
               THEN INT: 10
               ELSE INT: 3
               FI, proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M M call (3));
   
   UNION (R, CHAR) union := pr (proc, M M call (3), proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M M call (3)
          END), ?=:=(union; 1 = (M M d3 OF str) | M M d3 OF str), M M d3 OF str, test ((BOOL bool = FALSE; union | (R): M M PROC INT IF 3 = 0
               THEN INT: 10
               ELSE INT: 3
               FI, (CHAR car): SKIP)));
   ctrl (17 + 28 * 2));
  # nombre de monadiques : 5 #
  (ctrt := 10;
   ctrloc := ctr;
   test (M M M M M ("#" & (TRUE & d6 OF str)));
   FOR ident FROM M M M M M t[, f][2] BY M M M M M PROC INT IF 6 = 0
   THEN INT: 10
   ELSE INT: 6
   FI TO M M M M M PROC INT IF 6 = 0
   THEN INT: 10
   ELSE INT: 6
   FI 
   WHILE 1 = (M M M M M 6)
   DO [M M M M M (INT x := f; x) : 4, -1 : M M M M M (INT x := f; x)] R ent;
      
      ent[M M M M M t[, f][2], 0] := ent[1, M M M M M call (6)] := M M M M M t[, f][2];
      test (ent[1, 0]);
      test (ent[1, 1])
   OD;
   R alfa,
   R par = (SKIP;
            M M M M M PROC INT IF 6 = 0
            THEN INT: 10
            ELSE INT: 6
            FI;
            REAL pi = 0.12345;
            
            M M M M M t[, f][2]);
   
   test (par);
   alfa := ?=:=M M M M M f;
   R ident = M M M M M (INT x := f; x),
   R loc := CASE M M M M M (INT x := f; x)
   IN M M M M M (INT x := f; x), SKIP
   ESAC, tas := M M M M M (INT x := f; x);
   
   test (ident);
   test (loc);
   test (tas);
   PROC proc = R: M M M M M f,
   STRUCT (COMPL of, STRUCT (R de, COMPL of) de) struct := ((0.11, 0), (M M M M M call (6), (0, 1e0)));
   
   test (de OF de OF struct);
   [] R apd = (ident, par, loc, M M M M M call (6), proc, tas, de OF de OF struct);
   
   test (apd[4]);
   test (apd[5]);
   PROC pr := (R rep, reprep, PROC R procrep) R:
        (test (rep);
         test (reprep);
         M M M M M call (6));
   
   UNION (R, CHAR) union := pr (proc, M M M M M PROC INT IF 6 = 0
                                THEN INT: 10
                                ELSE INT: 6
                                FI, proc);
   
   test ((union | (R a): a));
   (test (R BEGIN M M M M M t[, f][2]
          END), ?=:=(union; 1 = (M M M M M t[, f][2]) | M M M M M f), M M M M M f, test ((BOOL bool = FALSE; union | (R): M M M M M t[, f][2], (CHAR car): SKIP)));
   ctrl (17 + 28 * 5));
  SKIP);
 # contextes demandant un mode : rep #
 (OP M = (INT a) REF INT:
     HEAP INT := (ctr +:= 1; a - 1);
  
  # nombre de operateurs : 1 #
  ctrt := 11;
  ctrloc := ctr;
  test (M 2 := M 2 := (M 2 :/=: M 2 | M 2));
  ctrl (1 + 5 * 1);
  ctrt := 12;
  ctrloc := ctr;
  test (M b := M b := (M b :/=: M b | M b));
  ctrl (1 + 5 * 1);
  ctrt := 13;
  ctrloc := ctr;
  test (M d2 OF str := M d2 OF str := (M d2 OF str :/=: M d2 OF str | M d2 OF str));
  ctrl (1 + 5 * 1);
  ctrt := 14;
  ctrloc := ctr;
  test (M t[, b][2] := M t[, b][2] := (M t[, b][2] :/=: M t[, b][2] | M t[, b][2]));
  ctrl (1 + 5 * 1);
  ctrt := 15;
  ctrloc := ctr;
  test (M call (2) := M call (2) := (M call (2) :/=: M call (2) | M call (2)));
  ctrl (1 + 5 * 1);
  ctrt := 16;
  ctrloc := ctr;
  test (M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI := M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI := (M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI :/=: M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI | M PROC INT IF 2 = 0
        THEN INT: 10
        ELSE INT: 2
        FI));
  ctrl (1 + 5 * 1);
  ctrt := 17;
  ctrloc := ctr;
  test (M (INT x := b; x) := M (INT x := b; x) := (M (INT x := b; x) :/=: M (INT x := b; x) | M (INT x := b; x)));
  ctrl (1 + 5 * 1);
  ctrt := 18;
  ctrloc := ctr;
  test (M ("#" & (TRUE & call (2))) := M call (2) := (M call (2) :/=: M call (2) | M call (2)));
  ctrl (1 + 5 * 1);
  # nombre de operateurs : 2 #
  ctrt := 19;
  ctrloc := ctr;
  test (M M t[, c][2] := M M ("#" & (TRUE & t[, c][2])) := (M M d3 OF str :/=: M M call (3) | M M c));
  ctrl (1 + 5 * 2);
  # nombre de operateurs : 5 #
  ctrt := 20;
  ctrloc := ctr;
  test (M M M M M f := M M M M M PROC INT IF 6 = 0
        THEN INT: 10
        ELSE INT: 6
        FI := (M M M M M t[, f][2] :/=: M M M M M t[, f][2] | M M M M M 6));
  ctrl (1 + 5 * 5);
  SKIP);
 print ((ctr, " tests ", (ctr = vf | "ok" | "error"))))