COMMENT

This program is part of the Algol 68 Genie test.

The test set contains programs from the 
   "Revised Mathematisch Centrum Algol 68 Test Set" [1979] 
and synthetic programs from the 
   "Rennes test set" [1975].
These test sets are available from:
   www.dickgrune.com/CS/Algol68
or from the Vrije Universiteit Amsterdam:
   ftp://ftp.cs.vu.nl/pub/dick/Algol68

Above two test sets were used in the 1980's to validate the ALGOL68RS compilers [Algol Bulletin 49.2]. 

The "Rennes test-set" programs are automatically generated from the Algol 68 grammar using a formalism from Bernard Houssais (Universite de Rennes).  Especially the "Rennes test set" has proven very effective in exposing problems in Algol 68 implementations.  All programs are converted to upper-stropping and reformatted for lay-out.

The "Revised Mathematisch Centrum test set" programs are not synthetic like those in the "Rennes test set", but are selected programmer-made applications that are distributed with Algol 68 Genie with kind permission of the author of this test set, Dick Grune.

Note that part of the programs in this test set will fail; most due to intentional (syntactic or runtime) errors and a few due to differences between Algol 68 Genie and revised Algol 68. 

COMMENT

PR regression PR

# This program contains the Rennes Test Set, 
  automatically generated from the Algol 68 grammar 
  using a formalism of B. Houssais (University of Rennes, 1975).
 
  This test set is available from:
     www.dickgrune.com/CS/Algol68
  or from the Vrije Universiteit Amsterdam:
     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet storage=8 PR

PROC pretty = (LONG INT n) VOID:
  IF n < 0
  THEN write ("-");
    pretty (-n)
  ELSE FORMAT f;
    IF n < 1 000
    THEN f := $%d$
    ELIF n < 10 000
    THEN f := $d"."3d$
    ELIF n < 100 000
    THEN f := $2d"."3d$
    ELIF n < 1 000 000
    THEN f := $3d"."3d$
    ELIF n < 10 000 000
    THEN f := $d"."3d"."3d$
    ELIF n < 100 000 000
    THEN f := $2d"."3d"."3d$
    ELIF n < 1 000 000 000
    THEN f := $3d"."3d"."3d$
    ELIF n < 10 000 000 000
    THEN f := $d"."3d"."3d"."3d$
    ELIF n < 100 000 000 000
    THEN f := $2d"."3d"."3d"."3d$
    ELIF n < 1 000 000 000 000
    THEN f := $3d"."3d"."3d"."3d$
    ELSE f := $%d$
    FI;
    writef ((f, n))
  FI;

INT total to := 0, total ok := 0; 

BEGIN
  INT to test := 0, tests ok := 0; 
  
  # r31 #
  (print(("Closed clauses: ")); 
   INT vf = ((27+4+5+2)*2+7)*6; 
   INT ctr:= 0, ctrt, mem; 
   PROC controle = (INT incr) VOID :
      (ctr/=mem+incr | 
      print(("count er in test", ctrt, ctr, mem+incr, newline))); 
   PROC test = INT : (ctr+:= 1; 1), 
     rre = [] PROC INT :(ctr+:= 1; test), 
     pche = PROC (STRING) PROC INT :
  (ctr+:= 1; (STRING a) PROC INT :test); 
   UNION (INT, STRING) vu:= 1; 
  
   MODE MSTR = STRUCT (COMPL de, of), 
   PRIO  += = 5, ? = 9, 
   OP   ?= = (INT x) VOID : x, 
      += = (INT a) PROC INT :test, 
      += = (UNION (INT, BOOL) a, INT b) BOOL :(ctr+:= 1)=b, 
      += = (UNION (REF INT, REF BOOL) a, REAL b) MSTR :  SKIP, 
      += = (MSTR a, b) REF INT : ctr+:= 1; 
  
                     # declarations pour unites du mode
                      PROC INT  #
   OP  ? = (INT a, PROC INT b)
   PROC INT :
  (ctr+:= 1; 
  test), 
   STRUCT (INT of, PROC INT de) structa
  = (0, 
  test), 
   PROC proca= ([] INT a)
   PROC INT : (ctr+:= 1; 
  test)
  , identa= PROC INT 
  :(ctr+:= 1; 
  test), 
  [] PROC PROC INT 
   ranga= identa; 
  
                     # declarations pour unites du mode
                      PROC REF BOOL  #
   OP  ? = (INT a, PROC REF BOOL b)
   PROC REF BOOL :
  (ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
   STRUCT (INT of, PROC REF BOOL de) structb
  = (0, 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
   PROC procb= ([] INT a)
   PROC REF BOOL : (ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  , identb= PROC REF BOOL 
  :(ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
  [] PROC PROC REF BOOL 
   rangb= identb; 
  
                     # declarations pour unites du mode
                      PROC MSTR  #
   OP  ? = (INT a, PROC MSTR b)
   PROC MSTR :
  (ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1)), 
   STRUCT (INT of, PROC MSTR de) structc
  = (0, 
   MSTR :((0, 0), ctr+:= 1)), 
   PROC procc= ([] INT a)
   PROC MSTR : (ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1))
  , identc= PROC MSTR 
  :(ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1)), 
  [] PROC PROC MSTR 
   rangc= identc; 
  
                     # declarations pour unites du mode
                      PROC  [] PROC INT  #
   OP  ? = (INT a, PROC [] PROC INT b)
   PROC  [] PROC INT :
  (ctr+:= 1; 
  rre), 
   STRUCT (INT of, PROC [] PROC INT de) structd
  = (0, 
  rre), 
   PROC procd= ([] INT a)
   PROC [] PROC INT : (ctr+:= 1; 
  rre)
  , identd= PROC [] PROC INT 
  :(ctr+:= 1; 
  rre), 
  [] PROC PROC [] PROC INT 
   rangd= identd; 
  
                     # declarations pour unites du mode
                      PROC PROC (STRING) PROC INT  #
   OP  ? = (INT a, PROC PROC (STRING) PROC INT b)
   PROC PROC (STRING) PROC INT :
  (ctr+:= 1; 
  pche), 
   STRUCT (INT of, PROC PROC (STRING) PROC INT de) structe
  = (0, 
  pche), 
   PROC proce= ([] INT a)
   PROC PROC (STRING) PROC INT : (ctr+:= 1; 
  pche)
  , idente= PROC PROC (STRING) PROC INT 
  :(ctr+:= 1; 
  pche), 
  [] PROC PROC PROC (STRING) PROC INT 
   range= idente; 
  
                     #  contextes  #
  
  ctrt:= 1; mem:=ctr; 
  
  (FOR ident FROM 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   BY 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   TO 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   WHILE 
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
   DO  [
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  : 4, -ident:
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ]  INT ent; ent [
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , 0]:=ent[ident, 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ]:=
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   OD; 
   INT alfa, INT par= (SKIP; 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ; REAL pp= 1.00001; 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ); alfa:= 1+
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ;  INT ident=
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , INT loc:= CASE 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   IN 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , SKIP ESAC, tas:=
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , PROC proc = INT :
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , proc)
  ; (INT BEGIN 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
   END, ?= (union; 
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
   | 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ), 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , (BOOL bool= TRUE; union | (INT):
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 2; mem:=ctr; 
  
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
  :=
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
  :=
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
  :=:
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
  ; 
  controle(4*2); 
  ctrt:= 3; mem:=ctr; 
  VOID (+=
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  += (
   BEGIN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   END 
  += re OF de OF 
   BEGIN 
      ctr+:= 1; vu:= 1; 
       MSTR :((0, 0), ctr+:= 1)
   END 
  +=
   BEGIN 
      ctr+:= 1; vu:= 1; 
       MSTR :((0, 0), ctr+:= 1)
   END 
  ) += +=
   BEGIN 
      ctr+:= 1; vu:= 1; 
      test
   END 
  ) #VOID#
  ; 
  controle(5*2+5); 
  ctrt:= 4; mem:=ctr; 
  
   BEGIN 
      ctr+:= 1; vu:= 1; 
      rre
   END 
  [1]; 
   BEGIN 
      ctr+:= 1; vu:= 1; 
      pche
   END 
  (""); 
  controle(2*2+2)); 
  
  ctrt:= 5; mem:=ctr; 
  
  (FOR ident FROM 
  (
       INT x= 1; ctr+:=x; 
      test
  )
   BY 
  (
       INT x= 1; ctr+:=x; 
      test
  )
   TO 
  (
       INT x= 1; ctr+:=x; 
      test
  )
   WHILE 
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   DO  [
  (
       INT x= 1; ctr+:=x; 
      test
  )
  : 4, -ident:
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ]  INT ent; ent [
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , 0]:=ent[ident, 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ]:=
  (
       INT x= 1; ctr+:=x; 
      test
  )
   OD; 
   INT alfa, INT par= (SKIP; 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ; REAL pp= 1.00001; 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ); alfa:= 1+
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ;  INT ident=
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , INT loc:= CASE 
  (
       INT x= 1; ctr+:=x; 
      test
  )
   IN 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , SKIP ESAC, tas:=
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , PROC proc = INT :
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , proc)
  ; (INT BEGIN 
  (
       INT x= 1; ctr+:=x; 
      test
  )
   END, ?= (union; 
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   | 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ), 
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , (BOOL bool= TRUE; union | (INT):
  (
       INT x= 1; ctr+:=x; 
      test
  )
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 6; mem:=ctr; 
  
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=:
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  ; 
  controle(4*2); 
  ctrt:= 7; mem:=ctr; 
  VOID (+=
  (
       INT x= 1; ctr+:=x; 
      test
  )
  += (
  (
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  += re OF de OF 
  (
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1)
  )
  +=
  (
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1)
  )
  ) += +=
  (
       INT x= 1; ctr+:=x; 
      test
  )
  ) #VOID#
  ; 
  controle(5*2+5); 
  ctrt:= 8; mem:=ctr; 
  
  (
       INT x= 1; ctr+:=x; 
      rre
  )
  [1]; 
  (
       INT x= 1; ctr+:=x; 
      pche
  )
  (""); 
  controle(2*2+2)); 
  
  ctrt:= 9; mem:=ctr; 
  
  (FOR ident FROM 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   BY 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   TO 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   WHILE 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
   DO  [
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  : 4, -ident:
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ]  INT ent; ent [
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , 0]:=ent[ident, 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ]:=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   OD; 
   INT alfa, INT par= (SKIP; 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ; REAL pp= 1.00001; 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ); alfa:= 1+
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ;  INT ident=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , INT loc:= CASE 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   IN 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , SKIP ESAC, tas:=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , PROC proc = INT :
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , proc)
  ; (INT BEGIN 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
   END, ?= (union; 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
   | 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  ), 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , (BOOL bool= TRUE; union | (INT):
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 10; mem:=ctr; 
  
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
  :=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
  :=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
  :=:
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
  ; 
  controle(4*2); 
  ctrt:= 11; mem:=ctr; 
  VOID (+=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  += (
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   END 
  += re OF de OF 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       MSTR :((0, 0), ctr+:= 1))
   END 
  +=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       MSTR :((0, 0), ctr+:= 1))
   END 
  ) += +=
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   END 
  )
  ; 
  controle(5*2+5); 
  ctrt:= 12; mem:=ctr; 
  
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      rre)
   END 
  [1]; 
   BEGIN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      pche)
   END 
  (""); 
  controle(2*2+2)); 
  
  ctrt:= 13; mem:=ctr; 
  
  (FOR ident FROM 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   BY 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   TO 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   WHILE 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   DO  [
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  : 4, -ident:
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ]  INT ent; ent [
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , 0]:=ent[ident, 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ]:=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   OD; 
   INT alfa, INT par= (SKIP; 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ; REAL pp= 1.00001; 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ); alfa:= 1+
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ;  INT ident=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , INT loc:= CASE 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   IN 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , SKIP ESAC, tas:=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , PROC proc = INT :
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , proc)
  ; (INT BEGIN 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   END, ?= (union; 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   | 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ), 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , (BOOL bool= TRUE; union | (INT):
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 14; mem:=ctr; 
  
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=:
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  ; 
  controle(4*2); 
  ctrt:= 15; mem:=ctr; 
  VOID (+=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  += (
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  += re OF de OF 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       MSTR :((0, 0), ctr+:= 1)
  )
  +=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       MSTR :((0, 0), ctr+:= 1)
  )
  ) += +=
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ) #VOID#
  ; 
  controle(5*2+5); 
  ctrt:= 16; mem:=ctr; 
  
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      rre
  )
  [1]; 
  (
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      pche
  )
  (""); 
  controle(2*2+2)); 
  
  ctrt:= 17; mem:=ctr; 
  
  (FOR ident FROM 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   BY 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   TO 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   WHILE 
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
   DO  [
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  : 4, -ident:
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ]  INT ent; ent [
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , 0]:=ent[ident, 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ]:=
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   OD; 
   INT alfa, INT par= (SKIP; 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ; REAL pp= 1.00001; 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ); alfa:= 1+
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ;  INT ident=
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , INT loc:= CASE 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   IN 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , SKIP ESAC, tas:=
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , PROC proc = INT :
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , proc)
  ; (INT BEGIN 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
   END, ?= (union; 
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
   | 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ), 
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , (BOOL bool= TRUE; union | (INT):
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 18; mem:=ctr; 
  
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
  :=
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
  :=
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
  :=:
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
  ; 
  controle(4*2); 
  ctrt:= 19; mem:=ctr; 
  VOID (+=
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  += (
   BEGIN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   END 
  += re OF de OF 
   BEGIN 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT e: SKIP 
   END 
  +=
   BEGIN 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT e: SKIP 
   END 
  ) += +=
   BEGIN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   END 
  ) #VOID#
  ; 
  controle(5*2+5); 
  ctrt:= 20; mem:=ctr; 
  
   BEGIN 
       INT x= 1; ctr+:=x; 
      rre EXIT e: SKIP 
   END 
  [1]; 
   BEGIN 
       INT x= 1; ctr+:=x; 
      pche EXIT e: SKIP 
   END 
  (""); 
  controle(2*2+2)); 
  
  ctrt:= 21; mem:=ctr; 
  
  (FOR ident FROM 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   BY 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   TO 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   WHILE 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   DO  [
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  : 4, -ident:
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ]  INT ent; ent [
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , 0]:=ent[ident, 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ]:=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   OD; 
   INT alfa, INT par= (SKIP; 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; REAL pp= 1.00001; 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ); alfa:= 1+
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ;  INT ident=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , INT loc:= CASE 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   IN 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , SKIP ESAC, tas:=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , PROC proc = INT :
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , proc)
  ; (INT BEGIN 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   END, ?= (union; 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   | 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ), 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , (BOOL bool= TRUE; union | (INT):
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , (COMPL complex): SKIP)); 
  controle(27*2); 
  ctrt:= 22; mem:=ctr; 
  
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  :=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  :=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  :=:
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; 
  controle(4*2); 
  ctrt:= 23; mem:=ctr; 
  VOID (+=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  += (
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  += re OF de OF 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  +=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ) += +=
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ) # VOID #
  ; 
  controle(5*2+5); 
  ctrt:= 24; mem:=ctr; 
  
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      rre EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  [1]; 
  (
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      pche EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  (""); 
  controle(2*2+2)); 
  
  print((whole ((tests ok +:= ctr; ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r33d #
  (print((newline, "VOID collateral clauses: ")); 
   INT vf = 718*2; 
   INT ctr:= 0, mem, ctrt; 
   PROC controle = (INT incr) VOID :
      (ctr/=mem+incr | 
      print(("count er in test", ctrt, ctr, mem+incr, newline))); 
   BOOL boo:= TRUE, INT decr, k, vi, 
   MODE M = UNION (INT, STRING), 
   M vu:="vide", 
   PROC p1 = INT : 1, 
  [] M tre= (1, "vide", "vide"), 
   STRUCT (M a, b) srm = ("vide", 2); 
  
  (ctrt:= 1; mem:=ctr; 
   REF INT xx, INT incr = 0; 
  (
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7; 
  ea : ctrt:= 2; 
   IF 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ;  TRUE THEN ctr+:= 7 FI; 
  eb : ctrt:= 3; 
  (
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; 1 | ctr+:= 7, "vide"); 
  ec : ctrt:= 4; 
   CASE 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; vu IN (INT): SKIP ESAC; ctr+:= 7; 
  ed : ctrt:= 5; 
   FOR i WHILE 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ;  FALSE DO REF INT xx; SKIP OD; ctr+:= 7; 
  ee : ctrt:= 6; 
   TO  4  DO 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7 OD; 
  ef : ctrt:= 7; 
   IF 
  (boo | boo:= FALSE; ctr+:= 7)
  ;  TRUE THEN 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7  FI; 
  eg : ctrt:= 8; 
  (
  (boo | boo:= FALSE; ctr+:= 7)
  ;  FALSE  |  SKIP  | 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7); 
  eh : ctrt:= 9; 
   CASE  0  IN  1, 2  OUT 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7  ESAC; 
  ei : ctrt:= 10; 
  (SKIP; 
  (boo | boo:= FALSE; ctr+:= 7)
  ; vu | (INT): SKIP  |  SKIP; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7); 
  ej : ctrt:= 11; 
   decr:= 2;  FOR i TO  7
      WHILE BOOL b= (decr-:= 1)>= 0; (b | 
     (boo | boo:= FALSE; ctr+:= 7)
  );  REF INT xx; b
      DO SKIP; 
      BEGIN boo:= TRUE, ctr+:= 15  END 
       OD; ctr+:= 7; 
  ek : ctrt:= 12; 
  
  (boo | boo:= FALSE; ctr+:= 7)
  ; (TRUE  | 
   BEGIN boo:= TRUE, ctr+:= 15  END 
   | "vide"); ctr+:= 7; 
  el : ctrt:= 13; 
   IF 
  (boo | boo:= FALSE; ctr+:= 7)
  ;  FALSE THEN REF INT xx;  SKIP ELSE 
   BEGIN boo:= TRUE, ctr+:= 15  END 
    FI; ctr+:= 7; 
  em : ctrt:= 14; 
  (
  (boo | boo:= FALSE; ctr+:= 7)
  ; -1 | "vide", "vide" |  REF INT xx; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ); ctr+:= 7; 
  en : ctrt:= 15; 
   CASE REF INT xx; vu
   IN (INT a):"vide"  OUT 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
    ESAC; ctr+:= 7; 
  eo : ctrt:= 16; 
  
  (boo | boo:= FALSE; ctr+:= 7)
  ; (SKIP, 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  , (1.0, 0)); ctr+:= 7; 
  ep : ctrt:= 17; 
   CASE 
  (boo | boo:= FALSE; ctr+:= 7)
  ; 3 IN  (0, 1, 2), "vide", 
   BEGIN boo:= TRUE, ctr+:= 15  END 
    ESAC; ctr+:= 7; 
  eq : ctrt:= 18; 
  (
  (boo | boo:= FALSE; ctr+:= 7)
  ; vu | (STRING):
   BEGIN boo:= TRUE, ctr+:= 15  END 
  , (INT):"vide"); ctr+:= 7; 
  er : ctrt:= 19; 
  (PROC p= (REF INT kk) VOID :
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; p(
  (boo | boo:= FALSE; ctr+:= 7)
  )); ctr+:= 7; 
  es : ctrt:= 20; 
  
  (boo | boo:= FALSE; ctr+:= 7)
  ;  VOID :
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ; ctr+:= 7; 
  et : ctrt:= 21; 
  
  (boo | boo:= FALSE; ctr+:= 7)
  ; 
   BEGIN boo:= TRUE, ctr+:= 15  END 
  ); ctr+:= 7; 
  eu : controle(718)); 
  
  (ctrt:= 22; mem:=ctr; 
   REF INT xx, INT incr = 0; 
  (
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7; 
  ea : ctrt:= 23; 
   IF 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ;  TRUE THEN ctr+:= 7 FI; 
  eb : ctrt:= 24; 
  (
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; 1 | ctr+:= 7, "vide"); 
  ec : ctrt:= 25; 
   CASE 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; vu IN (INT): SKIP ESAC; ctr+:= 7; 
  ed : ctrt:= 26; 
   FOR i WHILE 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ;  FALSE DO REF INT xx; SKIP OD; ctr+:= 7; 
  ee : ctrt:= 27; 
   TO  4  DO 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7 OD; 
  ef : ctrt:= 28; 
   IF 
   SKIP 
  ;  TRUE THEN 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7  FI; 
  eg : ctrt:= 29; 
  (
   SKIP 
  ;  FALSE  |  SKIP  | 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7); 
  eh : ctrt:= 30; 
   CASE  0  IN  1, 2  OUT 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7  ESAC; 
  ei : ctrt:= 31; 
  (SKIP; 
   SKIP 
  ; vu | (INT): SKIP  |  SKIP; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7); 
  ej : ctrt:= 32; 
   decr:= 2;  FOR i TO  7
      WHILE BOOL b= (decr-:= 1)>= 0; (b | 
      SKIP 
  );  REF INT xx; b
      DO SKIP; 
     (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
     (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
     tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
       OD; ctr+:= 7; 
  ek : ctrt:= 33; 
  
   SKIP 
  ; (TRUE  | 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
   | "vide"); ctr+:= 7; 
  el : ctrt:= 34; 
   IF 
   SKIP 
  ;  FALSE THEN REF INT xx;  SKIP ELSE 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
    FI; ctr+:= 7; 
  em : ctrt:= 35; 
  (
   SKIP 
  ; -1 | "vide", "vide" |  REF INT xx; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ); ctr+:= 7; 
  en : ctrt:= 36; 
   CASE REF INT xx; vu
   IN (INT a):"vide"  OUT 
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
    ESAC; ctr+:= 7; 
  eo : ctrt:= 37; 
  
   SKIP 
  ; (SKIP, 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  , (1.0, 0)); ctr+:= 7; 
  ep : ctrt:= 38; 
   CASE 
   SKIP 
  ; 3 IN  (0, 1, 2), "vide", 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
    ESAC; ctr+:= 7; 
  eq : ctrt:= 39; 
  (
   SKIP 
  ; vu | (STRING):
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  , (INT):"vide"); ctr+:= 7; 
  er : ctrt:= 40; 
  (PROC p= (REF INT kk) VOID :
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; p(
   SKIP 
  )); ctr+:= 7; 
  es : ctrt:= 41; 
  
   SKIP 
  ;  VOID :
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ; ctr+:= 7; 
  et : ctrt:= 42; 
  
   SKIP 
  ; 
  (BEGIN SKIP, REF M (NIL), HEAP M END, LOC M := 5, ctr:=:mem, 
  (1, 2, VOID (ctr+100)), (REAL x:= 3.14; VOID (ctr-mem*5/x)), VOID (-p1), ctr+:= 22, 
  tre[3], a OF srm, (INT a) VOID :ctr-:= 100)
  ); ctr+:= 7; 
  eu : controle(718)); 
  
  print((whole ((tests ok +:= ctr; ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r34a #
  (print((newline, "Choice using boolean: ")); 
   INT vf = (27+4+5+2)*(4*3+2*4)+7*6; 
   INT ctr:= 0, ctrt, mem; 
   PROC controle = (INT incr) VOID :
      (ctr/=mem+incr | 
      print(("count er in test", ctrt, ctr, mem+incr, newline))); 
   PROC test = INT : (ctr+:= 1; 1), 
     rre = [] PROC INT :(ctr+:= 1; test), 
     pche = PROC (STRING) PROC INT :
  (ctr+:= 1; (STRING a) PROC INT :test); 
   UNION (INT, STRING) vu:= 1; 
  
   MODE MSTR = STRUCT (COMPL de, of), 
   PRIO  += = 5, ? = 9, 
   OP   ?= = (INT x) VOID : x, 
      += = (INT a) PROC INT :test, 
      += = (UNION (INT, BOOL) a, INT b) BOOL :(ctr+:= 1)=b, 
      += = (UNION (REF INT, REF BOOL) a, REAL b) MSTR :  SKIP, 
      += = (MSTR a, b) REF INT : ctr+:= 1; 
  
                     # declarations pour unites du mode
                      PROC INT  #
   OP  ? = (INT a, PROC INT b)
   PROC INT :
  (ctr+:= 1; 
  test), 
   STRUCT (INT of, PROC INT de) structa
  = (0, 
  test), 
   PROC proca= ([] INT a)
   PROC INT : (ctr+:= 1; 
  test)
  , identa= PROC INT 
  :(ctr+:= 1; 
  test), 
  [] PROC PROC INT 
   ranga= identa; 
  
                     # declarations pour unites du mode
                      PROC REF BOOL  #
   OP  ? = (INT a, PROC REF BOOL b)
   PROC REF BOOL :
  (ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
   STRUCT (INT of, PROC REF BOOL de) structb
  = (0, 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
   PROC procb= ([] INT a)
   PROC REF BOOL : (ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  , identb= PROC REF BOOL 
  :(ctr+:= 1; 
   REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)), 
  [] PROC PROC REF BOOL 
   rangb= identb; 
  
                     # declarations pour unites du mode
                      PROC MSTR  #
   OP  ? = (INT a, PROC MSTR b)
   PROC MSTR :
  (ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1)), 
   STRUCT (INT of, PROC MSTR de) structc
  = (0, 
   MSTR :((0, 0), ctr+:= 1)), 
   PROC procc= ([] INT a)
   PROC MSTR : (ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1))
  , identc= PROC MSTR 
  :(ctr+:= 1; 
   MSTR :((0, 0), ctr+:= 1)), 
  [] PROC PROC MSTR 
   rangc= identc; 
  
                     # declarations pour unites du mode
                      PROC  [] PROC INT  #
   OP  ? = (INT a, PROC [] PROC INT b)
   PROC  [] PROC INT :
  (ctr+:= 1; 
  rre), 
   STRUCT (INT of, PROC [] PROC INT de) structd
  = (0, 
  rre), 
   PROC procd= ([] INT a)
   PROC [] PROC INT : (ctr+:= 1; 
  rre)
  , identd= PROC [] PROC INT 
  :(ctr+:= 1; 
  rre), 
  [] PROC PROC [] PROC INT 
   rangd= identd; 
  
                     # declarations pour unites du mode
                      PROC PROC (STRING) PROC INT  #
   OP  ? = (INT a, PROC PROC (STRING) PROC INT b)
   PROC PROC (STRING) PROC INT :
  (ctr+:= 1; 
  pche), 
   STRUCT (INT of, PROC PROC (STRING) PROC INT de) structe
  = (0, 
  pche), 
   PROC proce= ([] INT a)
   PROC PROC (STRING) PROC INT : (ctr+:= 1; 
  pche)
  , idente= PROC PROC (STRING) PROC INT 
  :(ctr+:= 1; 
  pche), 
  [] PROC PROC PROC (STRING) PROC INT 
   range= idente; 
  
                     #  contextes  #
  
  ctrt:= 1; mem:=ctr; 
  
  (FOR ident FROM 
   IF 
      ctr+:= 1; SKIP; 0<= 0
   THEN 
      ctr+:= 1; vu:= 1; 
      test
   ELSE SKIP FI 
   BY 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
   TO 
   IF 
      ctr+:= 1; SKIP; 0<= 0
   THEN 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   FI 
   WHILE 
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   ELSE SKIP FI 
   DO  [
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  : 4, -ident:
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  ]  INT ent; ent [
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   ELSE SKIP FI 
  , 0]:=ent[ident, 
   IF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   ELSE SKIP FI 
  ]:=
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      test
   FI 
   OD; 
   INT alfa, INT par= (SKIP; 
   IF 
      (ctr+:= 1; INT x= 1; x); 0<= 0
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   ELSE SKIP FI 
  ; REAL pp= 1.00001; 
   IF 
      (ctr+:= 1; INT x= 1; x); 0<= 0
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   ELSE SKIP FI 
  ); alfa:= 1+
   IF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   THEN 
      ctr+:= 1; vu:= 1; 
      test
   ELSE SKIP FI 
  ;  INT ident=
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   ELSE SKIP FI 
  , INT loc:= CASE 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   FI 
   IN 
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   ELSE SKIP FI 
  , SKIP ESAC, tas:=
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   FI 
  , PROC proc = INT :
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   ELSE SKIP FI 
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
   IF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      test
   FI 
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   ELSE SKIP FI 
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
       INT x= 1; ctr+:=x; 
      test
   ELSE SKIP FI 
  , proc)
  ; (INT BEGIN 
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
      ctr+:= 1; vu:= 1; 
      test
   ELSE SKIP FI 
   END, ?= (union; 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   FI 
   | 
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
       INT x= 1; ctr+:=x; 
      test
   FI 
  ), 
   IF 
      (ctr+:= 1; INT x= 1; x); 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      test
   FI 
  , (BOOL bool= TRUE; union | (INT):
   IF 
      (ctr+:= 1; INT x= 1; x); 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   ELSE SKIP FI 
  , (COMPL complex): SKIP)); 
  controle(27*3); 
  ctrt:= 2; mem:=ctr; 
  
   IF 
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   THEN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   FI 
  :=
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
  :=
   IF 
      ctr+:= 1; SKIP; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
  :=:
   IF 
      ctr+:= 1; SKIP; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   ELSE SKIP FI 
  ; 
  controle(4*3); 
  ctrt:= 3; mem:=ctr; 
  VOID (+=
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      test
   ELSE SKIP FI 
  += (
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   FI 
  += re OF de OF 
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   THEN 
      ctr+:= 1; vu:= 1; 
       MSTR :((0, 0), ctr+:= 1)
   FI 
  +=
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       MSTR :((0, 0), ctr+:= 1)
   ELSE SKIP FI 
  ) += +=
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   THEN 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   ELSE SKIP FI 
  )#VOID#
  ; 
  controle(5*3+5); 
  ctrt:= 4; mem:=ctr; 
  
   IF 
      ctr+:= 1; SKIP; 0<= 0
   THEN 
       INT x= 1; ctr+:=x; 
      rre
   ELSE SKIP FI 
  [1]; 
   IF 
      ctr+:= 1; INT x; 0<= 0
   THEN 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      pche)
   ELSE SKIP FI 
  (""); 
  controle(2*3+2)); 
  
  ctrt:= 5; mem:=ctr; 
  
  (FOR ident FROM 
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
   BY 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
   TO 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   WHILE 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   DO  [
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  : 4, -ident:
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ]  INT ent; ent [
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , 0]:=ent[ident, 
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
      ctr+:= 1; vu:= 1; 
      test
  )
  ]:=
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
   OD; 
   INT alfa, INT par= (SKIP; 
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ; REAL pp= 1.00001; 
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  ); alfa:= 1+
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ;  INT ident=
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , INT loc:= CASE 
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   IN 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  , SKIP ESAC, tas:=
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , PROC proc = INT :
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
      ctr+:= 1; vu:= 1; 
      test
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  , proc)
  ; (INT BEGIN 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
   END, ?= (union; 
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   | 
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ), 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , (BOOL bool= TRUE; union | (INT):
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , (COMPL complex): SKIP)); 
  controle(27*3); 
  ctrt:= 6; mem:=ctr; 
  
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  :=
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  :=:
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
  )
  ; 
  controle(4*3); 
  ctrt:= 7; mem:=ctr; 
  VOID (+=
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  += (
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
  )
  += re OF de OF 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1)
  )
  +=
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1)
  )
  ) += +=
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ) # VOID #
  ; 
  controle(5*3+5); 
  ctrt:= 8; mem:=ctr; 
  
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      rre
  )
  [1]; 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      pche EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  (""); 
  controle(2*3+2)); 
  
  ctrt:= 9; mem:=ctr; 
  
  (FOR ident FROM 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
  )
   BY 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
   TO 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
   | SKIP)
   WHILE 
  (FALSE | SKIP |: FALSE | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   DO  [
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  : 4, -ident:
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
  )
  ]  INT ent; ent [
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   | SKIP)
  , 0]:=ent[ident, 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
  ]:=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
   OD; 
   INT alfa, INT par= (SKIP; 
  (FALSE | SKIP |: FALSE | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   | SKIP)
  ; REAL pp= 1.00001; 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
  )
  ); alfa:= 1+
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  ;  INT ident=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
   | SKIP)
  , INT loc:= CASE 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
   IN 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , SKIP ESAC, tas:=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , PROC proc = INT :
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
   | SKIP)
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (FALSE | SKIP |: FALSE | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   | SKIP)
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , proc)
  ; (INT BEGIN 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
   END, ?= (union; 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   | 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  ), 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
  , (BOOL bool= TRUE; union | (INT):
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , (COMPL complex): SKIP)); 
  controle(27*3); 
  ctrt:= 10; mem:=ctr; 
  
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  )
  :=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  )
  :=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  )
  :=:
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  ; 
  controle(4*3); 
  ctrt:= 11; mem:=ctr; 
  VOID (+=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  += (
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
  )
  += re OF de OF 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       MSTR :((0, 0), ctr+:= 1))
   | SKIP)
  +=
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT e: SKIP 
   | SKIP)
  ) += +=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  ) #VOID#
  ; 
  controle(5*3+5); 
  ctrt:= 12; mem:=ctr; 
  
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
      ctr+:= 1; vu:= 1; 
      rre
  )
  [1]; 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      pche EXIT e: SKIP 
   | SKIP)
  (""); 
  controle(2*3+2)); 
  
  ctrt:= 13; mem:=ctr; 
  
  (FOR ident FROM 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
   BY 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
   TO 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
   WHILE 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
  )
   DO  [
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      ctr+:= 1; vu:= 1; 
      test
  )
  : 4, -ident:
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ]  INT ent; ent [
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
      ctr+:= 1; vu:= 1; 
      test
  )
  , 0]:=ent[ident, 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ]:=
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   OD; 
   INT alfa, INT par= (SKIP; 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  ; REAL pp= 1.00001; 
  (FALSE | SKIP |: FALSE | SKIP |:
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  ); alfa:= 1+
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  ;  INT ident=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , INT loc:= CASE 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   IN 
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , SKIP ESAC, tas:=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
      ctr+:= 1; vu:= 1; 
      test
  )
  , PROC proc = INT :
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (FALSE | SKIP |: FALSE | SKIP |:
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  , proc)
  ; (INT BEGIN 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
   END, ?= (union; 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
   | 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ), 
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  , (BOOL bool= TRUE; union | (INT):
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , (COMPL complex): SKIP)); 
  controle(27*3); 
  ctrt:= 14; mem:=ctr; 
  
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
  )
  :=
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=:
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; 
  controle(4*3); 
  ctrt:= 15; mem:=ctr; 
  VOID (+=
  (FALSE | SKIP |: FALSE | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  += (
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
  )
  += re OF de OF 
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; INT x; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT e: SKIP 
  )
  +=
  (FALSE | SKIP |: FALSE | SKIP |:
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       MSTR :((0, 0), ctr+:= 1)
  )
  ) += +=
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      test
  )
  ) #VOID#
  ; 
  controle(5*3+5); 
  ctrt:= 16; mem:=ctr; 
  
  (FALSE | SKIP |: FALSE | SKIP |:
      ctr+:= 1; SKIP; FALSE 
   | SKIP | 
       INT x= 1; ctr+:=x; 
      rre EXIT e: SKIP 
  )
  [1]; 
  (FALSE | SKIP |: FALSE | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      pche)
  )
  (""); 
  controle(2*3+2)); 
  
  ctrt:= 17; mem:=ctr; 
  
  (FOR ident FROM 
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       INT x= 1; ctr+:=x; 
      test
  )
   BY 
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
   TO 
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   | SKIP)
   WHILE 
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT e: SKIP 
   | SKIP)
   DO  [
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   | SKIP)
  : 4, -ident:
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   | SKIP)
  ]  INT ent; ent [
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   | SKIP)
  , 0]:=ent[ident, 
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
  ]:=
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
   | SKIP)
   OD; 
   INT alfa, INT par= (SKIP; 
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  ; REAL pp= 1.00001; 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  ); alfa:= 1+
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  ;  INT ident=
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , INT loc:= CASE 
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
  )
   IN 
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
   | SKIP)
  , SKIP ESAC, tas:=
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      ctr+:= 1; vu:= 1; 
      test
   | SKIP)
  , PROC proc = INT :
  (
      (ctr+:= 1; INT x= 1; x); FALSE 
   | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   | SKIP)
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   | SKIP)
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      ctr+:= 1; INT x; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
  )
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  , proc)
  ; (INT BEGIN 
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (INT x:= 10; ctr+:= 1; TRUE | 0<= 0)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
  )
   END, ?= (union; 
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
   | SKIP)
   | 
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   | SKIP)
  ), 
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      test
  )
  , (BOOL bool= TRUE; union | (INT):
  (
      ctr+:= 1; SKIP; FALSE 
   | SKIP |:
      (GOTO e; ctr+:= 100; e:ctr+:= 1); 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
  )
  , (COMPL complex): SKIP)); 
  controle(27*4); 
  ctrt:= 18; mem:=ctr; 
  
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
   | SKIP)
  :=
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
  )
  :=
  (
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   | SKIP)
  :=:
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   | SKIP)
  ; 
  controle(4*4); 
  ctrt:= 19; mem:=ctr; 
  VOID (+=
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (INT x= 5; x); ctr+:= 1; INT x; 0<= 0
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   | SKIP)
  += (
  (
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   | SKIP)
  += re OF de OF 
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP |:
       CASE ctr+:= 1; 1 IN 0<= 0, SKIP ESAC 
   | 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT 
      e: SKIP) EXIT f: GOTO e
  )
  +=
  (
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   | SKIP |:
      ctr+:= 1; SKIP; 0<= 0
   | 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1)
  )
  ) += +=
  (
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   | SKIP |:
      (ctr+:= 1; 0<= 0
       EXIT e:ctr+:= 100; SKIP)
   | 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   | SKIP)
  ) #VOID#
  ; 
  controle(5*4+5); 
  ctrt:= 20; mem:=ctr; 
  
  (
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      rre EXIT e: SKIP 
  )
  [1]; 
  (
      ctr+:= 1; INT x; FALSE 
   | SKIP |:
      (ctr+:= 1; INT x= 1; x); 0<= 0
   | 
       INT x= 1; ctr+:=x; 
      pche EXIT e: SKIP 
   | SKIP)
  (""); 
  controle(2*4+2)); 
  
  ctrt:= 21; mem:=ctr; 
  
  (FOR ident FROM 
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
   BY 
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
   TO 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
   WHILE 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   FI 
   DO  [
   IF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   FI 
  : 4, -ident:
   IF 
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   THEN SKIP ELIF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
  ]  INT ent; ent [
   IF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
  , 0]:=ent[ident, 
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
  ]:=
   IF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
   OD; 
   INT alfa, INT par= (SKIP; 
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELSE 
      ctr+:= 1; vu:= 1; 
      test
   FI 
  ; REAL pp= 1.00001; 
   IF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   FI 
  ); alfa:= 1+
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
  ;  INT ident=
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
  , INT loc:= CASE 
   IF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELSE 
      ctr+:= 1; vu:= 1; 
      test
   FI 
   IN 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      test)
   FI 
  , SKIP ESAC, tas:=
   IF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELIF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELSE 
      ctr+:= 1; vu:= 1; 
      test
   FI 
  , PROC proc = INT :
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
      test EXIT 
      e: SKIP) EXIT f: GOTO e
   FI 
  , STRUCT (COMPL of, STRUCT (INT de, COMPL of)de) de:=
  ((.111, 0), (
   IF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  , (0, 0e1))); 
  [] INT apd= (ident, par, loc, 
   IF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   FI 
  , proc, tas, de OF de OF de), 
   PROC pr:= (INT rep, reprep, PROC INT repproc) INT :
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  ; UNION (REAL, INT, COMPL)union:=pr(proc, 
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
      ctr+:= 1; vu:= 1; 
      test
   FI 
  , proc)
  ; (INT BEGIN 
   IF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   FI 
   END, ?= (union; 
   IF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; SKIP; FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
   | 
   IF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
      ctr+:= 1; vu:= 1; 
      test
   FI 
  ), 
   IF 
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   THEN SKIP ELIF 
      (ctr+:= 1; FALSE 
       EXIT e:ctr+:= 100; SKIP)
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test
   FI 
  , (BOOL bool= TRUE; union | (INT):
   IF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  , (COMPL complex): SKIP)); 
  controle(27*4); 
  ctrt:= 22; mem:=ctr; 
  
   IF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELIF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE))
   FI 
  :=
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
  :=
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
       GOTO f EXIT e:(INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE) EXIT 
      e: SKIP) EXIT f: GOTO e
   FI 
  :=:
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
  ; 
  controle(4*4); 
  ctrt:= 23; mem:=ctr; 
  VOID (+=
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELSE 
      (INT x; ctr+:= 1 EXIT e:x); 
       INT y; e:f:g:h:
      test
   FI 
  += (
   IF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
       REF BOOL :(ctr+:= 1; HEAP BOOL := TRUE)
   FI 
  += re OF de OF 
   IF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
       MSTR :((0, 0), ctr+:= 1) EXIT e: SKIP 
   FI 
  +=
   IF 
      (GOTO e; ctr+:= 100; e:ctr+:= 1); FALSE 
   THEN SKIP ELIF 
      (INT x:= 10; ctr+:= 1; TRUE | FALSE)
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
       MSTR :((0, 0), ctr+:= 1))
   FI 
  ) += +=
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
       CASE ctr+:= 1; 1 IN FALSE, SKIP ESAC 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      test EXIT e: SKIP 
   FI 
  ) #VOID#
  ; 
  controle(5*4+5); 
  ctrt:= 24; mem:=ctr; 
  
   IF 
      (ctr+:= 1; INT x= 1; x); FALSE 
   THEN SKIP ELIF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
      vu:= 1; (INT x:= 1; TRUE | 
      ctr+:= 1; x; INT y; 
      rre)
   FI 
  [1]; 
   IF 
      (INT x= 5; x); ctr+:= 1; INT x; FALSE 
   THEN SKIP ELIF 
      ctr+:= 1; INT x; FALSE 
   THEN SKIP ELSE 
       INT x= 1; ctr+:=x; 
      pche EXIT e: SKIP 
   FI 
  (""); 
  controle(2*4+2)); 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r541a #
  (print((newline, "Routine texts without parameters: ")); 
   INT vf = 47*10+45; 
   INT ctr:= 0, ctrt:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
  
   OP MON = (REAL a) REAL : (ctr+:= 1; 3.1415), 
   = = (BOOL a, INT b) INT : (a | b | ctr-:= 1), 
   UNION (INT, BOOL) vu, 
   MODE STRA = STRUCT (INT de, REF INT of), 
  [, ] INT ta = 1, 
   PROC pra = (UNION (INT, BOOL) a) INT :
  (a | (INT x) : (ctr+:= 1; x)), 
   INT ida = 1; 
   MODE STRB = STRUCT (BOOL de, REF INT of), 
  [, ] BOOL tb = TRUE, 
   PROC prb = (UNION (INT, BOOL) a) BOOL :
  (a | (BOOL x) : (ctr+:= 1; x)), 
   BOOL idb = TRUE; 
  
  # mode rendu :  PROC INT  #
  (MODE R = PROC INT; 
   PROC test = (R proc) VOID :
       IF proc= 1  THEN ctr+:= 1
       ELSE print(("er", ctrt, ctr-ctrloc, newline))  FI; 
   OP  ?=:= = (R x) R : (test(x); x); 
  
  (ctrt:= 1; ctrloc:=ctr; 
  test(INT :  LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM INT :  LOC INT := (ctr+:= 1; 1)
   BY INT :  LOC INT := (ctr+:= 1; 1)
   TO INT :  LOC INT := (ctr+:= 1; 1)
   WHILE BOOL :  LOC BOOL := (ctr+:= 1; TRUE)
   DO  [ INT :  LOC INT := (ctr+:= 1; 1) : 4, 
  -1 :  INT :  LOC INT := (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  LOC INT := (ctr+:= 1; 1), 0] :=
  ent[1, INT :  LOC INT := (ctr+:= 1; 1)]:=
   INT :  LOC INT := (ctr+:= 1; 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; INT :  LOC INT := (ctr+:= 1; 1)); 
  test(par); alfa:=?=:= (INT :  LOC INT := (ctr+:= 1; 1)); 
   R ident = INT :  LOC INT := (ctr+:= 1; 1), 
   R loc:= CASE INT :  LOC INT := (ctr+:= 1; 1) IN 
   INT :  LOC INT := (ctr+:= 1; 1), SKIP ESAC, 
  tas:= INT :  LOC INT := (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  LOC INT := (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  LOC INT := (ctr+:= 1; 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  LOC INT := (ctr+:= 1; 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  LOC INT := (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  LOC INT := (ctr+:= 1; 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  LOC INT := (ctr+:= 1; 1) END), 
  ?=:= (union; BOOL :  LOC BOOL := (ctr+:= 1; TRUE) |  INT :  LOC INT 
  := (ctr+:= 1; 1)), 
   INT :  LOC INT := (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  LOC INT := (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 2; ctrloc:=ctr; 
  test(INT :  INT : (ctr+:= 1; 1)); 
   FOR ident FROM INT :  INT : (ctr+:= 1; 1)
   BY INT :  INT : (ctr+:= 1; 1)
   TO INT :  INT : (ctr+:= 1; 1)
   WHILE BOOL :  BOOL : (ctr+:= 1;  TRUE)
   DO  [ INT :  INT : (ctr+:= 1; 1) : 4, 
  -1 :  INT :  INT : (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  INT : (ctr+:= 1; 1), 0] :=
  ent[1, INT :  INT : (ctr+:= 1; 1)]:=
   INT :  INT : (ctr+:= 1; 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  INT : (ctr+:= 1; 1); 
   REAL e = .12345; INT :  INT : (ctr+:= 1; 1)); 
  test(par); alfa:=?=:= (INT :  INT : (ctr+:= 1; 1)); 
   R ident = INT :  INT : (ctr+:= 1; 1), 
   R loc:= CASE INT :  INT : (ctr+:= 1; 1) IN 
   INT :  INT : (ctr+:= 1; 1), SKIP ESAC, 
  tas:= INT :  INT : (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  INT : (ctr+:= 1; 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  INT : (ctr+:= 1; 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT : (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT : (ctr+:= 1; 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  INT : (ctr+:= 1; 1) END), 
  ?=:= (union; BOOL :  BOOL : (ctr+:= 1;  TRUE) |  INT :  INT 
   : (ctr+:= 1; 1)), 
   INT :  INT : (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  INT : (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 3; ctrloc:=ctr; 
  test(INT : 3.1415 = MON .5 = 1); 
   FOR ident FROM INT : 3.1415 = MON .5 = 1
   BY INT : 3.1415 = MON .5 = 1
   TO INT : 3.1415 = MON .5 = 1
   WHILE BOOL : 3.1415 = MON .5 = TRUE 
   DO  [ INT : 3.1415 = MON .5 = 1 : 4, 
  -1 :  INT : 3.1415 = MON .5 = 1]  R ent; 
  ent[ INT : 3.1415 = MON .5 = 1, 0] :=
  ent[1, INT : 3.1415 = MON .5 = 1]:=
   INT : 3.1415 = MON .5 = 1; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : 3.1415 = MON .5 = 1; 
   REAL e = .12345; INT : 3.1415 = MON .5 = 1); 
  test(par); alfa:=?=:= (INT : 3.1415 = MON .5 = 1); 
   R ident = INT : 3.1415 = MON .5 = 1, 
   R loc:= CASE INT : 3.1415 = MON .5 = 1 IN 
   INT : 3.1415 = MON .5 = 1, SKIP ESAC, 
  tas:= INT : 3.1415 = MON .5 = 1; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : 3.1415 = MON .5 = 1, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : 3.1415 = MON .5 = 1, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : 3.1415 = MON .5 = 1
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : 3.1415 = MON .5 = 1); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : 3.1415 = MON .5 = 1, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : 3.1415 = MON .5 = 1 END), 
  ?=:= (union; BOOL : 3.1415 = MON .5 = TRUE  |  INT : 3.1415 = MON .5 = 1), 
   INT : 3.1415 = MON .5 = 1, 
  test((BOOL bool= FALSE; union | (R) :
   INT : 3.1415 = MON .5 = 1, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 4; ctrloc:=ctr; 
  test(INT : de OF STRA (1, ctr+:= 1)); 
   FOR ident FROM INT : de OF STRA (1, ctr+:= 1)
   BY INT : de OF STRA (1, ctr+:= 1)
   TO INT : de OF STRA (1, ctr+:= 1)
   WHILE BOOL : de OF STRB (TRUE, ctr+:= 1)
   DO  [ INT : de OF STRA (1, ctr+:= 1) : 4, 
  -1 :  INT : de OF STRA (1, ctr+:= 1)]  R ent; 
  ent[ INT : de OF STRA (1, ctr+:= 1), 0] :=
  ent[1, INT : de OF STRA (1, ctr+:= 1)]:=
   INT : de OF STRA (1, ctr+:= 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : de OF STRA (1, ctr+:= 1); 
   REAL e = .12345; INT : de OF STRA (1, ctr+:= 1)); 
  test(par); alfa:=?=:= (INT : de OF STRA (1, ctr+:= 1)); 
   R ident = INT : de OF STRA (1, ctr+:= 1), 
   R loc:= CASE INT : de OF STRA (1, ctr+:= 1) IN 
   INT : de OF STRA (1, ctr+:= 1), SKIP ESAC, 
  tas:= INT : de OF STRA (1, ctr+:= 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : de OF STRA (1, ctr+:= 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : de OF STRA (1, ctr+:= 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : de OF STRA (1, ctr+:= 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : de OF STRA (1, ctr+:= 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : de OF STRA (1, ctr+:= 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : de OF STRA (1, ctr+:= 1) END), 
   ?=:= (union;  BOOL : de OF STRB (TRUE, ctr+:= 1) | 
       INT : de OF STRA (1, ctr+:= 1)), 
   INT : de OF STRA (1, ctr+:= 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : de OF STRA (1, ctr+:= 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 5; ctrloc:=ctr; 
  test(INT : ta[ida, (ctr+:= 1; 1)]); 
   FOR ident FROM INT : ta[ida, (ctr+:= 1; 1)]
   BY INT : ta[ida, (ctr+:= 1; 1)]
   TO INT : ta[ida, (ctr+:= 1; 1)]
   WHILE BOOL : tb[ida, (ctr+:= 1; 1)]
   DO  [ INT : ta[ida, (ctr+:= 1; 1)] : 4, 
  -1 :  INT : ta[ida, (ctr+:= 1; 1)]]  R ent; 
  ent[ INT : ta[ida, (ctr+:= 1; 1)], 0] :=
  ent[1, INT : ta[ida, (ctr+:= 1; 1)]]:=
   INT : ta[ida, (ctr+:= 1; 1)]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : ta[ida, (ctr+:= 1; 1)]; 
   REAL e = .12345; INT : ta[ida, (ctr+:= 1; 1)]); 
  test(par); alfa:=?=:= (INT : ta[ida, (ctr+:= 1; 1)]); 
   R ident = INT : ta[ida, (ctr+:= 1; 1)], 
   R loc:= CASE INT : ta[ida, (ctr+:= 1; 1)] IN 
   INT : ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= INT : ta[ida, (ctr+:= 1; 1)]; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : ta[ida, (ctr+:= 1; 1)], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : ta[ida, (ctr+:= 1; 1)], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : ta[ida, (ctr+:= 1; 1)]
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : ta[ida, (ctr+:= 1; 1)]); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : ta[ida, (ctr+:= 1; 1)], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : ta[ida, (ctr+:= 1; 1)] END), 
  ?=:= (union; BOOL : tb[ida, (ctr+:= 1; 1)] |  INT : ta
  [ida, (ctr+:= 1; 1)]), 
   INT : ta[ida, (ctr+:= 1; 1)], 
  test((BOOL bool= FALSE; union | (R) :
   INT : ta[ida, (ctr+:= 1; 1)], 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 6; ctrloc:=ctr; 
  test(INT : pra(1)); 
   FOR ident FROM INT : pra(1)
   BY INT : pra(1)
   TO INT : pra(1)
   WHILE BOOL : prb(TRUE)
   DO  [ INT : pra(1) : 4, 
  -1 :  INT : pra(1)]  R ent; 
  ent[ INT : pra(1), 0] :=
  ent[1, INT : pra(1)]:=
   INT : pra(1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : pra(1); 
   REAL e = .12345; INT : pra(1)); 
  test(par); alfa:=?=:= (INT : pra(1)); 
   R ident = INT : pra(1), 
   R loc:= CASE INT : pra(1) IN 
   INT : pra(1), SKIP ESAC, 
  tas:= INT : pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : pra(1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : pra(1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : pra(1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : pra(1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : pra(1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : pra(1) END), 
  ?=:= (union; BOOL : prb(TRUE) |  INT : pra(1)), 
   INT : pra(1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : pra(1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 7; ctrloc:=ctr; 
  test(INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   FOR ident FROM INT :  INT (ctr+:= 1; ida | 1, SKIP)
   BY INT :  INT (ctr+:= 1; ida | 1, SKIP)
   TO INT :  INT (ctr+:= 1; ida | 1, SKIP)
   WHILE BOOL :  BOOL (ctr+:= 1; ida |  TRUE, SKIP)
   DO  [ INT :  INT (ctr+:= 1; ida | 1, SKIP) : 4, 
  -1 :  INT :  INT (ctr+:= 1; ida | 1, SKIP)]  R ent; 
  ent[ INT :  INT (ctr+:= 1; ida | 1, SKIP), 0] :=
  ent[1, INT :  INT (ctr+:= 1; ida | 1, SKIP)]:=
   INT :  INT (ctr+:= 1; ida | 1, SKIP); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  INT (ctr+:= 1; ida | 1, SKIP); 
   REAL e = .12345; INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= (INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   R ident = INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE INT :  INT (ctr+:= 1; ida | 1, SKIP) IN 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), SKIP ESAC, 
  tas:= INT :  INT (ctr+:= 1; ida | 1, SKIP); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  INT (ctr+:= 1; ida | 1, SKIP), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  INT (ctr+:= 1; ida | 1, SKIP) END), 
  ?=:= (union; BOOL :  BOOL (ctr+:= 1; ida |  TRUE, SKIP) |  INT :
   INT (ctr+:= 1; ida | 1, SKIP)), 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  INT (ctr+:= 1; ida | 1, SKIP), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 8; ctrloc:=ctr; 
  test(INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   FOR ident FROM INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   BY INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   TO INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   WHILE BOOL :  BEGIN INT x; ctr+:= 1; e :
   TRUE EXIT f: SKIP END 
   DO  [ INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END : 4, 
  -1 :  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END ]  R ent; 
  ent[ INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 0] :=
  ent[1, INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END ]:=
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
   REAL e = .12345; INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
  test(par); alfa:=?=:= (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   R ident = INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   R loc:= CASE INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END IN 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, SKIP ESAC, 
  tas:= INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END END), 
  ?=:= (union; BOOL :  BEGIN INT x; ctr+:= 1; e :
   TRUE EXIT f: SKIP END  |  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END), 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  test((BOOL bool= FALSE; union | (R) :
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 9; ctrloc:=ctr; 
  test(INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   FOR ident FROM INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   BY INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   TO INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   WHILE BOOL : (NOT idb |  SKIP  | ctr+:= 1; idb)
   DO  [ INT : (NOT idb |  SKIP  | ctr+:= 1; ida) : 4, 
  -1 :  INT : (NOT idb |  SKIP  | ctr+:= 1; ida)]  R ent; 
  ent[ INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 0] :=
  ent[1, INT : (NOT idb |  SKIP  | ctr+:= 1; ida)]:=
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : (NOT idb |  SKIP  | ctr+:= 1; ida
  ); 
   REAL e = .12345; INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
  test(par); alfa:=?=:= (INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   R ident = INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
   R loc:= CASE INT : (NOT idb |  SKIP  | ctr+:= 1; ida) IN 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), SKIP ESAC, 
  tas:= INT : (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : (NOT idb |  SKIP  | ctr+:= 1; ida), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : (NOT idb |  SKIP  | ctr+:= 1; ida) END), 
  ?=:= (union; BOOL : (NOT idb |  SKIP  | ctr+:= 1; idb) |  INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)), 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
  test((BOOL bool= FALSE; union | (R) :
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 10; ctrloc:=ctr; 
  test(INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   FOR ident FROM INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   BY INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   TO INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   WHILE BOOL :  CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
   DO  [ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC : 4, 
  -1 :  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC ]  R ent; 
  ent[ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 0] :=
  ent[1, INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC ]:=
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
   REAL e = .12345; INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
  test(par); alfa:=?=:= (INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   R ident = INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
   R loc:= CASE INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC IN 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, SKIP ESAC, 
  tas:= INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC END), 
  ?=:= (union; BOOL :  CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC  |  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC), 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
  test((BOOL bool= FALSE; union | (R) :
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
   SKIP); 
  
  # mode rendu :  INT  #
  (MODE R = INT; 
   PROC test = (R proc) VOID :
       IF proc= 1  THEN ctr+:= 1
       ELSE print(("er", ctrt, ctr-ctrloc, newline))  FI; 
   OP  ?=:= = (R x) R : (test(x); x); 
  
  (ctrt:= 11; ctrloc:=ctr; 
  test(INT :  LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM INT :  INT : (ctr+:= 1; 1)
   BY INT : pra(1)
   TO INT : ta[ida, (ctr+:= 1; 1)]
   WHILE BOOL : tb[ida, (ctr+:= 1; 1)]
   DO  [ INT : de OF STRA (1, ctr+:= 1) : 4, 
  -1 :  INT :  LOC INT := (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 0] :=
  ent[1, INT :  INT : (ctr+:= 1; 1)]:=
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= (INT :  INT : (ctr+:= 1; 1)); 
   R ident = INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE INT : de OF STRA (1, ctr+:= 1) IN 
   INT : ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= INT : pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : pra(1) END), 
  VOID (?=:= (union; BOOL : prb(TRUE) |  INT : pra(1))), 
   INT : de OF STRA (1, ctr+:= 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : de OF STRA (1, ctr+:= 1), 
  (CHAR car) :  SKIP))); 
  ctrl(45)); 
   SKIP); 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r541b #
  (print((newline, "Routine texts with parameters: ")); 
   INT vf = 44*10+3; 
   INT ctr:= 0, ctrt:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
   MODE MU = UNION (STRING, CHAR); 
  
   OP MON = (REAL a) REAL : (ctr+:= 1; 3.1415), 
   = = (BOOL a, INT b) INT : (a | b | ctr-:= 1), 
   UNION (INT, BOOL) vu, 
   MODE STRA = STRUCT (INT de, REF INT of), 
  [, ] INT ta = 1, 
   PROC pra = (UNION (INT, BOOL) a) INT :
  (a | (INT x) : (ctr+:= 1; x)), 
   INT ida = 1; 
   MODE STRB = STRUCT (BOOL de, REF INT of), 
  [, ] BOOL tb = TRUE, 
   PROC prb = (UNION (INT, BOOL) a) BOOL :
  (a | (BOOL x) : (ctr+:= 1; x)), 
   BOOL idb = TRUE; 
  
  # mode rendu :  PROC (INT, MU, MU) INT  #
  (MODE R = PROC (INT, MU, MU) INT; 
   PROC test = (R proc) VOID :
       IF proc(1, "", " ")= 1  THEN ctr+:= 1
       ELSE print(("er", ctrt, ctr-ctrloc, newline))  FI; 
   OP  ?=:= = (R x) R : (test(x); x); 
  
  (ctrt:= 1; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  tb[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)); 
   R ident = (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
  pra(1) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
  prb(TRUE)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
  pra(1))), 
  (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 2; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  tb[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]; 
   REAL e = .12345; (INT ida, MU b, c) INT :
  pra(1)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)); 
   R ident = (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   BOOL (ctr+:= 1; ida |  TRUE, SKIP)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP))), 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 3; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  de OF STRB (TRUE, ctr+:= 1)
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]); 
   R ident = (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
   R loc:= CASE ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1; 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida))), 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 4; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  de OF STRB (TRUE, ctr+:= 1)
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  pra(1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1; 
   REAL e = .12345; (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   R ident = (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   R loc:= CASE ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  pra(1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
  pra(1) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   BOOL (ctr+:= 1; ida |  TRUE, SKIP)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1))), 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 5; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
   BEGIN INT x; ctr+:= 1; e :
   TRUE EXIT f: SKIP END 
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]); 
   R ident = (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida), 
   R loc:= CASE ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  pra(1), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
  pra(1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
  tb[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END)), 
  (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 6; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  de OF STRB (TRUE, ctr+:= 1)
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
  pra(1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)); 
   R ident = (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
   R loc:= CASE ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1))), 
  (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 7; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
   CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]; 
   REAL e = .12345; (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)); 
   R ident = (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), 
   R loc:= CASE ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  pra(1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
  de OF STRB (TRUE, ctr+:= 1)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1))), 
  (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 8; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
   CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
  pra(1)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)); 
   R ident = (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
   R loc:= CASE ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
  pra(1) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
  (NOT idb |  SKIP  | ctr+:= 1; idb)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP))), 
  (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 9; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  de OF STRB (TRUE, ctr+:= 1)
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP); 
   REAL e = .12345; (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   R ident = (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1), 
   R loc:= CASE ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  pra(1), SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END)), 
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
  
  (ctrt:= 10; ctrloc:=ctr; 
  test((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)); 
   FOR ident FROM  ((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
  
   BY  ((INT ida, MU b, c) INT :
   BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  ) (1, "", " ")
  
   TO  ((INT ida, MU b, c) INT :
  pra(1)
  ) (1, "", " ")
  
   WHILE  ((INT ida, MU b, c) BOOL :
  tb[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
  
   DO  [((INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1)
  ) (1, "", " ")
   : 4, 
  -1 : ((INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1)
  ) (1, "", " ")
  ]  R ent; 
  ent[((INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)
  ) (1, "", " ")
  , 0] :=
  ent[1, ((INT ida, MU b, c) INT :
   INT : (ctr+:= 1; 1)
  ) (1, "", " ")
  ]:=
  (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; (INT ida, MU b, c) INT :
  pra(1)); 
  test(par); alfa:=?=:= ((INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1); 
   R ident = (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, 
   R loc:= CASE ((INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)]
  ) (1, "", " ")
   IN 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1, SKIP ESAC, 
  tas:= (INT ida, MU b, c) INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : (INT ida, MU b, c) INT :
   INT (ctr+:= 1; ida | 1, SKIP), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), ((INT ida, MU b, c) INT :
   CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
  (INT ida, MU b, c) INT :
  3.1415 = MON .5 = 1
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); (INT ida, MU b, c) INT :
  pra(1)); 
   UNION (R, CHAR) union:=pr(proc, 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN (INT ida, MU b, c) INT :
   LOC INT := (ctr+:= 1; 1) END), 
  VOID (?=:= (union; ((INT ida, MU b, c) BOOL :
   BOOL : (ctr+:= 1;  TRUE)
  ) (1, "", " ")
   | (INT ida, MU b, c) INT :
  de OF STRA (1, ctr+:= 1))), 
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
  test((BOOL bool= FALSE; union | (R) :
  (INT ida, MU b, c) INT :
  ta[ida, (ctr+:= 1; 1)], 
  (CHAR car) :  SKIP))); 
  ctrl(44)); 
   SKIP); 
  
  # corps = relation d IDENTITE #
  ctrt:= 11; ctrloc:=ctr; 
   TO  1  WHILE BOOL : vu:/=:(ctr+:= 1; NIL)
       DO  (BOOL :
           (idb | ctr | ctrt):=:ctr+:= 1 | ctr+:= 1)  OD; 
  ctrl(3); 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r541a #
  (print((newline, "Routine texts without parameters: ")); 
   INT vf = 47*10+45; 
   INT ctr:= 0, ctrt:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
  
   OP MON = (REAL a) REAL : (ctr+:= 1; 3.14), 
   = = (BOOL a, INT b) INT : (a | b | ctr-:= 1), 
   UNION (INT, BOOL) vu, 
   MODE STRA = STRUCT (INT de, REF INT of), 
  [, ] INT ta = 1, 
   PROC pra = (UNION (INT, BOOL) a) INT :
  (a | (INT x) : (ctr+:= 1; x)), 
   INT ida = 1; 
   MODE STRB = STRUCT (BOOL de, REF INT of), 
  [, ] BOOL tb = TRUE, 
   PROC prb = (UNION (INT, BOOL) a) BOOL :
  (a | (BOOL x) : (ctr+:= 1; x)), 
   BOOL idb = TRUE; 
  
  # mode rendu :  PROC INT  #
  (MODE R = PROC INT; 
   PROC test = (R proc) VOID :
       IF proc= 1  THEN ctr+:= 1
       ELSE print(("er", ctrt, ctr-ctrloc, newline))  FI; 
   OP  ?=:= = (R x) R : (test(x); x); 
  
  (ctrt:= 1; ctrloc:=ctr; 
  test(INT :  LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM INT :  LOC INT := (ctr+:= 1; 1)
   BY INT :  LOC INT := (ctr+:= 1; 1)
   TO INT :  LOC INT := (ctr+:= 1; 1)
   WHILE BOOL :  LOC BOOL := (ctr+:= 1; TRUE)
   DO  [ INT :  LOC INT := (ctr+:= 1; 1) : 4, 
  -1 :  INT :  LOC INT := (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  LOC INT := (ctr+:= 1; 1), 0] :=
  ent[1, INT :  LOC INT := (ctr+:= 1; 1)]:=
   INT :  LOC INT := (ctr+:= 1; 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; INT :  LOC INT := (ctr+:= 1; 1)); 
  test(par); alfa:=?=:= (INT :  LOC INT := (ctr+:= 1; 1)); 
   R ident = INT :  LOC INT := (ctr+:= 1; 1), 
   R loc:= CASE INT :  LOC INT := (ctr+:= 1; 1) IN 
   INT :  LOC INT := (ctr+:= 1; 1), SKIP ESAC, 
  tas:= INT :  LOC INT := (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  LOC INT := (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  LOC INT := (ctr+:= 1; 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  LOC INT := (ctr+:= 1; 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  LOC INT := (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  LOC INT := (ctr+:= 1; 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  LOC INT := (ctr+:= 1; 1) END), 
  ?=:= (union; BOOL :  LOC BOOL := (ctr+:= 1; TRUE) |  INT :  LOC INT 
  := (ctr+:= 1; 1)), 
   INT :  LOC INT := (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  LOC INT := (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 2; ctrloc:=ctr; 
  test(INT :  INT : (ctr+:= 1; 1)); 
   FOR ident FROM INT :  INT : (ctr+:= 1; 1)
   BY INT :  INT : (ctr+:= 1; 1)
   TO INT :  INT : (ctr+:= 1; 1)
   WHILE BOOL :  BOOL : (ctr+:= 1;  TRUE)
   DO  [ INT :  INT : (ctr+:= 1; 1) : 4, 
  -1 :  INT :  INT : (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  INT : (ctr+:= 1; 1), 0] :=
  ent[1, INT :  INT : (ctr+:= 1; 1)]:=
   INT :  INT : (ctr+:= 1; 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  INT : (ctr+:= 1; 1); 
   REAL e = .12345; INT :  INT : (ctr+:= 1; 1)); 
  test(par); alfa:=?=:= (INT :  INT : (ctr+:= 1; 1)); 
   R ident = INT :  INT : (ctr+:= 1; 1), 
   R loc:= CASE INT :  INT : (ctr+:= 1; 1) IN 
   INT :  INT : (ctr+:= 1; 1), SKIP ESAC, 
  tas:= INT :  INT : (ctr+:= 1; 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  INT : (ctr+:= 1; 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  INT : (ctr+:= 1; 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT : (ctr+:= 1; 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT : (ctr+:= 1; 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  INT : (ctr+:= 1; 1) END), 
  ?=:= (union; BOOL :  BOOL : (ctr+:= 1;  TRUE) |  INT :  INT 
   : (ctr+:= 1; 1)), 
   INT :  INT : (ctr+:= 1; 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  INT : (ctr+:= 1; 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 3; ctrloc:=ctr; 
  test(INT : 3.14 = MON .5 = 1); 
   FOR ident FROM INT : 3.14 = MON .5 = 1
   BY INT : 3.14 = MON .5 = 1
   TO INT : 3.14 = MON .5 = 1
   WHILE BOOL : 3.14 = MON .5 = TRUE 
   DO  [ INT : 3.14 = MON .5 = 1 : 4, 
  -1 :  INT : 3.14 = MON .5 = 1]  R ent; 
  ent[ INT : 3.14 = MON .5 = 1, 0] :=
  ent[1, INT : 3.14 = MON .5 = 1]:=
   INT : 3.14 = MON .5 = 1; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : 3.14 = MON .5 = 1; 
   REAL e = .12345; INT : 3.14 = MON .5 = 1); 
  test(par); alfa:=?=:= (INT : 3.14 = MON .5 = 1); 
   R ident = INT : 3.14 = MON .5 = 1, 
   R loc:= CASE INT : 3.14 = MON .5 = 1 IN 
   INT : 3.14 = MON .5 = 1, SKIP ESAC, 
  tas:= INT : 3.14 = MON .5 = 1; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : 3.14 = MON .5 = 1, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : 3.14 = MON .5 = 1, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : 3.14 = MON .5 = 1
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : 3.14 = MON .5 = 1); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : 3.14 = MON .5 = 1, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : 3.14 = MON .5 = 1 END), 
  ?=:= (union; BOOL : 3.14 = MON .5 = TRUE  |  INT : 3.14 = MON .5 = 1), 
   INT : 3.14 = MON .5 = 1, 
  test((BOOL bool= FALSE; union | (R) :
   INT : 3.14 = MON .5 = 1, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 4; ctrloc:=ctr; 
  test(INT : de OF STRA (1, ctr+:= 1)); 
   FOR ident FROM INT : de OF STRA (1, ctr+:= 1)
   BY INT : de OF STRA (1, ctr+:= 1)
   TO INT : de OF STRA (1, ctr+:= 1)
   WHILE BOOL : de OF STRB (TRUE, ctr+:= 1)
   DO  [ INT : de OF STRA (1, ctr+:= 1) : 4, 
  -1 :  INT : de OF STRA (1, ctr+:= 1)]  R ent; 
  ent[ INT : de OF STRA (1, ctr+:= 1), 0] :=
  ent[1, INT : de OF STRA (1, ctr+:= 1)]:=
   INT : de OF STRA (1, ctr+:= 1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : de OF STRA (1, ctr+:= 1); 
   REAL e = .12345; INT : de OF STRA (1, ctr+:= 1)); 
  test(par); alfa:=?=:= (INT : de OF STRA (1, ctr+:= 1)); 
   R ident = INT : de OF STRA (1, ctr+:= 1), 
   R loc:= CASE INT : de OF STRA (1, ctr+:= 1) IN 
   INT : de OF STRA (1, ctr+:= 1), SKIP ESAC, 
  tas:= INT : de OF STRA (1, ctr+:= 1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : de OF STRA (1, ctr+:= 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : de OF STRA (1, ctr+:= 1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : de OF STRA (1, ctr+:= 1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : de OF STRA (1, ctr+:= 1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : de OF STRA (1, ctr+:= 1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : de OF STRA (1, ctr+:= 1) END), 
   ?=:= (union;  BOOL : de OF STRB (TRUE, ctr+:= 1) | 
       INT : de OF STRA (1, ctr+:= 1)), 
   INT : de OF STRA (1, ctr+:= 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : de OF STRA (1, ctr+:= 1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 5; ctrloc:=ctr; 
  test(INT : ta[ida, (ctr+:= 1; 1)]); 
   FOR ident FROM INT : ta[ida, (ctr+:= 1; 1)]
   BY INT : ta[ida, (ctr+:= 1; 1)]
   TO INT : ta[ida, (ctr+:= 1; 1)]
   WHILE BOOL : tb[ida, (ctr+:= 1; 1)]
   DO  [ INT : ta[ida, (ctr+:= 1; 1)] : 4, 
  -1 :  INT : ta[ida, (ctr+:= 1; 1)]]  R ent; 
  ent[ INT : ta[ida, (ctr+:= 1; 1)], 0] :=
  ent[1, INT : ta[ida, (ctr+:= 1; 1)]]:=
   INT : ta[ida, (ctr+:= 1; 1)]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : ta[ida, (ctr+:= 1; 1)]; 
   REAL e = .12345; INT : ta[ida, (ctr+:= 1; 1)]); 
  test(par); alfa:=?=:= (INT : ta[ida, (ctr+:= 1; 1)]); 
   R ident = INT : ta[ida, (ctr+:= 1; 1)], 
   R loc:= CASE INT : ta[ida, (ctr+:= 1; 1)] IN 
   INT : ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= INT : ta[ida, (ctr+:= 1; 1)]; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : ta[ida, (ctr+:= 1; 1)], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : ta[ida, (ctr+:= 1; 1)], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : ta[ida, (ctr+:= 1; 1)]
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : ta[ida, (ctr+:= 1; 1)]); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : ta[ida, (ctr+:= 1; 1)], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : ta[ida, (ctr+:= 1; 1)] END), 
  ?=:= (union; BOOL : tb[ida, (ctr+:= 1; 1)] |  INT : ta
  [ida, (ctr+:= 1; 1)]), 
   INT : ta[ida, (ctr+:= 1; 1)], 
  test((BOOL bool= FALSE; union | (R) :
   INT : ta[ida, (ctr+:= 1; 1)], 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 6; ctrloc:=ctr; 
  test(INT : pra(1)); 
   FOR ident FROM INT : pra(1)
   BY INT : pra(1)
   TO INT : pra(1)
   WHILE BOOL : prb(TRUE)
   DO  [ INT : pra(1) : 4, 
  -1 :  INT : pra(1)]  R ent; 
  ent[ INT : pra(1), 0] :=
  ent[1, INT : pra(1)]:=
   INT : pra(1); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : pra(1); 
   REAL e = .12345; INT : pra(1)); 
  test(par); alfa:=?=:= (INT : pra(1)); 
   R ident = INT : pra(1), 
   R loc:= CASE INT : pra(1) IN 
   INT : pra(1), SKIP ESAC, 
  tas:= INT : pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : pra(1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : pra(1), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : pra(1)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : pra(1)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : pra(1), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : pra(1) END), 
  ?=:= (union; BOOL : prb(TRUE) |  INT : pra(1)), 
   INT : pra(1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : pra(1), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 7; ctrloc:=ctr; 
  test(INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   FOR ident FROM INT :  INT (ctr+:= 1; ida | 1, SKIP)
   BY INT :  INT (ctr+:= 1; ida | 1, SKIP)
   TO INT :  INT (ctr+:= 1; ida | 1, SKIP)
   WHILE BOOL :  BOOL (ctr+:= 1; ida |  TRUE, SKIP)
   DO  [ INT :  INT (ctr+:= 1; ida | 1, SKIP) : 4, 
  -1 :  INT :  INT (ctr+:= 1; ida | 1, SKIP)]  R ent; 
  ent[ INT :  INT (ctr+:= 1; ida | 1, SKIP), 0] :=
  ent[1, INT :  INT (ctr+:= 1; ida | 1, SKIP)]:=
   INT :  INT (ctr+:= 1; ida | 1, SKIP); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  INT (ctr+:= 1; ida | 1, SKIP); 
   REAL e = .12345; INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= (INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   R ident = INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE INT :  INT (ctr+:= 1; ida | 1, SKIP) IN 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), SKIP ESAC, 
  tas:= INT :  INT (ctr+:= 1; ida | 1, SKIP); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  INT (ctr+:= 1; ida | 1, SKIP), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  INT (ctr+:= 1; ida | 1, SKIP) END), 
  ?=:= (union; BOOL :  BOOL (ctr+:= 1; ida |  TRUE, SKIP) |  INT :
   INT (ctr+:= 1; ida | 1, SKIP)), 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), 
  test((BOOL bool= FALSE; union | (R) :
   INT :  INT (ctr+:= 1; ida | 1, SKIP), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 8; ctrloc:=ctr; 
  test(INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   FOR ident FROM INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   BY INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   TO INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
   WHILE BOOL :  BEGIN INT x; ctr+:= 1; e :
   TRUE EXIT f: SKIP END 
   DO  [ INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END : 4, 
  -1 :  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END ]  R ent; 
  ent[ INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 0] :=
  ent[1, INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END ]:=
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
   REAL e = .12345; INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
  test(par); alfa:=?=:= (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   R ident = INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   R loc:= CASE INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END IN 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, SKIP ESAC, 
  tas:= INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END END), 
  ?=:= (union; BOOL :  BEGIN INT x; ctr+:= 1; e :
   TRUE EXIT f: SKIP END  |  INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END), 
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  test((BOOL bool= FALSE; union | (R) :
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 9; ctrloc:=ctr; 
  test(INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   FOR ident FROM INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   BY INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   TO INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
   WHILE BOOL : (NOT idb |  SKIP  | ctr+:= 1; idb)
   DO  [ INT : (NOT idb |  SKIP  | ctr+:= 1; ida) : 4, 
  -1 :  INT : (NOT idb |  SKIP  | ctr+:= 1; ida)]  R ent; 
  ent[ INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 0] :=
  ent[1, INT : (NOT idb |  SKIP  | ctr+:= 1; ida)]:=
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT : (NOT idb |  SKIP  | ctr+:= 1; ida
  ); 
   REAL e = .12345; INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
  test(par); alfa:=?=:= (INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   R ident = INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
   R loc:= CASE INT : (NOT idb |  SKIP  | ctr+:= 1; ida) IN 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), SKIP ESAC, 
  tas:= INT : (NOT idb |  SKIP  | ctr+:= 1; ida); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT : (NOT idb |  SKIP  | ctr+:= 1; ida), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT : (NOT idb |  SKIP  | ctr+:= 1; ida)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : (NOT idb |  SKIP  | ctr+:= 1; ida) END), 
  ?=:= (union; BOOL : (NOT idb |  SKIP  | ctr+:= 1; idb) |  INT :
  (NOT idb |  SKIP  | ctr+:= 1; ida)), 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
  test((BOOL bool= FALSE; union | (R) :
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida), 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
  
  (ctrt:= 10; ctrloc:=ctr; 
  test(INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   FOR ident FROM INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   BY INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   TO INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
   WHILE BOOL :  CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC 
   DO  [ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC : 4, 
  -1 :  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC ]  R ent; 
  ent[ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 0] :=
  ent[1, INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC ]:=
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
   REAL e = .12345; INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
  test(par); alfa:=?=:= (INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   R ident = INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
   R loc:= CASE INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC IN 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, SKIP ESAC, 
  tas:= INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC 
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC END), 
  ?=:= (union; BOOL :  CASE vu:= (ctr+:= 1; TRUE) IN 
  (BOOL x) : x ESAC  |  INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC), 
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
  test((BOOL bool= FALSE; union | (R) :
   INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 
  (CHAR car) :  SKIP))); 
  ctrl(47)); 
   SKIP); 
  
  # mode rendu :  INT  #
  (MODE R = INT; 
   PROC test = (R proc) VOID :
       IF proc= 1  THEN ctr+:= 1
       ELSE print(("er", ctrt, ctr-ctrloc, newline))  FI; 
   OP  ?=:= = (R x) R : (test(x); x); 
  
  (ctrt:= 11; ctrloc:=ctr; 
  test(INT :  LOC INT := (ctr+:= 1; 1)); 
   FOR ident FROM INT :  INT : (ctr+:= 1; 1)
   BY INT : pra(1)
   TO INT : ta[ida, (ctr+:= 1; 1)]
   WHILE BOOL : tb[ida, (ctr+:= 1; 1)]
   DO  [ INT : de OF STRA (1, ctr+:= 1) : 4, 
  -1 :  INT :  LOC INT := (ctr+:= 1; 1)]  R ent; 
  ent[ INT :  CASE vu:= (ctr+:= 1; 1) IN 
  (INT x) : x ESAC, 0] :=
  ent[1, INT :  INT : (ctr+:= 1; 1)]:=
   INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; INT :  LOC INT := (ctr+:= 1; 1); 
   REAL e = .12345; INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
  test(par); alfa:=?=:= (INT :  INT : (ctr+:= 1; 1)); 
   R ident = INT :  INT (ctr+:= 1; ida | 1, SKIP), 
   R loc:= CASE INT : de OF STRA (1, ctr+:= 1) IN 
   INT : ta[ida, (ctr+:= 1; 1)], SKIP ESAC, 
  tas:= INT : pra(1); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  INT :  INT : (ctr+:= 1; 1), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (INT :  BEGIN INT x; ctr+:= 1; e :
  1 EXIT f: SKIP END, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   INT : (NOT idb |  SKIP  | ctr+:= 1; ida)
  , proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); INT :  INT (ctr+:= 1; ida | 1, SKIP)); 
   UNION (R, CHAR) union:=pr(proc, 
   INT :  INT (ctr+:= 1; ida | 1, SKIP), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN INT : pra(1) END), 
  VOID (?=:= (union; BOOL : prb(TRUE) |  INT : pra(1))), 
   INT : de OF STRA (1, ctr+:= 1), 
  test((BOOL bool= FALSE; union | (R) :
   INT : de OF STRA (1, ctr+:= 1), 
  (CHAR car) :  SKIP))); 
  ctrl(45)); 
   SKIP); 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r542a #
  (print((newline, "Monadic formulas: ")); 
   INT vf = 18*(8+2)+33*(8+2+5); 
   INT ctrt:= 0, ctr:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
   MODE R = INT; 
   PROC test = (INT a) VOID : (a= 1 | ctr+:= 1
   | print(("er", ctrt, ctr-ctrloc, newline))); 
   OP  ?=:= = (INT x) INT : (test(x); x); 
  
   INT b= 2, c= 3, d= 4, e= 5, f= 6, g= 7, h= 8, i= 9, j= 10; 
   STRUCT (INT d2, d3, d4, d5, d6, d7, d8, d9, d0) str =
      (2, 3, 4, 5, 6, 7, 8, 9, 10); 
  [, ] INT t= ((0, b, c, d, e, f, g, h, i, j), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)), 
   PROC call = (INT a) INT : (a= 0 | 10 | a), 
   OP  & = (BOOL a, INT b) STRUCT (INT a, b) : (b, 0), 
      & = (CHAR a, STRUCT (INT a, b) b) INT : a OF b; 
   PRIO  & = 3; 
  
  # contextes demandant un mode : ent #
  (
  # definition des operateurs #
   OP M = (INT a) INT : (ctr+:= 1; a-1); 
  
  # nombre de monadiques : 1 #
  
  (ctrt:= 1; ctrloc:=ctr; 
  test(M  2); 
   FOR ident FROM M  2
   BY M  2
   TO M  2
   WHILE  1= (M  2)
   DO  [ M  2 : 4, 
  -1 :  M  2]  R ent; 
  ent [ M  2, 0 ] :=
  ent[ 1, M  2] :=
   M  2; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M  2); 
   REAL pi = .12345;  M  2); 
  test(par); alfa:=?=:= M  2
  ; 
   R ident = M  2, 
   R loc:= CASE M  2  IN 
   M  2, SKIP ESAC, 
  tas:= M  2; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M  2, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M  2, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M  2, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M  2); 
   UNION (R, CHAR) union := pr(proc, 
   M  2, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M  2 END), 
  VOID (?=:= (union; 1= (M  2)
   |  M  2)), 
   VOID (M  2), 
  test((BOOL bool= FALSE; union | (R) :
   M  2, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 2; ctrloc:=ctr; 
  test(M b); 
   FOR ident FROM M b
   BY M b
   TO M b
   WHILE  1= (M b)
   DO  [ M b : 4, 
  -1 :  M b]  R ent; 
  ent [ M b, 0 ] :=
  ent[ 1, M b] :=
   M b; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M b); 
   REAL pi = .12345;  M b); 
  test(par); alfa:=?=:= M b
  ; 
   R ident = M b, 
   R loc:= CASE M b IN 
   M b, SKIP ESAC, 
  tas:= M b; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M b, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M b, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M b, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M b); 
   UNION (R, CHAR) union := pr(proc, 
   M b, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M b END), 
  VOID (?=:= (union; 1= (M b) |  M b)), 
   VOID (M b), 
  test((BOOL bool= FALSE; union | (R) :
   M b, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 3; ctrloc:=ctr; 
  test(M d2 OF str); 
   FOR ident FROM M d2 OF str
   BY M d2 OF str
   TO M d2 OF str
   WHILE  1= (M d2 OF str)
   DO  [ M d2 OF str : 4, 
  -1 :  M d2 OF str]  R ent; 
  ent [ M d2 OF str, 0 ] :=
  ent[ 1, M d2 OF str] :=
   M d2 OF str; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M d2 OF str); 
   REAL pi = .12345;  M d2 OF str); 
  test(par); alfa:=?=:= M d2 OF str
  ; 
   R ident = M d2 OF str, 
   R loc:= CASE M d2 OF str IN 
   M d2 OF str, SKIP ESAC, 
  tas:= M d2 OF str; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M d2 OF str, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M d2 OF str, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M d2 OF str, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M d2 OF str); 
   UNION (R, CHAR) union := pr(proc, 
   M d2 OF str, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M d2 OF str END), 
  VOID (?=:= (union; 1= (M d2 OF str) |  M d2 OF str)), 
   VOID (M d2 OF str), 
  test((BOOL bool= FALSE; union | (R) :
   M d2 OF str, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 4; ctrloc:=ctr; 
  test(M t[, b][2]); 
   FOR ident FROM M t[, b][2]
   BY M t[, b][2]
   TO M t[, b][2]
   WHILE  1= (M t[, b][2])
   DO  [ M t[, b][2] : 4, 
  -1 :  M t[, b][2]]  R ent; 
  ent [ M t[, b][2], 0 ] :=
  ent[ 1, M t[, b][2]] :=
   M t[, b][2]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M t[, b][2]); 
   REAL pi = .12345;  M t[, b][2]); 
  test(par); alfa:=?=:= M t[, b][2]
  ; 
   R ident = M t[, b][2], 
   R loc:= CASE M t[, b][2]  IN 
   M t[, b][2], SKIP ESAC, 
  tas:= M t[, b][2]; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M t[, b][2], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M t[, b][2], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M t[, b][2], proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M t[, b][2]); 
   UNION (R, CHAR) union := pr(proc, 
   M t[, b][2], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M t[, b][2] END), 
  VOID (?=:= (union; 1= (M t[, b][2]) |  M t[, b][2])), 
   VOID (M t[, b][2]), 
  test((BOOL bool= FALSE; union | (R) :
   M t[, b][2], 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 5; ctrloc:=ctr; 
  test(M call(2)); 
   FOR ident FROM M call(2)
   BY M call(2)
   TO M call(2)
   WHILE  1= (M call(2))
   DO  [ M call(2) : 4, 
  -1 :  M call(2)]  R ent; 
  ent [ M call(2), 0 ] :=
  ent[ 1, M call(2)] :=
   M call(2); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M call(2)); 
   REAL pi = .12345;  M call(2)); 
  test(par); alfa:=?=:= M call(2)
  ; 
   R ident = M call(2), 
   R loc:= CASE M call(2)  IN 
   M call(2), SKIP ESAC, 
  tas:= M call(2); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M call(2), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M call(2), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M call(2), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M call(2)); 
   UNION (R, CHAR) union := pr(proc, 
   M call(2), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M call(2) END), 
  VOID (?=:= (union; 1= (M call(2)) |  M call(2))), 
   VOID (M call(2)), 
  test((BOOL bool= FALSE; union | (R) :
   M call(2), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 6; ctrloc:=ctr; 
  test(M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI); 
   FOR ident FROM M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI 
   BY M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI 
   TO M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI 
   WHILE  1= (M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI)
   DO  [ M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI : 4, 
  -1 :  M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI ]  R ent; 
  ent [ M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, 0 ] :=
  ent[ 1, M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI ] :=
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI; 
   REAL pi = .12345;  M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI); 
  test(par); alfa:=?=:= M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI 
  ; 
   R ident = M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, 
   R loc:= CASE M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI IN 
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, SKIP ESAC, 
  tas:= M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI); 
   UNION (R, CHAR) union := pr(proc, 
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI END), 
  ?=:= (union; 1= (M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI)
   |  M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI), 
   VOID (M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI), 
  test((BOOL bool= FALSE; union | (R) :
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 7; ctrloc:=ctr; 
  test(M (INT x:=b; x)); 
   FOR ident FROM M (INT x:=b; x)
   BY M (INT x:=b; x)
   TO M (INT x:=b; x)
   WHILE  1= (M (INT x:=b; x))
   DO  [ M (INT x:=b; x) : 4, 
  -1 :  M (INT x:=b; x)]  R ent; 
  ent [ M (INT x:=b; x), 0 ] :=
  ent[ 1, M (INT x:=b; x)] :=
   M (INT x:=b; x); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M (INT x:=b; x)); 
   REAL pi = .12345;  M (INT x:=b; x)); 
  test(par); alfa:=?=:= M (INT x:=b; x)
  ; 
   R ident = M (INT x:=b; x), 
   R loc:= CASE M (INT x:=b; x)  IN 
   M (INT x:=b; x), SKIP ESAC, 
  tas:= M (INT x:=b; x); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M (INT x:=b; x), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M (INT x:=b; x), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M (INT x:=b; x), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M (INT x:=b; x)); 
   UNION (R, CHAR) union := pr(proc, 
   M (INT x:=b; x), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M (INT x:=b; x) END), 
  VOID (?=:= (union; 1= (M (INT x:=b; x))
   |  M (INT x:=b; x))), 
   VOID (M (INT x:=b; x)), 
  test((BOOL bool= FALSE; union | (R) :
   M (INT x:=b; x), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  (ctrt:= 8; ctrloc:=ctr; 
  test(M ("#" & (TRUE  &
   2))); 
   FOR ident FROM M  2
   BY M  2
   TO M  2
   WHILE  1= (M  2)
   DO  [ M  2 : 4, 
  -1 :  M  2]  R ent; 
  ent [ M  2, 0 ] :=
  ent[ 1, M  2] :=
   M  2; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M  2); 
   REAL pi = .12345;  M  2); 
  test(par); alfa:=?=:= M  2
  ; 
   R ident = M  2, 
   R loc:= CASE M  2  IN 
   M  2, SKIP ESAC, 
  tas:= M  2; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M  2, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M  2, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M  2, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M  2); 
   UNION (R, CHAR) union := pr(proc, 
   M  2, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M  2 END), 
  VOID (?=:= (union; 1= (M  2) |  M  2)), 
   VOID (M  2), 
  test((BOOL bool= FALSE; union | (R) :
   M  2, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*1)); 
  
  
  # nombre de monadiques : 2 #
  
  (ctrt:= 9; ctrloc:=ctr; 
  test(M M c); 
   FOR ident FROM M M call(3)
   BY M M t[, c][2]
   TO M M t[, c][2]
   WHILE  1= (M M d3 OF str)
   DO  [ M M  3 : 4, 
  -1 :  M M ("#" & (TRUE  &
  c))]  R ent; 
  ent [ M M (INT x:=c; x), 0 ] :=
  ent[ 1, M M  3] :=
   M M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M M c); 
   REAL pi = .12345;  M M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI); 
  test(par); alfa:=?=:= M M d3 OF str
  ; 
   R ident = M M t[, c][2], 
   R loc:= CASE M M call(3)  IN 
   M M c, SKIP ESAC, 
  tas:= M M (INT x:=c; x); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M M (INT x:=c; x), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M M call(3)); 
   UNION (R, CHAR) union := pr(proc, 
   M M call(3), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M M call(3) END), 
  ?=:= (union; 1= (M M d3 OF str)
   |  M M d3 OF str), 
   VOID (M M d3 OF str), 
  test((BOOL bool= FALSE; union | (R) :
   M M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*2)); 
  
  
  # nombre de monadiques : 5 #
  
  (ctrt:= 10; ctrloc:=ctr; 
  test(M M M M M ("#" & (TRUE  &
  d6 OF str))); 
   FOR ident FROM M M M M M t[, f][2]
   BY M M M M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI 
   TO M M M M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI 
   WHILE  1= (M M M M M  6)
   DO  [ M M M M M (INT x:=f; x) : 4, 
  -1 :  M M M M M (INT x:=f; x)]  R ent; 
  ent [ M M M M M t[, f][2], 0 ] :=
  ent[ 1, M M M M M call(6)] :=
   M M M M M t[, f][2]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; M M M M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI; 
   REAL pi = .12345;  M M M M M t[, f][2]); 
  test(par); alfa:=?=:= M M M M M f
  ; 
   R ident = M M M M M (INT x:=f; x), 
   R loc:= CASE M M M M M (INT x:=f; x)  IN 
   M M M M M (INT x:=f; x), SKIP ESAC, 
  tas:= M M M M M (INT x:=f; x); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M M M M M f, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M M M M M call(6), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M M M M M call(6), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M M M M M call(6)); 
   UNION (R, CHAR) union := pr(proc, 
   M M M M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M M M M M t[, f][2] END), 
  ?=:= (union; 1= (M M M M M t[, f][2]) |  M M M M M f), 
  VOID (M M M M M f), 
  test((BOOL bool= FALSE; union | (R) :
   M M M M M t[, f][2], 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*5)); 
  
   SKIP); 
  # contextes demandant un mode : rep #
  (OP M = (INT a) REF INT :  HEAP INT := (ctr+:= 1; a-1); 
  
  # nombre de operateurs : 1 #
  ctrt:= 11; ctrloc:=ctr; 
  test(M  2:=
   M  2:=
  (M  2:/=:
   M  2 | 
   M  2)); 
  ctrl(1+5*1); 
  ctrt:= 12; ctrloc:=ctr; 
  test(M b:=
   M b:=
  (M b:/=:
   M b | 
   M b)); 
  ctrl(1+5*1); 
  ctrt:= 13; ctrloc:=ctr; 
  test(M d2 OF str:=
   M d2 OF str:=
  (M d2 OF str:/=:
   M d2 OF str | 
   M d2 OF str)); 
  ctrl(1+5*1); 
  ctrt:= 14; ctrloc:=ctr; 
  test(M t[, b][2]:=
   M t[, b][2]:=
  (M t[, b][2]:/=:
   M t[, b][2] | 
   M t[, b][2])); 
  ctrl(1+5*1); 
  ctrt:= 15; ctrloc:=ctr; 
  test(M call(2):=
   M call(2):=
  (M call(2):/=:
   M call(2) | 
   M call(2))); 
  ctrl(1+5*1); 
  ctrt:= 16; ctrloc:=ctr; 
  test(M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI :=
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI :=
  (M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI :/=:
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI  | 
   M PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI)); 
  ctrl(1+5*1); 
  ctrt:= 17; ctrloc:=ctr; 
  test(M (INT x:=b; x):=
   M (INT x:=b; x):=
  (M (INT x:=b; x):/=:
   M (INT x:=b; x) | 
   M (INT x:=b; x))); 
  ctrl(1+5*1); 
  ctrt:= 18; ctrloc:=ctr; 
  test(M ("#" & (TRUE  &
  call(2))):=
   M call(2):=
  (M call(2):/=:
   M call(2) | 
   M call(2))); 
  ctrl(1+5*1); 
  
  # nombre de operateurs : 2 #
  ctrt:= 19; ctrloc:=ctr; 
  test(M M t[, c][2]:=
   M M ("#" & (TRUE  &
  t[, c][2])):=
  (M M d3 OF str:/=:
   M M call(3) | 
   M M c)); 
  ctrl(1+5*2); 
  
  # nombre de operateurs : 5 #
  ctrt:= 20; ctrloc:=ctr; 
  test(M M M M M f:=
   M M M M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI :=
  (M M M M M t[, f][2]:/=:
   M M M M M t[, f][2] | 
   M M M M M  6)); 
  ctrl(1+5*5); 
   SKIP); 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r542b #
  (print((newline, "Dyadic formulas: ")); 
   INT vf = 17*(8+2) + 28*(8*4+15+14); 
   INT ctrt:= 0, ctr:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
   MODE R = INT; 
   PROC test = (INT a) VOID : (a= 1 | ctr+:= 1
   | print(("er", ctrt, ctr-ctrloc, newline))); 
   OP  ?=:= = (INT x) INT : (test(x); x); 
  
   INT b= 2, c= 3, d= 4, e= 5, f= 6, g= 7, h= 8, i= 9, j= 10; 
   STRUCT (INT d2, d3, d4, d5, d6, d7, d8, d9, d0) str =
      (2, 3, 4, 5, 6, 7, 8, 9, 10); 
  [, ] INT t= ((0, b, c, d, e, f, g, h, i, j), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)), 
   PROC call = (INT a) INT : (a= 0 | 10 | a), 
   OP  & = (BOOL a, INT b) STRUCT (INT a, b) : (b, 0), 
      & = (CHAR a, STRUCT (INT a, b) b) INT : a OF b; 
   PRIO  & = 3; 
   PRIO A = 1, B = 2, C = 3, D = 4, E = 5, F = 6, G = 7, H = 8, I = 9; 
  
  # contextes demandant un mode : ent #
  (
  # definition des operateurs #
   OP M = (INT a) INT : (ctr+:= 1; a-1); 
   PROC dyad = (INT a, b) INT : ((a=b | ctr+:= 1 | 
      print(("er.prio", ctrt, ctr-ctrloc, a, b, newline))); a-1); 
   OP (INT, INT) INT A =dyad, B =dyad, C =dyad, 
       D =dyad, E =dyad, F =dyad, G =dyad, H =dyad, I =dyad; 
  
  # nombre de operateurs : 4 #
  
  (ctrt:= 1; ctrloc:=ctr; 
  test(M  3 D M M  4); 
   FOR ident FROM M  3 D M M  4
   BY M  3 D M M  4
   TO M  3 D M M  4
   WHILE  1= (M  3 D M M  4)
   DO  [ M  3 D M M  4 : 4, 
  -1 :  M  3 D M M  4]  R ent; 
  ent [ M  3 D M M  4, 0 ] :=
  ent[ 1, M  3 D M M  4] :=
   M  3 D M M  4; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M  3 D M M  4); 
   REAL pi = .12345;  M  3 D M M  4); 
  test(par); 
  alfa:=?=:= (M  3 D M M  4); 
   R ident = M  3 D M M  4, 
   R loc:= CASE M  3 D M M  4  IN 
   M  3 D M M  4, SKIP ESAC, 
  tas:= M  3 D M M  4; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M  3 D M M  4, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M  3 D M M  4, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M  3 D M M  4, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M  3 D M M  4); 
   UNION (R, CHAR) union := pr(proc, 
   M  3 D M M  4, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M  3 D M M  4 END), 
  ?=:= (union; 1= (M  3 D M M  4) |  M  3 D M M  4), 
   VOID (M  3 D M M  4), 
  test((BOOL bool= FALSE; union | (R) :
   M  3 D M M  4, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 2; ctrloc:=ctr; 
  test(M c D M M d); 
   FOR ident FROM M c D M M d
   BY M c D M M d
   TO M c D M M d
   WHILE  1= (M c D M M d)
   DO  [ M c D M M d : 4, 
  -1 :  M c D M M d]  R ent; 
  ent [ M c D M M d, 0 ] :=
  ent[ 1, M c D M M d] :=
   M c D M M d; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M c D M M d); 
   REAL pi = .12345;  M c D M M d); 
  test(par); 
  alfa:=?=:= (M c D M M d); 
   R ident = M c D M M d, 
   R loc:= CASE M c D M M d IN 
   M c D M M d, SKIP ESAC, 
  tas:= M c D M M d; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M c D M M d, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M c D M M d, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M c D M M d, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M c D M M d); 
   UNION (R, CHAR) union := pr(proc, 
   M c D M M d, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M c D M M d END), 
  ?=:= (union; 1= (M c D M M d)
   |  M c D M M d), 
   VOID (M c D M M d), 
  test((BOOL bool= FALSE; union | (R) :
   M c D M M d, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 3; ctrloc:=ctr; 
  test(M d3 OF str D M M d4 OF str); 
   FOR ident FROM M d3 OF str D M M d4 OF str
   BY M d3 OF str D M M d4 OF str
   TO M d3 OF str D M M d4 OF str
   WHILE  1= (M d3 OF str D M M d4 OF str)
   DO  [ M d3 OF str D M M d4 OF str : 4, 
  -1 :  M d3 OF str D M M d4 OF str]  R ent; 
  ent [ M d3 OF str D M M d4 OF str, 0 ] :=
  ent[ 1, M d3 OF str D M M d4 OF str] :=
   M d3 OF str D M M d4 OF str; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M d3 OF str D M M d4 OF str); 
   REAL pi = .12345;  M d3 OF str D M M d4 OF str); 
  test(par); 
  alfa:=?=:= (M d3 OF str D M M d4 OF str); 
   R ident = M d3 OF str D M M d4 OF str, 
   R loc:= CASE M d3 OF str D M M d4 OF str IN 
   M d3 OF str D M M d4 OF str, SKIP ESAC, 
  tas:= M d3 OF str D M M d4 OF str; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M d3 OF str D M M d4 OF str, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M d3 OF str D M M d4 OF str, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M d3 OF str D M M d4 OF str, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M d3 OF str D M M d4 OF str); 
   UNION (R, CHAR) union := pr(proc, 
   M d3 OF str D M M d4 OF str, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M d3 OF str D M M d4 OF str END), 
  ?=:= (union; 1= (M d3 OF str D M M d4 OF str)
   |  M d3 OF str D M M d4 OF str), 
   M d3 OF str D M M d4 OF str, 
  test((BOOL bool= FALSE; union | (R) :
   M d3 OF str D M M d4 OF str, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 4; ctrloc:=ctr; 
  test(M t[, c][2] D M M t[, d][2]); 
   FOR ident FROM M t[, c][2] D M M t[, d][2]
   BY M t[, c][2] D M M t[, d][2]
   TO M t[, c][2] D M M t[, d][2]
   WHILE  1= (M t[, c][2] D M M t[, d][2])
   DO  [ M t[, c][2] D M M t[, d][2] : 4, 
  -1 :  M t[, c][2] D M M t[, d][2]]  R ent; 
  ent [ M t[, c][2] D M M t[, d][2], 0 ] :=
  ent[ 1, M t[, c][2] D M M t[, d][2]] :=
   M t[, c][2] D M M t[, d][2]; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M t[, c][2] D M M t[, d][2]); 
   REAL pi = .12345;  M t[, c][2] D M M t[, d][2]); 
  test(par); 
  alfa:=?=:= (M t[, c][2] D M M t[, d][2]); 
   R ident = M t[, c][2] D M M t[, d][2], 
   R loc:= CASE M t[, c][2] D M M t[, d][2]  IN 
   M t[, c][2] D M M t[, d][2], SKIP ESAC, 
  tas:= M t[, c][2] D M M t[, d][2]; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M t[, c][2] D M M t[, d][2], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M t[, c][2] D M M t[, d][2], (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M t[, c][2] D M M t[, d][2], proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M t[, c][2] D M M t[, d][2]); 
   UNION (R, CHAR) union := pr(proc, 
   M t[, c][2] D M M t[, d][2], proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M t[, c][2] D M M t[, d][2] END), 
  ?=:= (union; 1= (M t[, c][2] D M M t[, d][2])
   |  M t[, c][2] D M M t[, d][2]), 
   M t[, c][2] D M M t[, d][2], 
  test((BOOL bool= FALSE; union | (R) :
   M t[, c][2] D M M t[, d][2], 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 5; ctrloc:=ctr; 
  test(M call(3) D M M call(4)); 
   FOR ident FROM M call(3) D M M call(4)
   BY M call(3) D M M call(4)
   TO M call(3) D M M call(4)
   WHILE  1= (M call(3) D M M call(4))
   DO  [ M call(3) D M M call(4) : 4, 
  -1 :  M call(3) D M M call(4)]  R ent; 
  ent [ M call(3) D M M call(4), 0 ] :=
  ent[ 1, M call(3) D M M call(4)] :=
   M call(3) D M M call(4); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M call(3) D M M call(4)); 
   REAL pi = .12345;  M call(3) D M M call(4)); 
  test(par); 
  alfa:=?=:= (M call(3) D M M call(4)); 
   R ident = M call(3) D M M call(4), 
   R loc:= CASE M call(3) D M M call(4)  IN 
   M call(3) D M M call(4), SKIP ESAC, 
  tas:= M call(3) D M M call(4); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M call(3) D M M call(4), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M call(3) D M M call(4), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M call(3) D M M call(4), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M call(3) D M M call(4)); 
   UNION (R, CHAR) union := pr(proc, 
   M call(3) D M M call(4), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M call(3) D M M call(4) END), 
  ?=:= (union; 1= (M call(3) D M M call(4))
   |  M call(3) D M M call(4)), 
   M call(3) D M M call(4), 
  test((BOOL bool= FALSE; union | (R) :
   M call(3) D M M call(4), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 6; ctrloc:=ctr; 
  test(M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI); 
   FOR ident FROM M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   BY M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   TO M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   WHILE  1= (M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)
   DO  [ M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI : 4, 
  -1 :  M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI ]  R ent; 
  ent [ M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, 0 ] :=
  ent[ 1, M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI ] :=
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI; 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI; 
   REAL pi = .12345;  M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI); 
  test(par); 
  alfa:=?=:= (M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI); 
   R ident = M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, 
   R loc:= CASE M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI IN 
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, SKIP ESAC, 
  tas:= M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI); 
   UNION (R, CHAR) union := pr(proc, 
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI END), 
  ?=:= (union; 1= (M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)
   |  M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI), 
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, 
  test((BOOL bool= FALSE; union | (R) :
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 7; ctrloc:=ctr; 
  test(M (INT x:=c; x) D M M (INT x:=d; x)); 
   FOR ident FROM M (INT x:=c; x) D M M (INT x:=d; x)
   BY M (INT x:=c; x) D M M (INT x:=d; x)
   TO M (INT x:=c; x) D M M (INT x:=d; x)
   WHILE  1= (M (INT x:=c; x) D M M (INT x:=d; x))
   DO  [ M (INT x:=c; x) D M M (INT x:=d; x) : 4, 
  -1 :  M (INT x:=c; x) D M M (INT x:=d; x)]  R ent; 
  ent [ M (INT x:=c; x) D M M (INT x:=d; x), 0 ] :=
  ent[ 1, M (INT x:=c; x) D M M (INT x:=d; x)] :=
   M (INT x:=c; x) D M M (INT x:=d; x); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; VOID (M (INT x:=c; x) D M M (INT x:=d; x)); 
   REAL pi = .12345;  M (INT x:=c; x) D M M (INT x:=d; x)); 
  test(par); 
  alfa:=?=:= (M (INT x:=c; x) D M M (INT x:=d; x)); 
   R ident = M (INT x:=c; x) D M M (INT x:=d; x), 
   R loc:= CASE M (INT x:=c; x) D M M (INT x:=d; x)  IN 
   M (INT x:=c; x) D M M (INT x:=d; x), SKIP ESAC, 
  tas:= M (INT x:=c; x) D M M (INT x:=d; x); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M (INT x:=c; x) D M M (INT x:=d; x), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M (INT x:=c; x) D M M (INT x:=d; x), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M (INT x:=c; x) D M M (INT x:=d; x), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M (INT x:=c; x) D M M (INT x:=d; x)); 
   UNION (R, CHAR) union := pr(proc, 
   M (INT x:=c; x) D M M (INT x:=d; x), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M (INT x:=c; x) D M M (INT x:=d; x) END), 
  ?=:= (union; 1= (M (INT x:=c; x) D M M (INT x:=d; x))
   |  M (INT x:=c; x) D M M (INT x:=d; x)), 
   M (INT x:=c; x) D M M (INT x:=d; x), 
  test((BOOL bool= FALSE; union | (R) :
   M (INT x:=c; x) D M M (INT x:=d; x), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  (ctrt:= 8; ctrloc:=ctr; 
  test(M ("#" & (TRUE  &
   3)) D M M ("#" & (TRUE  &
  d))); 
   FOR ident FROM M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
  t[, d][2]))
   BY M ("#" & (TRUE  &
  t[, c][2])) D M M ("#" & (TRUE  &
  d4 OF str))
   TO M ("#" & (TRUE  &
   3)) D M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  d))))
   WHILE  1= (M ("#" & (TRUE  &
  (INT x:=c; x))) D M M ("#" & (TRUE  &
   4)))
   DO  [ M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
  d)) : 4, 
  -1 :  M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
  d4 OF str))]  R ent; 
  ent [ M ("#" & (TRUE  &
  t[, c][2])) D M M ("#" & (TRUE  &
  call(4))), 0 ] :=
  ent[ 1, M ("#" & (TRUE  &
  c)) D M M ("#" & (TRUE  &
  (INT x:=d; x)))] :=
   M ("#" & (TRUE  &
  (INT x:=c; x))) D M M ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
  call(4))); 
   REAL pi = .12345;  M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
  call(4)))); 
  test(par); 
  alfa:=?=:= (M ("#" & (TRUE  &
  d3 OF str)) D M M ("#" & (TRUE  &
  d4 OF str))); 
   R ident = M ("#" & (TRUE  &
  d3 OF str)) D M M ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)), 
   R loc:= CASE M ("#" & (TRUE  &
  ("#" & (TRUE  &
  d3 OF str)))) D M M ("#" & (TRUE  &
  t[, d][2]))  IN 
   M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)), SKIP ESAC, 
  tas:= M ("#" & (TRUE  &
   3)) D M M ("#" & (TRUE  &
  (INT x:=d; x))); 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M ("#" & (TRUE  &
  (INT x:=c; x))) D M M ("#" & (TRUE  &
  t[, d][2])), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
  t[, d][2])), (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
  t[, d][2])), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M ("#" & (TRUE  &
  c)) D M M ("#" & (TRUE  &
  (INT x:=d; x)))); 
   UNION (R, CHAR) union := pr(proc, 
   M ("#" & (TRUE  &
  (INT x:=c; x))) D M M ("#" & (TRUE  &
  (INT x:=d; x))), proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M ("#" & (TRUE  &
  (INT x:=c; x))) D M M ("#" & (TRUE  &
  d)) END), 
  ?=:= (union; 1= (M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
  call(4))))
   |  M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI))), 
   M ("#" & (TRUE  &
  t[, c][2])) D M M ("#" & (TRUE  &
  t[, d][2])), 
  test((BOOL bool= FALSE; union | (R) :
   M ("#" & (TRUE  &
  c)) D M M ("#" & (TRUE  &
  d)), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*4)); 
  
  # nombre de operateurs : 15 #
  
  (ctrt:= 9; ctrloc:=ctr; 
  test(t[, b][2] A M call(5)
   C t[, f][2] E M M ("#" & (TRUE  &
  t[, j][2])) G d0 OF str
   I call(0) H i F M M i
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M t[, d][2]); 
   FOR ident FROM t[, b][2] A M  5
   C (INT x:=f; x) E M M d0 OF str G j
   I d0 OF str H d9 OF str F M M t[, i][2]
   D d5 OF str B M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   BY  ("#" & (TRUE  &
  (INT x:=b; x))) A M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI 
   C t[, f][2] E M M j G j
   I 10 H  9 F M M d9 OF str
   D e B M  4
   TO d2 OF str A M (INT x:=e; x)
   C call(6) E M M d0 OF str G PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI 
   I j H (INT x:=i; x) F M M d9 OF str
   D call(5) B M  4
   WHILE  1= (d2 OF str A M t[, e][2]
   C call(6) E M M ("#" & (TRUE  &
  t[, j][2])) G call(0)
   I PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI H  9 F M M d9 OF str
   D ("#" & (TRUE  &
  e)) B M t[, d][2])
   DO  [("#" & (TRUE  &
  b)) A M (INT x:=e; x)
   C ("#" & (TRUE  &
   PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI)) E M M d0 OF str G ("#" & (TRUE  &
  d0 OF str))
   I 10 H (INT x:=i; x) F M M t[, i][2]
   D (INT x:=e; x) B M d : 4, 
  -1 : call(2) A M call(5)
   C call(6) E M M 10 G t[, j][2]
   I t[, j][2] H PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI F M M call(9)
   D t[, e][2] B M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI ]  R ent; 
  ent [b A M e
   C d6 OF str E M M call(0) G j
   I (INT x:=j; x) H d9 OF str F M M d9 OF str
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M call(4), 0 ] :=
  ent[ 1, t[, b][2] A M t[, e][2]
   C call(6) E M M ("#" & (TRUE  &
  10)) G t[, j][2]
   I j H  9 F M M ("#" & (TRUE  &
  d9 OF str))
   D ("#" & (TRUE  &
  d5 OF str)) B M d] :=
  b A M  5
   C ("#" & (TRUE  &
  d6 OF str)) E M M PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI G j
   I (INT x:=j; x) H i F M M  9
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M ("#" & (TRUE  &
   4)); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; ("#" & (TRUE  &
  b)) A M (INT x:=e; x)
   C ("#" & (TRUE  &
  t[, f][2])) E M M (INT x:=j; x) G PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI 
   I d0 OF str H i F M M t[, i][2]
   D e B M t[, d][2]; 
   REAL pi = .12345; b A M call(5)
   C f E M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  d0 OF str)))) G j
   I 10 H  9 F M M d9 OF str
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M d4 OF str); 
  test(par); 
  alfa:=?=:= (2 A M ("#" & (TRUE  &
  ("#" & (TRUE  &
  (INT x:=e; x)))))
   C d6 OF str E M M call(0) G ("#" & (TRUE  &
  d0 OF str))
   I call(0) H  9 F M M t[, i][2]
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI))); 
   R ident = PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI A M d5 OF str
   C ("#" & (TRUE  &
   6)) E M M d0 OF str G call(0)
   I ("#" & (TRUE  &
   PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI)) H PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI F M M PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI 
   D  5 B M d, 
   R loc:= CASE  (INT x:=b; x) A M e
   C d6 OF str E M M call(0) G j
   I call(0) H PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI F M M d9 OF str
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M (INT x:=d; x)  IN 
  ("#" & (TRUE  &
  t[, b][2])) A M call(5)
   C call(6) E M M d0 OF str G PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI 
   I t[, j][2] H ("#" & (TRUE  &
   9)) F M M  9
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M ("#" & (TRUE  &
  (INT x:=d; x))), SKIP ESAC, 
  tas:= PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI A M call(5)
   C f E M M 10 G (INT x:=j; x)
   I call(0) H t[, i][2] F M M  9
   D d5 OF str B M (INT x:=d; x); 
  test(ident); test(loc); test(tas); 
   PROC proc = R : b A M call(5)
   C  6 E M M call(0) G d0 OF str
   I d0 OF str H t[, i][2] F M M i
   D ("#" & (TRUE  &
   PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI)) B M ("#" & (TRUE  &
  d4 OF str)), 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (call(2) A M t[, e][2]
   C  6 E M M j G d0 OF str
   I t[, j][2] H t[, i][2] F M M d9 OF str
   D e B M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   2 A M e
   C  6 E M M t[, j][2] G ("#" & (TRUE  &
  j))
   I PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI H t[, i][2] F M M t[, i][2]
   D t[, e][2] B M call(4), proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); d2 OF str A M (INT x:=e; x)
   C (INT x:=f; x) E M M 10 G d0 OF str
   I 10 H t[, i][2] F M M i
   D d5 OF str B M call(4)); 
   UNION (R, CHAR) union := pr(proc, 
  (INT x:=b; x) A M call(5)
   C (INT x:=f; x) E M M call(0) G call(0)
   I PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI H t[, i][2] F M M t[, i][2]
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M d4 OF str, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN PROC INT IF 2= 0  THEN 
   INT :10  ELSE INT :2 FI A M  5
   C PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI E M M call(0) G (INT x:=j; x)
   I 10 H PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI F M M i
   D (INT x:=e; x) B M ("#" & (TRUE  &
  d)) END), 
  ?=:= (union; 1= (call(2) A M ("#" & (TRUE  &
  d5 OF str))
   C d6 OF str E M M (INT x:=j; x) G t[, j][2]
   I (INT x:=j; x) H t[, i][2] F M M ("#" & (TRUE  &
  call(9)))
   D call(5) B M t[, d][2])
   |  2 A M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI 
   C (INT x:=f; x) E M M 10 G d0 OF str
   I (INT x:=j; x) H ("#" & (TRUE  &
  call(9))) F M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  t[, i][2]))))
   D  5 B M d4 OF str), 
   2 A M call(5)
   C (INT x:=f; x) E M M j G (INT x:=j; x)
   I j H d9 OF str F M M call(9)
   D e B M call(4), 
  test((BOOL bool= FALSE; union | (R) :
  b A M (INT x:=e; x)
   C d6 OF str E M M d0 OF str G t[, j][2]
   I ("#" & (TRUE  &
  t[, j][2])) H ("#" & (TRUE  &
   9)) F M M (INT x:=i; x)
   D e B M (INT x:=d; x), 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*15)); 
  
  # nombre de operateurs : 14 #
  
  (ctrt:= 10; ctrloc:=ctr; 
  test(M (INT x:=h; x) H call(7)
   E M  7 E e C M M  6
   C (INT x:=c; x) C PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI E d4 OF str
   E M  5 H (INT x:=d; x)); 
   FOR ident FROM M h H g
   E M t[, g][2] E e C M M d6 OF str
   C d3 OF str C (INT x:=d; x) E  4
   E M (INT x:=e; x) H call(4)
   BY M (INT x:=h; x) H t[, g][2]
   E M PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI E ("#" & (TRUE  &
   PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI)) C M M d6 OF str
   C (INT x:=c; x) C call(4) E d
   E M ("#" & (TRUE  &
   PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI)) H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   TO M d8 OF str H t[, g][2]
   E M ("#" & (TRUE  &
  (INT x:=g; x))) E d5 OF str C M M f
   C d3 OF str C d E (INT x:=d; x)
   E M call(5) H  4
   WHILE  1= (M ("#" & (TRUE  &
   PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI)) H (INT x:=g; x)
   E M ("#" & (TRUE  &
  g)) E ("#" & (TRUE  &
  e)) C M M d6 OF str
   C (INT x:=c; x) C call(4) E (INT x:=d; x)
   E M t[, e][2] H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)
   DO  [ M h H g
   E M (INT x:=g; x) E  5 C M M (INT x:=f; x)
   C ("#" & (TRUE  &
  t[, c][2])) C d E PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   E M  5 H d4 OF str : 4, 
  -1 :  M call(8) H PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI 
   E M call(7) E  5 C M M ("#" & (TRUE  &
  d6 OF str))
   C ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) C ("#" & (TRUE  &
  call(4))) E d
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI ]  R ent; 
  ent [ M PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI H g
   E M (INT x:=g; x) E d5 OF str C M M  6
   C (INT x:=c; x) C t[, d][2] E call(4)
   E M call(5) H d4 OF str, 0 ] :=
  ent[ 1, M d8 OF str H  7
   E M call(7) E t[, e][2] C M M (INT x:=f; x)
   C  3 C PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI E (INT x:=d; x)
   E M (INT x:=e; x) H (INT x:=d; x)] :=
   M ("#" & (TRUE  &
   PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI)) H d7 OF str
   E M call(7) E (INT x:=e; x) C M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI 
   C d3 OF str C d E  4
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H call(4); 
  test(ent[1, 0]); test(ent[1, 1])  OD; 
   R alfa, R par = (SKIP; M h H call(7)
   E M (INT x:=g; x) E ("#" & (TRUE  &
  (INT x:=e; x))) C M M t[, f][2]
   C  3 C call(4) E d4 OF str
   E M ("#" & (TRUE  &
  call(5))) H call(4); 
   REAL pi = .12345;  M call(8) H call(7)
   E M call(7) E d5 OF str C M M PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI 
   C PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI C call(4) E call(4)
   E M (INT x:=e; x) H (INT x:=d; x)); 
  test(par); 
  alfa:=?=:= (M (INT x:=h; x) H PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI 
   E M call(7) E e C M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  d6 OF str))))
   C call(3) C  4 E d4 OF str
   E M  5 H t[, d][2]); 
   R ident = M (INT x:=h; x) H call(7)
   E M ("#" & (TRUE  &
   PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI)) E d5 OF str C M M (INT x:=f; x)
   C t[, c][2] C d E d4 OF str
   E M (INT x:=e; x) H ("#" & (TRUE  &
  call(4))), 
   R loc:= CASE M PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI H call(7)
   E M d7 OF str E t[, e][2] C M M d6 OF str
   C t[, c][2] C PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI E t[, d][2]
   E M t[, e][2] H t[, d][2]  IN 
   M t[, h][2] H  7
   E M g E ("#" & (TRUE  &
  (INT x:=e; x))) C M M f
   C t[, c][2] C  4 E PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   E M d5 OF str H call(4), SKIP ESAC, 
  tas:= M ("#" & (TRUE  &
  d8 OF str)) H g
   E M call(7) E e C M M call(6)
   C d3 OF str C  4 E d
   E M  5 H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI; 
  test(ident); test(loc); test(tas); 
   PROC proc = R :  M d8 OF str H (INT x:=g; x)
   E M g E t[, e][2] C M M call(6)
   C t[, c][2] C d E d4 OF str
   E M  5 H t[, d][2], 
   STRUCT (COMPL of, STRUCT (R de, COMPL of)de) struct
  := ((.11, 0), (M t[, h][2] H t[, g][2]
   E M  7 E t[, e][2] C M M  6
   C t[, c][2] C ("#" & (TRUE  &
  ("#" & (TRUE  &
  ("#" & (TRUE  &
   4)))))) E call(4)
   E M  5 H  4, (0, 1e0))); 
  test(de OF de OF struct); 
  [] R apd = (ident, par, loc, 
   M (INT x:=h; x) H t[, g][2]
   E M  7 E call(5) C M M t[, f][2]
   C PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI C d E PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   E M  5 H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI, proc, tas, de OF de OF struct); 
  test(apd[4]); test(apd[5]); 
   PROC pr:= (R rep, reprep, PROC R procrep) R : (
  test(rep); test(reprep); M  8 H  7
   E M call(7) E ("#" & (TRUE  &
   PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI)) C M M f
   C (INT x:=c; x) C (INT x:=d; x) E d
   E M ("#" & (TRUE  &
  ("#" & (TRUE  &
  call(5))))) H ("#" & (TRUE  &
  d))); 
   UNION (R, CHAR) union := pr(proc, 
   M d8 OF str H d7 OF str
   E M g E call(5) C M M call(6)
   C PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI C (INT x:=d; x) E t[, d][2]
   E M ("#" & (TRUE  &
  call(5))) H d4 OF str, proc); 
  test((union | (R a) : a)); 
  (test(R BEGIN M PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI H PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI 
   E M t[, g][2] E ("#" & (TRUE  &
  e)) C M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  (INT x:=f; x)))))
   C PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI C t[, d][2] E t[, d][2]
   E M d5 OF str H ("#" & (TRUE  &
   PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)) END), 
  ?=:= (union; 1= (M d8 OF str H call(7)
   E M t[, g][2] E call(5) C M M f
   C (INT x:=c; x) C  4 E PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   E M t[, e][2] H  4)
   |  M h H g
   E M  7 E PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI C M M f
   C ("#" & (TRUE  &
  (INT x:=c; x))) C t[, d][2] E call(4)
   E M  5 H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI), 
   M  8 H  7
   E M g E (INT x:=e; x) C M M (INT x:=f; x)
   C PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI C  4 E call(4)
   E M t[, e][2] H ("#" & (TRUE  &
  d4 OF str)), 
  test((BOOL bool= FALSE; union | (R) :
   M ("#" & (TRUE  &
  h)) H  7
   E M d7 OF str E call(5) C M M call(6)
   C call(3) C PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI E PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI 
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H d4 OF str, 
  (CHAR car) :  SKIP))); 
  ctrl(17+28*14)); 
   SKIP); 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r542c #
  (print((newline, "Dyadic formulas: ")); 
   INT vf = 10+5*(4*8+15+14); 
   INT ctrt:= 0, ctr:= 0, ctrloc; 
   PROC ctrl = (INT inc) VOID : (ctr/=ctrloc+inc | 
      print(("count er in test", ctrt, ctr, ctrloc+inc, newline))); 
   MODE R = INT; 
   PROC test = (INT a) VOID : (a= 1 | ctr+:= 1
   | print(("er", ctrt, ctr-ctrloc, newline))); 
   OP  ?=:= = (INT x) INT : (test(x); x); 
  
   INT b= 2, c= 3, d= 4, e= 5, f= 6, g= 7, h= 8, i= 9, j= 10; 
   STRUCT (INT d2, d3, d4, d5, d6, d7, d8, d9, d0) str =
      (2, 3, 4, 5, 6, 7, 8, 9, 10); 
  [, ] INT t= ((0, b, c, d, e, f, g, h, i, j), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)), 
   PROC call = (INT a) INT : (a= 0 | 10 | a), 
   OP  & = (BOOL a, INT b) STRUCT (INT a, b) : (b, 0), 
      & = (CHAR a, STRUCT (INT a, b) b) INT : a OF b; 
   PRIO  & = 3; 
   PRIO A = 1, B = 2, C = 3, D = 4, E = 5, F = 6, G = 7, H = 8, I = 9; 
  
   PROC dyad = (INT a, b) INT : ((a=b | ctr+:= 1 | 
      print(("er.prio", ctrt, ctr-ctrloc, a, b, newline))); a-1); 
  
  # contextes demandant un mode : rep #
  
  (OP M = (INT a) REF INT :  HEAP INT := (ctr+:= 1; a-1); 
   PROC rep = (INT a, b) REF INT :  HEAP INT :=dyad(a, b); 
   OP (INT, INT) REF INT A =rep, B =rep, C =rep, D =rep, E =rep, 
       F =rep, G =rep, H =rep, I =rep; 
  
  # nombre de operateurs : 4 #
  ctrt:= 11; ctrloc:=ctr; 
  test(M  3 D M M  4:=
   M  3 D M M  4:=
  (M  3 D M M  4:/=:
   M  3 D M M  4 | 
   M  3 D M M  4)); 
  ctrl(1+5*4); 
  ctrt:= 12; ctrloc:=ctr; 
  test(M c D M M d:=
   M c D M M d:=
  (M c D M M d:/=:
   M c D M M d | 
   M c D M M d)); 
  ctrl(1+5*4); 
  ctrt:= 13; ctrloc:=ctr; 
  test(M d3 OF str D M M d4 OF str:=
   M d3 OF str D M M d4 OF str:=
  (M d3 OF str D M M d4 OF str:/=:
   M d3 OF str D M M d4 OF str | 
   M d3 OF str D M M d4 OF str)); 
  ctrl(1+5*4); 
  ctrt:= 14; ctrloc:=ctr; 
  test(M t[, c][2] D M M t[, d][2]:=
   M t[, c][2] D M M t[, d][2]:=
  (M t[, c][2] D M M t[, d][2]:/=:
   M t[, c][2] D M M t[, d][2] | 
   M t[, c][2] D M M t[, d][2])); 
  ctrl(1+5*4); 
  ctrt:= 15; ctrloc:=ctr; 
  test(M call(3) D M M call(4):=
   M call(3) D M M call(4):=
  (M call(3) D M M call(4):/=:
   M call(3) D M M call(4) | 
   M call(3) D M M call(4))); 
  ctrl(1+5*4); 
  ctrt:= 16; ctrloc:=ctr; 
  test(M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI :=
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI :=
  (M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI :/=:
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI  | 
   M PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI D M M PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI)); 
  ctrl(1+5*4); 
  ctrt:= 17; ctrloc:=ctr; 
  test(M (INT x:=c; x) D M M (INT x:=d; x):=
   M (INT x:=c; x) D M M (INT x:=d; x):=
  (M (INT x:=c; x) D M M (INT x:=d; x):/=:
   M (INT x:=c; x) D M M (INT x:=d; x) | 
   M (INT x:=c; x) D M M (INT x:=d; x))); 
  ctrl(1+5*4); 
  ctrt:= 18; ctrloc:=ctr; 
  test(M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
  d4 OF str)):=
   M ("#" & (TRUE  &
   PROC INT IF 3= 0  THEN 
   INT :10  ELSE INT :3 FI)) D M M ("#" & (TRUE  &
   4)):=
  (M ("#" & (TRUE  &
  d3 OF str)) D M M ("#" & (TRUE  &
  (INT x:=d; x))):/=:
   M ("#" & (TRUE  &
  call(3))) D M M ("#" & (TRUE  &
  ("#" & (TRUE  &
  d4 OF str)))) | 
   M ("#" & (TRUE  &
  t[, c][2])) D M M ("#" & (TRUE  &
  d)))); 
  ctrl(1+5*4); 
  
  # nombre de operateurs : 15 #
  ctrt:= 19; ctrloc:=ctr; 
  test(call(2) A M t[, e][2]
   C  6 E M M 10 G j
   I j H (INT x:=i; x) F M M call(9)
   D e B M call(4):=
  ("#" & (TRUE  &
  (INT x:=b; x))) A M  5
   C d6 OF str E M M call(0) G call(0)
   I d0 OF str H i F M M PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI 
   D call(5) B M d:=
  (call(2) A M e
   C f E M M PROC INT IF 0= 0  THEN 
   INT :10  ELSE INT :0 FI G j
   I ("#" & (TRUE  &
  j)) H d9 OF str F M M i
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M call(4):/=:
  t[, b][2] A M (INT x:=e; x)
   C ("#" & (TRUE  &
  d6 OF str)) E M M t[, j][2] G ("#" & (TRUE  &
  j))
   I (INT x:=j; x) H (INT x:=i; x) F M M ("#" & (TRUE  &
  t[, i][2]))
   D PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI B M (INT x:=d; x) | 
  call(2) A M call(5)
   C PROC INT IF 6= 0  THEN 
   INT :10  ELSE INT :6 FI E M M call(0) G t[, j][2]
   I 10 H  9 F M M PROC INT IF 9= 0  THEN 
   INT :10  ELSE INT :9 FI 
   D (INT x:=e; x) B M (INT x:=d; x))); 
  ctrl(1+5*15); 
  
  # nombre de operateurs : 14 #
  ctrt:= 20; ctrloc:=ctr; 
  test(M PROC INT IF 8= 0  THEN 
   INT :10  ELSE INT :8 FI H g
   E M t[, g][2] E t[, e][2] C M M (INT x:=f; x)
   C (INT x:=c; x) C PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI E ("#" & (TRUE  &
   4))
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H ("#" & (TRUE  &
  d)):=
   M t[, h][2] H t[, g][2]
   E M g E ("#" & (TRUE  &
   PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI)) C M M d6 OF str
   C call(3) C d E t[, d][2]
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H d4 OF str:=
  (M h H d7 OF str
   E M call(7) E call(5) C M M d6 OF str
   C call(3) C ("#" & (TRUE  &
   4)) E call(4)
   E M t[, e][2] H  4:/=:
   M d8 OF str H d7 OF str
   E M PROC INT IF 7= 0  THEN 
   INT :10  ELSE INT :7 FI E call(5) C M M PROC INT IF 6
  = 0  THEN 
   INT :10  ELSE INT :6 FI 
   C  3 C d4 OF str E (INT x:=d; x)
   E M ("#" & (TRUE  &
  t[, e][2])) H PROC INT IF 4= 0  THEN 
   INT :10  ELSE INT :4 FI  | 
   M ("#" & (TRUE  &
  d8 OF str)) H (INT x:=g; x)
   E M call(7) E t[, e][2] C M M (INT x:=f; x)
   C c C d4 OF str E t[, d][2]
   E M PROC INT IF 5= 0  THEN 
   INT :10  ELSE INT :5 FI H d4 OF str)); 
  ctrl(1+5*14); 
   SKIP); 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r6b #
  (print((newline, "Coercions in firm context: ")); 
   INT vf = 800; 
   INT ctrt:= 0, ctr:= 0, ctrloc:= 0; 
   BOOL bascule:= TRUE, b, 
   PROC controle = VOID :  IF b AND ctr=ctrloc+15  THEN ctr+:= 5
   ELSE print(("er. in test", ctrt, ctr, ctrloc+15, newline)) FI; 
   PROC tilt = VOID : print(("er.op", ctrt, ctr-ctrloc, newline)); 
  
   UNION (INT, REAL) vu = 1e0, 
   MODE SB = STRUCT (BOOL ch, of), 
      UBE = UNION (BOOL, INT), 
   PRIO BOLD = 2, -==:= 1; 
  
  # mode a posteriori : [, ] BOOL  #
   OP  -==: = ([, ] BOOL a) [, ] BOOL :
      (FALSE, FALSE, NOT (ctr+:= 1; a)[3, 1])
  , -==: = ([, ] BOOL a, b) [, ] BOOL :
      (a[3, 1] AND b[3, 1] | 
      ctr+:= 2; (FALSE, FALSE, TRUE 
  ) | tilt;  SKIP)
  , BOLD = ([, ] BOOL a, b) [, ] BOOL :
      (NOT a[3, 1] AND b[3, 1] | 
      ctr+:= 2; (FALSE, FALSE, bascule:= NOT bascule
  ) | tilt;  SKIP); 
  
  # mode a posteriori :  UNION (BITS, REAL, SB) #
   OP  -==: = (UNION (BITS, REAL, SB) a)  SB :
      (NOT ch OF (ctr+:= 1; a | (SB a):a), FALSE)
  , -==: = (UNION (BITS, REAL, SB) a, b)  SB :
      (((a | (SB a):ch OF a) AND (b | (SB b):ch OF b) | 
      ctr+:= 2; TRUE  | 
      tilt;  SKIP), FALSE)
  , BOLD = (UNION (BITS, REAL, SB) a, b)  SB :
      ((NOT (a | (SB a):ch OF a) AND (b | (SB b):ch OF b) | 
      ctr+:= 2; bascule:= NOT bascule | 
      tilt;  SKIP), FALSE); 
  
  # mode a posteriori :  UNION (UNION (COMPL, BOOL), 
   INT, UNION (INT, UBE)) #
   OP  -==: = (UNION (UNION (COMPL, BOOL), 
   INT, UNION (INT, UBE)) a)  BOOL :
      (ctr+:= 1; a | (BOOL a): NOT a)
  , -==: = (UNION (UNION (COMPL, BOOL), 
       INT, UNION (INT, UBE)) a, b)  BOOL :
      ((a | (BOOL a):a) AND (b | (BOOL b):b) | 
      ctr+:= 2; TRUE  | 
      tilt;  SKIP)
  , BOLD = (UNION (UNION (COMPL, BOOL), 
       INT, UNION (INT, UBE)) a, b)  BOOL :
      (NOT (a | (BOOL a):a) AND (b | (BOOL b):b) | 
      ctr+:= 2; bascule:= NOT bascule | 
      tilt;  SKIP); 
  
   BEGIN  # coercion sur mode :
   SB  #
       SB ident = (TRUE, FALSE); 
       STRUCT (INT a, SB ch)de = (0, ident), 
      [] SB rang = (SKIP, ident, SKIP), 
       PROC proc = (SB a)  SB : a; 
  
                               #contextes #
  ctrt:= 1; ctrloc:=ctr; 
    b:=ch OF (ident
    -==:ident
    -==:-==:ident BOLD 
      (-==:-==:ident-==:
        (ident-==:ident))
     BOLD ident
  ); controle; 
  ctrt:= 2; ctrloc:=ctr; 
    b:=ch OF (SB ((TRUE, FALSE))
    -==: SB ((TRUE, FALSE))
    -==:-==: SB ((TRUE, FALSE)) BOLD 
      (-==:-==: SB ((TRUE, FALSE))-==:
        (SB ((TRUE, FALSE))-==: SB ((TRUE, FALSE))))
     BOLD SB ((TRUE, FALSE))
  ); controle; 
  ctrt:= 3; ctrloc:=ctr; 
    b:=ch OF (ch OF de
    -==:ch OF de
    -==:-==:ch OF de BOLD 
      (-==:-==:ch OF de-==:
        (ch OF de-==:ch OF de))
     BOLD ch OF de
  ); controle; 
  ctrt:= 4; ctrloc:=ctr; 
    b:=ch OF (rang[2]
    -==:rang[2]
    -==:-==:rang[2] BOLD 
      (-==:-==:rang[2]-==:
        (rang[2]-==:rang[2]))
     BOLD rang[2]
  ); controle; 
  ctrt:= 5; ctrloc:=ctr; 
    b:=ch OF (proc(ident)
    -==:proc(ident)
    -==:-==:proc(ident) BOLD 
      (-==:-==:proc(ident)-==:
        (proc(ident)-==:proc(ident)))
     BOLD proc(ident)
  ); controle; 
  ctrt:= 6; ctrloc:=ctr; 
    b:=ch OF (IF FALSE THEN SKIP ELSE ident FI 
  
    -==: IF FALSE THEN SKIP ELSE ident FI 
  
    -==:-==: IF FALSE THEN SKIP ELSE ident FI 
     BOLD 
      (-==:-==: IF FALSE THEN SKIP ELSE ident FI 
      -==:
        (IF FALSE THEN SKIP ELSE ident FI 
        -==: IF FALSE THEN SKIP ELSE ident FI 
  ))
     BOLD IF FALSE THEN SKIP ELSE ident FI 
  
  ); controle; 
  ctrt:= 7; ctrloc:=ctr; 
    b:=ch OF (SB (1 | ident, SKIP)
  
    -==: SB (1 | ident, SKIP)
  
    -==:-==: SB (1 | ident, SKIP)
     BOLD 
      (-==:-==: SB (1 | ident, SKIP)
      -==:
        (SB (1 | ident, SKIP)
        -==: SB (1 | ident, SKIP)
  ))
     BOLD SB (1 | ident, SKIP)
  
  ); controle; 
  ctrt:= 8; ctrloc:=ctr; 
    b:=ch OF ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
     BOLD 
      (-==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
           EXIT ee: GOTO e)
      -==:
        ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
        -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
  ))
     BOLD (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
  ); controle; 
   SKIP END; 
  
   BEGIN  # coercion sur mode :
   BOOL  #
       BOOL ident = TRUE; 
       STRUCT (INT a, BOOL ch)de = (0, ident), 
      [] BOOL rang = (SKIP, ident, SKIP), 
       PROC proc = (BOOL a)  BOOL : a; 
  
                               #contextes #
  ctrt:= 9; ctrloc:=ctr; 
    b:=ident
    -==:ident
    -==:-==:ident BOLD 
      (-==:-==:ident-==:
        (ident-==:ident))
     BOLD ident
  ; controle; 
  ctrt:= 10; ctrloc:=ctr; 
    b:= BOOL (TRUE)
    -==: BOOL (TRUE)
    -==:-==: BOOL (TRUE) BOLD 
      (-==:-==: BOOL (TRUE)-==:
        (BOOL (TRUE)-==: BOOL (TRUE)))
     BOLD BOOL (TRUE)
  ; controle; 
  ctrt:= 11; ctrloc:=ctr; 
    b:=ch OF de
    -==:ch OF de
    -==:-==:ch OF de BOLD 
      (-==:-==:ch OF de-==:
        (ch OF de-==:ch OF de))
     BOLD ch OF de
  ; controle; 
  ctrt:= 12; ctrloc:=ctr; 
    b:=rang[2]
    -==:rang[2]
    -==:-==:rang[2] BOLD 
      (-==:-==:rang[2]-==:
        (rang[2]-==:rang[2]))
     BOLD rang[2]
  ; controle; 
  ctrt:= 13; ctrloc:=ctr; 
    b:=proc(ident)
    -==:proc(ident)
    -==:-==:proc(ident) BOLD 
      (-==:-==:proc(ident)-==:
        (proc(ident)-==:proc(ident)))
     BOLD proc(ident)
  ; controle; 
  ctrt:= 14; ctrloc:=ctr; 
    b:= IF FALSE THEN SKIP ELSE ident FI 
  
    -==: IF FALSE THEN SKIP ELSE ident FI 
  
    -==:-==: IF FALSE THEN SKIP ELSE ident FI 
     BOLD 
      (-==:-==: IF FALSE THEN SKIP ELSE ident FI 
      -==:
        (IF FALSE THEN SKIP ELSE ident FI 
        -==: IF FALSE THEN SKIP ELSE ident FI 
  ))
     BOLD IF FALSE THEN SKIP ELSE ident FI 
  
  ; controle; 
  ctrt:= 15; ctrloc:=ctr; 
    b:= BOOL (1 | ident, SKIP)
  
    -==: BOOL (1 | ident, SKIP)
  
    -==:-==: BOOL (1 | ident, SKIP)
     BOLD 
      (-==:-==: BOOL (1 | ident, SKIP)
      -==:
        (BOOL (1 | ident, SKIP)
        -==: BOOL (1 | ident, SKIP)
  ))
     BOLD BOOL (1 | ident, SKIP)
  
  ; controle; 
  ctrt:= 16; ctrloc:=ctr; 
    b:= (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
     BOLD 
      (-==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
           EXIT ee: GOTO e)
      -==:
        ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
        -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
  ))
     BOLD (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
  ; controle; 
   SKIP END; 
  
   BEGIN  # coercion sur mode :
   REF [, ] BOOL  #
       REF [, ] BOOL ident = HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE); 
       STRUCT (INT a, REF [, ] BOOL ch)de = (0, ident), 
      [] REF [, ] BOOL rang = (SKIP, ident, SKIP), 
       PROC proc = (REF [, ] BOOL a)  REF [, ] BOOL : a; 
  
                               #contextes #
  ctrt:= 17; ctrloc:=ctr; 
    b:= (ident
    -==:ident
    -==:-==:ident BOLD 
      (-==:-==:ident-==:
        (ident-==:ident))
     BOLD ident
  )[3, 1]; controle; 
  ctrt:= 18; ctrloc:=ctr; 
    b:= (REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))
    -==: REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))
    -==:-==: REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))
   BOLD 
      (-==:-==: REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE)
  )-==:
        (REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))-==:
   REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))))
     BOLD REF [, ] BOOL (HEAP [3, 1] BOOL := (FALSE, FALSE, TRUE))
  )[3, 1]; controle; 
  ctrt:= 19; ctrloc:=ctr; 
    b:= (ch OF de
    -==:ch OF de
    -==:-==:ch OF de BOLD 
      (-==:-==:ch OF de-==:
        (ch OF de-==:ch OF de))
     BOLD ch OF de
  )[3, 1]; controle; 
  ctrt:= 20; ctrloc:=ctr; 
    b:= (rang[2]
    -==:rang[2]
    -==:-==:rang[2] BOLD 
      (-==:-==:rang[2]-==:
        (rang[2]-==:rang[2]))
     BOLD rang[2]
  )[3, 1]; controle; 
  ctrt:= 21; ctrloc:=ctr; 
    b:= (proc(ident)
    -==:proc(ident)
    -==:-==:proc(ident) BOLD 
      (-==:-==:proc(ident)-==:
        (proc(ident)-==:proc(ident)))
     BOLD proc(ident)
  )[3, 1]; controle; 
  ctrt:= 22; ctrloc:=ctr; 
    b:= (IF FALSE THEN SKIP ELSE ident FI 
  
    -==: IF FALSE THEN SKIP ELSE ident FI 
  
    -==:-==: IF FALSE THEN SKIP ELSE ident FI 
     BOLD 
      (-==:-==: IF FALSE THEN SKIP ELSE ident FI 
      -==:
        (IF FALSE THEN SKIP ELSE ident FI 
        -==: IF FALSE THEN SKIP ELSE ident FI 
  ))
     BOLD IF FALSE THEN SKIP ELSE ident FI 
  
  )[3, 1]; controle; 
  ctrt:= 23; ctrloc:=ctr; 
    b:= (REF [, ] BOOL (1 | ident, SKIP)
  
    -==: REF [, ] BOOL (1 | ident, SKIP)
  
    -==:-==: REF [, ] BOOL (1 | ident, SKIP)
     BOLD 
      (-==:-==: REF [, ] BOOL (1 | ident, SKIP)
      -==:
        (REF [, ] BOOL (1 | ident, SKIP)
        -==: REF [, ] BOOL (1 | ident, SKIP)
  ))
     BOLD REF [, ] BOOL (1 | ident, SKIP)
  
  )[3, 1]; controle; 
  ctrt:= 24; ctrloc:=ctr; 
    b:= ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
     BOLD 
      (-==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
           EXIT ee: GOTO e)
      -==:
        ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
        -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
  ))
     BOLD (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
  )[3, 1]; controle; 
   SKIP END; 
  
   BEGIN  # coercion sur mode :
   REF SB  #
       REF SB ident = HEAP SB := (TRUE, FALSE); 
       STRUCT (INT a, REF SB ch)de = (0, ident), 
      [] REF SB rang = (SKIP, ident, SKIP), 
       PROC proc = (REF SB a)  REF SB : a; 
  
                               #contextes #
  ctrt:= 25; ctrloc:=ctr; 
    b:=ch OF (ident
    -==:ident
    -==:-==:ident BOLD 
      (-==:-==:ident-==:
        (ident-==:ident))
     BOLD ident
  ); controle; 
  ctrt:= 26; ctrloc:=ctr; 
    b:=ch OF (REF SB (HEAP SB := (TRUE, FALSE))
    -==: REF SB (HEAP SB := (TRUE, FALSE))
    -==:-==: REF SB (HEAP SB := (TRUE, FALSE)) BOLD 
      (-==:-==: REF SB (HEAP SB := (TRUE, FALSE))-==:
        (REF SB (HEAP SB := (TRUE, FALSE))-==: REF SB (HEAP SB :=
  (TRUE, FALSE))))
     BOLD REF SB (HEAP SB := (TRUE, FALSE))
  ); controle; 
  ctrt:= 27; ctrloc:=ctr; 
    b:=ch OF (ch OF de
    -==:ch OF de
    -==:-==:ch OF de BOLD 
      (-==:-==:ch OF de-==:
        (ch OF de-==:ch OF de))
     BOLD ch OF de
  ); controle; 
  ctrt:= 28; ctrloc:=ctr; 
    b:=ch OF (rang[2]
    -==:rang[2]
    -==:-==:rang[2] BOLD 
      (-==:-==:rang[2]-==:
        (rang[2]-==:rang[2]))
     BOLD rang[2]
  ); controle; 
  ctrt:= 29; ctrloc:=ctr; 
    b:=ch OF (proc(ident)
    -==:proc(ident)
    -==:-==:proc(ident) BOLD 
      (-==:-==:proc(ident)-==:
        (proc(ident)-==:proc(ident)))
     BOLD proc(ident)
  ); controle; 
  ctrt:= 30; ctrloc:=ctr; 
    b:=ch OF (IF FALSE THEN SKIP ELSE ident FI 
  
    -==: IF FALSE THEN SKIP ELSE ident FI 
  
    -==:-==: IF FALSE THEN SKIP ELSE ident FI 
     BOLD 
      (-==:-==: IF FALSE THEN SKIP ELSE ident FI 
      -==:
        (IF FALSE THEN SKIP ELSE ident FI 
        -==: IF FALSE THEN SKIP ELSE ident FI 
  ))
     BOLD IF FALSE THEN SKIP ELSE ident FI 
  
  ); controle; 
  ctrt:= 31; ctrloc:=ctr; 
    b:=ch OF (REF SB (1 | ident, SKIP)
  
    -==: REF SB (1 | ident, SKIP)
  
    -==:-==: REF SB (1 | ident, SKIP)
     BOLD 
      (-==:-==: REF SB (1 | ident, SKIP)
      -==:
        (REF SB (1 | ident, SKIP)
        -==: REF SB (1 | ident, SKIP)
  ))
     BOLD REF SB (1 | ident, SKIP)
  
  ); controle; 
  ctrt:= 32; ctrloc:=ctr; 
    b:=ch OF ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
     BOLD 
      (-==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
           EXIT ee: GOTO e)
      -==:
        ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
        -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
  ))
     BOLD (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
  ); controle; 
   SKIP END; 
  
   BEGIN  # coercion sur mode :
   REF BOOL  #
       REF BOOL ident = HEAP BOOL := TRUE; 
       STRUCT (INT a, REF BOOL ch)de = (0, ident), 
      [] REF BOOL rang = (SKIP, ident, SKIP), 
       PROC proc = (REF BOOL a)  REF BOOL : a; 
  
                               #contextes #
  ctrt:= 33; ctrloc:=ctr; 
    b:=ident
    -==:ident
    -==:-==:ident BOLD 
      (-==:-==:ident-==:
        (ident-==:ident))
     BOLD ident
  ; controle; 
  ctrt:= 34; ctrloc:=ctr; 
    b:= REF BOOL (HEAP BOOL := TRUE)
    -==: REF BOOL (HEAP BOOL := TRUE)
    -==:-==: REF BOOL (HEAP BOOL := TRUE) BOLD 
      (-==:-==: REF BOOL (HEAP BOOL := TRUE)-==:
        (REF BOOL (HEAP BOOL := TRUE)-==: REF BOOL (HEAP BOOL :=
   TRUE)))
     BOLD REF BOOL (HEAP BOOL := TRUE)
  ; controle; 
  ctrt:= 35; ctrloc:=ctr; 
    b:=ch OF de
    -==:ch OF de
    -==:-==:ch OF de BOLD 
      (-==:-==:ch OF de-==:
        (ch OF de-==:ch OF de))
     BOLD ch OF de
  ; controle; 
  ctrt:= 36; ctrloc:=ctr; 
    b:=rang[2]
    -==:rang[2]
    -==:-==:rang[2] BOLD 
      (-==:-==:rang[2]-==:
        (rang[2]-==:rang[2]))
     BOLD rang[2]
  ; controle; 
  ctrt:= 37; ctrloc:=ctr; 
    b:=proc(ident)
    -==:proc(ident)
    -==:-==:proc(ident) BOLD 
      (-==:-==:proc(ident)-==:
        (proc(ident)-==:proc(ident)))
     BOLD proc(ident)
  ; controle; 
  ctrt:= 38; ctrloc:=ctr; 
    b:= IF FALSE THEN SKIP ELSE ident FI 
  
    -==: IF FALSE THEN SKIP ELSE ident FI 
  
    -==:-==: IF FALSE THEN SKIP ELSE ident FI 
     BOLD 
      (-==:-==: IF FALSE THEN SKIP ELSE ident FI 
      -==:
        (IF FALSE THEN SKIP ELSE ident FI 
        -==: IF FALSE THEN SKIP ELSE ident FI 
  ))
     BOLD IF FALSE THEN SKIP ELSE ident FI 
  
  ; controle; 
  ctrt:= 39; ctrloc:=ctr; 
    b:= REF BOOL (1 | ident, SKIP)
  
    -==: REF BOOL (1 | ident, SKIP)
  
    -==:-==: REF BOOL (1 | ident, SKIP)
     BOLD 
      (-==:-==: REF BOOL (1 | ident, SKIP)
      -==:
        (REF BOOL (1 | ident, SKIP)
        -==: REF BOOL (1 | ident, SKIP)
  ))
     BOLD REF BOOL (1 | ident, SKIP)
  
  ; controle; 
  ctrt:= 40; ctrloc:=ctr; 
    b:= (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
    -==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
     BOLD 
      (-==:-==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
           EXIT ee: GOTO e)
      -==:
        ((GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
        -==:(GOTO ee EXIT e:(INT x; vu | (REAL):ident)
             EXIT ee: GOTO e)
  ))
     BOLD (GOTO ee EXIT e:(INT x; vu | (REAL):ident)
         EXIT ee: GOTO e)
  
  ; controle; 
   SKIP END; 
  
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r6d #
  (print((newline, "Coercions in weak context: ")); 
   INT vf = 11*(3+13+9+17); 
   INT ctrt:= 0, ctr:= 0; 
   PROC controle = ([] REAL a, 
     UNION (STRING, CHAR, COMPL) b)  VOID :
     ((UPB a= 1  AND ABS (a[1]-1)<1e-5 | ctr+:= 1
       |:  UPB a= 3  AND ABS (a[3]-1)<1e-5 | ctr+:= 5); 
     (b | (CHAR c) : (c="""" | ctr+:= 2), 
        (STRING c) : (UPB c= 3  AND c[2]="." | ctr+:= 8), 
        (COMPL c) : (re OF c= 0  AND ABS (IM c-1)<1e-5 | 
  ctr+:= 12))); 
   PRIO  ?=: = 1, ?:= = 9; 
  
  # controle, servitudes et contextes pour modes :
  
       COMPL 
                      et
       STRING   #
   BEGIN 
   PROC c = (REAL a, CHAR b
  ) VOID :
      (INT x=ctr; controle(a, b); 
      ctr/=x+3 | 
      print(("count er in test", ctrt, ctr, x+3, newline))); 
  
   PROC PROC COMPL ids =
   PROC COMPL :  COMPL : (0, 1); 
   PROC PROC STRING idr =
   PROC STRING :  STRING : """."""; 
   OP  ?=: = (PROC PROC COMPL a)
   PROC PROC COMPL : a, 
       ?:= = (PROC PROC STRING a)
   PROC PROC STRING : a, 
       ?=: = (PROC PROC COMPL a, INT b)
   PROC PROC COMPL : (b |  SKIP, a), 
       ?:= = (PROC PROC STRING a, INT b)
   PROC PROC STRING : (b |  SKIP, a), 
   STRUCT (COMPL toto, 
   PROC PROC COMPL de)de = (0, ids), 
   STRUCT (COMPL toto, 
   PROC PROC STRING of)of = (0, idr), 
  [] PROC PROC COMPL sang = ids, 
  [] PROC PROC STRING rang = idr, 
   PROC si = (PROC PROC COMPL a)
   PROC PROC COMPL : a, 
         ri = (PROC PROC STRING a)
   PROC PROC STRING : a, 
   UNION (CHAR, PROC PROC COMPL, PROC PROC STRING) u; 
  ctrt:= 1; 
  c (im OF  (PROC COMPL :  COMPL : (0, 1)), 
      (PROC STRING :  STRING : """.""")[3]); 
  ctrt:= 2; 
  c (im OF  (?=:ids?=:2), 
      (?:=idr?:= 2)[3]); 
  ctrt:= 3; 
  c (im OF de OF de, 
      (of OF of)[3]); 
  ctrt:= 4; 
  c (im OF sang[1], 
      rang[1][3]); 
  ctrt:= 5; 
  c (im OF si(ids), 
      ri(idr)[3]); 
  ctrt:= 6; 
  c (im OF PROC PROC COMPL (ids), 
       PROC PROC STRING (idr)[3]); 
  ctrt:= 7; 
  c (im OF ids, 
      idr[3]); 
  ctrt:= 8; 
  c (im OF BEGIN (INT x; ids) EXIT etiq: SKIP END, 
       BEGIN (INT x; idr) EXIT etiq: SKIP END [3]); 
  ctrt:= 9; 
  c (im OF IF TRUE THEN ids FI, 
       IF TRUE THEN idr FI [3]); 
  ctrt:= 10; 
  c (im OF  (1 | ids, SKIP), 
      (1 | idr, SKIP)[3]); 
  ctrt:= 11; 
  c (im OF  (u:=ids | (PROC PROC COMPL x):x), 
      (u:=idr | (PROC PROC STRING x):x)[3]); 
   SKIP END; 
  
  # controle, servitudes et contextes pour modes :
  
       STRUCT (UNION (INT, PROC STRING)re, 
      [] REAL im)
                      et
      [] REF STRING   #
   BEGIN 
   PROC c = ([] REAL a, REF STRING b
  ) VOID :
      (INT x=ctr; controle(a, b); 
      ctr/=x+13 | 
      print(("count er in test", ctrt, ctr, x+13, newline))); 
  
   REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) ids =
   HEAP PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im):=
   STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) : (0, (2, 3, 1)); 
   REF PROC [] REF STRING idr =
   HEAP PROC  [] REF STRING :=
     [] REF STRING : (NIL, NIL, HEAP STRING :="""."""); 
   OP  ?=: = (REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) a)
   REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) : a, 
       ?:= = (REF PROC [] REF STRING a)
   REF PROC [] REF STRING : a, 
       ?=: = (REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) a, INT b)
   REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) : (b |  SKIP, a), 
       ?:= = (REF PROC [] REF STRING a, INT b)
   REF PROC [] REF STRING : (b |  SKIP, a), 
   STRUCT (COMPL toto, 
   REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im)de)de = (0, ids), 
   STRUCT (COMPL toto, 
   REF PROC [] REF STRING of)of = (0, idr), 
  [] REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im)sang = ids, 
  [] REF PROC [] REF STRING rang = idr, 
   PROC si = (REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) a)
   REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) : a, 
         ri = (REF PROC [] REF STRING a)
   REF PROC [] REF STRING : a, 
   UNION (CHAR, REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im), REF PROC [] REF STRING) u; 
  ctrt:= 12; 
  c (im OF  (HEAP PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im):=
   STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im) : (0, (2, 3, 1))), 
      (HEAP PROC  [] REF STRING :=
         [] REF STRING : (NIL, NIL, HEAP STRING :="""."""))
  [3]); 
  ctrt:= 13; 
  c (im OF  (?=:ids?=:2), 
      (?:=idr?:= 2)[3]); 
  ctrt:= 14; 
  c (im OF de OF de, 
      (of OF of)[3]); 
  ctrt:= 15; 
  c (im OF sang[1], 
      rang[1][3]); 
  ctrt:= 16; 
  c (im OF si(ids), 
      ri(idr)[3]); 
  ctrt:= 17; 
  c (im OF REF PROC STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im)(ids), 
       REF PROC [] REF STRING (idr)[3]); 
  ctrt:= 18; 
  c (im OF ids, 
      idr[3]); 
  ctrt:= 19; 
  c (im OF BEGIN (INT x; ids) EXIT etiq: SKIP END, 
       BEGIN (INT x; idr) EXIT etiq: SKIP END [3]); 
  ctrt:= 20; 
  c (im OF IF TRUE THEN ids FI, 
       IF TRUE THEN idr FI [3]); 
  ctrt:= 21; 
  c (im OF  (1 | ids, SKIP), 
      (1 | idr, SKIP)[3]); 
  ctrt:= 22; 
  c (im OF  (u:=ids | (REF PROC 
   STRUCT (UNION (INT, PROC STRING)re, 
  [] REAL im)x):x), 
      (u:=idr | (REF PROC [] REF STRING x):x)[3]); 
   SKIP END; 
  
  # controle, servitudes et contextes pour modes :
  
       REF COMPL 
                      et
       REF [] REF STRING   #
   BEGIN 
   PROC c = (REF REAL a, REF REF STRING b
  ) VOID :
      (INT x=ctr; controle(a, b); 
      ctr/=x+9 | 
      print(("count er in test", ctrt, ctr, x+9, newline))); 
  
   PROC REF COMPL ids =
   REF COMPL :  HEAP COMPL := (0, 1); 
   PROC REF [] REF STRING idr =
   REF [] REF STRING :  HEAP [3] REF STRING :=
     (NIL, NIL, HEAP STRING :="""."""); 
   OP  ?=: = (PROC REF COMPL a)
   PROC REF COMPL : a, 
       ?:= = (PROC REF [] REF STRING a)
   PROC REF [] REF STRING : a, 
       ?=: = (PROC REF COMPL a, INT b)
   PROC REF COMPL : (b |  SKIP, a), 
       ?:= = (PROC REF [] REF STRING a, INT b)
   PROC REF [] REF STRING : (b |  SKIP, a), 
   STRUCT (COMPL toto, 
   PROC REF COMPL de)de = (0, ids), 
   STRUCT (COMPL toto, 
   PROC REF [] REF STRING of)of = (0, idr), 
  [] PROC REF COMPL sang = ids, 
  [] PROC REF [] REF STRING rang = idr, 
   PROC si = (PROC REF COMPL a)
   PROC REF COMPL : a, 
         ri = (PROC REF [] REF STRING a)
   PROC REF [] REF STRING : a, 
   UNION (CHAR, PROC REF COMPL, PROC REF [] REF STRING) u; 
  ctrt:= 23; 
  c (im OF  (REF COMPL :  HEAP COMPL := (0, 1)), 
      (REF [] REF STRING :  HEAP [3] REF STRING :=
         (NIL, NIL, HEAP STRING :="""."""))[3]); 
  ctrt:= 24; 
  c (im OF  (?=:ids?=:2), 
      (?:=idr?:= 2)[3]); 
  ctrt:= 25; 
  c (im OF de OF de, 
      (of OF of)[3]); 
  ctrt:= 26; 
  c (im OF sang[1], 
      rang[1][3]); 
  ctrt:= 27; 
  c (im OF si(ids), 
      ri(idr)[3]); 
  ctrt:= 28; 
  c (im OF PROC REF COMPL (ids), 
       PROC REF [] REF STRING (idr)[3]); 
  ctrt:= 29; 
  c (im OF ids, 
      idr[3]); 
  ctrt:= 30; 
  c (im OF BEGIN (INT x; ids) EXIT etiq: SKIP END, 
       BEGIN (INT x; idr) EXIT etiq: SKIP END [3]); 
  ctrt:= 31; 
  c (im OF IF TRUE THEN ids FI, 
       IF TRUE THEN idr FI [3]); 
  ctrt:= 32; 
  c (im OF  (1 | ids, SKIP), 
      (1 | idr, SKIP)[3]); 
  ctrt:= 33; 
  c (im OF  (u:=ids | (PROC REF COMPL x):x), 
      (u:=idr | (PROC REF [] REF STRING x):x)[3]); 
   SKIP END; 
  
  # controle, servitudes et contextes pour modes :
  
       REF [] COMPL 
                      et
       REF [] COMPL   #
   BEGIN 
   PROC c = (REF [] REAL a, REF COMPL b
  ) VOID :
      (INT x=ctr; controle(a, b); 
      ctr/=x+17 | 
      print(("count er in test", ctrt, ctr, x+17, newline))); 
  
   REF PROC REF REF [] COMPL ids =
   HEAP PROC REF REF [] COMPL :=
      REF REF [] COMPL :  HEAP REF [] COMPL :=
         HEAP [3] COMPL := (0 I 3, 0 I 2, 0 I 1)
  ; 
   REF PROC REF REF [] COMPL idr =
   HEAP PROC REF REF [] COMPL :=
      REF REF [] COMPL :  HEAP REF [] COMPL :=
         HEAP [3] COMPL := (0 I 3, 0 I 2, 0 I 1)
  ; 
   OP  ?=: = (REF PROC REF REF [] COMPL a)
   REF PROC REF REF [] COMPL : a, 
       ?:= = (REF PROC REF REF [] COMPL a)
   REF PROC REF REF [] COMPL : a, 
       ?=: = (REF PROC REF REF [] COMPL a, INT b)
   REF PROC REF REF [] COMPL : (b |  SKIP, a), 
       ?:= = (REF PROC REF REF [] COMPL a, INT b)
   REF PROC REF REF [] COMPL : (b |  SKIP, a), 
   STRUCT (COMPL toto, 
   REF PROC REF REF [] COMPL de)de = (0, ids), 
   STRUCT (COMPL toto, 
   REF PROC REF REF [] COMPL of)of = (0, idr), 
  [] REF PROC REF REF [] COMPL sang = ids, 
  [] REF PROC REF REF [] COMPL rang = idr, 
   PROC si = (REF PROC REF REF [] COMPL a)
   REF PROC REF REF [] COMPL : a, 
         ri = (REF PROC REF REF [] COMPL a)
   REF PROC REF REF [] COMPL : a, 
   UNION (CHAR, REF PROC REF REF [] COMPL, REF PROC REF 
   REF [] COMPL) u; 
  ctrt:= 34; 
  c (im OF  (HEAP PROC REF REF [] COMPL :=
      REF REF [] COMPL :  HEAP REF [] COMPL :=
         HEAP [3] COMPL := (0 I 3, 0 I 2, 0 I 1)
  ), 
      (HEAP PROC REF REF [] COMPL :=
          REF REF [] COMPL :  HEAP REF [] COMPL :=
             HEAP [3] COMPL := (0 I 3, 0 I 2, 0 I 1)
  )[3]); 
  ctrt:= 35; 
  c (im OF  (?=:ids?=:2), 
      (?:=idr?:= 2)[3]); 
  ctrt:= 36; 
  c (im OF de OF de, 
      (of OF of)[3]); 
  ctrt:= 37; 
  c (im OF sang[1], 
      rang[1][3]); 
  ctrt:= 38; 
  c (im OF si(ids), 
      ri(idr)[3]); 
  ctrt:= 39; 
  c (im OF REF PROC REF REF [] COMPL (ids), 
       REF PROC REF REF [] COMPL (idr)[3]); 
  ctrt:= 40; 
  c (im OF ids, 
      idr[3]); 
  ctrt:= 41; 
  c (im OF BEGIN (INT x; ids) EXIT etiq: SKIP END, 
       BEGIN (INT x; idr) EXIT etiq: SKIP END [3]); 
  ctrt:= 42; 
  c (im OF IF TRUE THEN ids FI, 
       IF TRUE THEN idr FI [3]); 
  ctrt:= 43; 
  c (im OF  (1 | ids, SKIP), 
      (1 | idr, SKIP)[3]); 
  ctrt:= 44; 
  c (im OF  (u:=ids | (REF PROC REF REF [] COMPL x):x), 
      (u:=idr | (REF PROC REF REF [] COMPL x):x)[3]); 
   SKIP END; 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r6e #
  (print((newline, "Coercions in soft context: ")); 
   INT vf = 330; 
   INT ctrt:= 0, ctr:= 0; 
   MODE MODEREP = REF UNION (INT, COMPL); 
           # procedure de controle #
            BOOL active := TRUE; 
   PROC c = (UNION (REF PROC INT, REF REF COMPL, 
   REF PROC [] UNION (INT, COMPL), MODEREP) par) VOID :
       ctr+:= (par | (REF PROC INT p) :
        (active:= FALSE;  INT x=p; active:= TRUE; x), 
        (REF REF COMPL) : 5, 
        (REF PROC [] UNION (INT, COMPL)) : 7, 
        (MODEREP) : 11
   | print(("erreur mode", ctrt, newline)); 0); 
  
  # instructions de servitude generales #
   PROC pe = INT : (active | print("activation pe"); 0 | 3); 
   PROC INT rpe:=pe; 
   HEAP COMPL rc;  REF COMPL rrc:=rc; 
   UNION (INT, COMPL)ru := 1 I 0; 
   PROC rpru:=[] UNION (INT, COMPL) :
  (print("activation pru"); 1); 
  
   BEGIN  # servitudes pour unites du mode PROC PROC REF PROC INT  #
   PROC PROC REF PROC INT ident = PROC REF PROC INT :
   REF PROC INT : rpe; 
   OP  &=: = (BOOL a, PROC PROC REF PROC INT b) PROC PROC 
   REF PROC INT : (a | b), 
   PRIO  &=: = 9, 
   STRUCT (PROC PROC REF PROC INT de, of) de = (ident, SKIP); 
  [] PROC PROC REF PROC INT rang = ident, 
   PROC pav = (PROC PROC REF PROC INT x)
       PROC PROC REF PROC INT : x; 
       # contextes #
  ctrt:= 1
  ; c((PROC REF PROC INT :
   REF PROC INT : rpe):= (
  (PROC REF PROC INT :
   REF PROC INT : rpe) :=
  (PROC REF PROC INT :
   REF PROC INT : rpe) :=
  (PROC REF PROC INT :
   REF PROC INT : rpe) :=
  pe)); 
  (((PROC REF PROC INT :
   REF PROC INT : rpe) :/=:  NIL) AND 
      (rpe :=:
  (PROC REF PROC INT :
   REF PROC INT : rpe)) | ctr+:= 1); 
  ctrt:= 2
  ; c(NOT FALSE &=:ident:= (
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
  pe)); 
  ((NOT FALSE &=:ident :/=:  NIL) AND 
      (rpe :=:
   NOT FALSE &=:ident) | ctr+:= 1); 
  ctrt:= 3
  ; c(de OF de:= (
  de OF de :=
  de OF de :=
  de OF de :=
  pe)); 
  ((de OF de :/=:  NIL) AND 
      (rpe :=:
  de OF de) | ctr+:= 1); 
  ctrt:= 4
  ; c(rang[1]:= (
  rang[1] :=
  rang[1] :=
  rang[1] :=
  pe)); 
  ((rang[1] :/=:  NIL) AND 
      (rpe :=:
  rang[1]) | ctr+:= 1); 
  ctrt:= 5
  ; c(pav(ident):= (
  pav(ident) :=
  pav(ident) :=
  pav(ident) :=
  pe)); 
  ((pav(ident) :/=:  NIL) AND 
      (rpe :=:
  pav(ident)) | ctr+:= 1); 
  ctrt:= 6
  ; c(PROC PROC REF PROC INT BEGIN ident END := (
   PROC PROC REF PROC INT BEGIN ident END :=
   PROC PROC REF PROC INT BEGIN ident END :=
   PROC PROC REF PROC INT BEGIN ident END :=
  pe)); 
  ((PROC PROC REF PROC INT BEGIN ident END :/=:  NIL) AND 
      (rpe :=:
   PROC PROC REF PROC INT BEGIN ident END) | ctr+:= 1); 
  ctrt:= 7
  ; c(ident:= (
  ident :=
  ident :=
  ident :=
  pe)); 
  ((ident :/=:  NIL) AND 
      (rpe :=:
  ident) | ctr+:= 1); 
  ctrt:= 8
  ; c(BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END := (
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
  pe)); 
  ((BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :/=:  NIL) AND 
      (rpe :=:
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END) | ctr+:= 1); 
  ctrt:= 9
  ; c((TRUE | SKIP; ident):= (
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  pe)); 
  (((TRUE | SKIP; ident) :/=:  NIL) AND 
      (rpe :=:
  (TRUE | SKIP; ident)) | ctr+:= 1); 
  ctrt:= 10
  ; c(CASE -2 IN SKIP, ident
   OUT ident ESAC := (
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
  pe)); 
  ((CASE -2 IN SKIP, ident
   OUT ident ESAC :/=:  NIL) AND 
      (rpe :=:
   CASE -2 IN SKIP, ident
   OUT ident ESAC) | ctr+:= 1); 
  ctrt:= 11
  ; c((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  := (
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  pe)); 
  (((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :/=:  NIL) AND 
      (rpe :=:
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  ) | ctr+:= 1); 
   SKIP END; 
  
   BEGIN  # servitudes pour unites du mode PROC REF REF COMPL  #
   PROC REF REF COMPL ident = REF REF COMPL : rrc; 
   OP  &=: = (BOOL a, PROC REF REF COMPL b) PROC REF REF COMPL 
   : (a | b), 
   PRIO  &=: = 9, 
   STRUCT (PROC REF REF COMPL de, of) de = (ident, SKIP); 
  [] PROC REF REF COMPL rang = ident, 
   PROC pav = (PROC REF REF COMPL x)
       PROC REF REF COMPL : x; 
       # contextes #
  ctrt:= 12
  ; c((REF REF COMPL : rrc):= (
  (REF REF COMPL : rrc) :=
  (REF REF COMPL : rrc) :=
  (REF REF COMPL : rrc) :=
  rc)); 
  (((REF REF COMPL : rrc) :/=:  NIL) AND 
      (rrc :=:
  (REF REF COMPL : rrc)) | ctr+:= 1); 
  ctrt:= 13
  ; c(NOT FALSE &=:ident:= (
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
  rc)); 
  ((NOT FALSE &=:ident :/=:  NIL) AND 
      (rrc :=:
   NOT FALSE &=:ident) | ctr+:= 1); 
  ctrt:= 14
  ; c(de OF de:= (
  de OF de :=
  de OF de :=
  de OF de :=
  rc)); 
  ((de OF de :/=:  NIL) AND 
      (rrc :=:
  de OF de) | ctr+:= 1); 
  ctrt:= 15
  ; c(rang[1]:= (
  rang[1] :=
  rang[1] :=
  rang[1] :=
  rc)); 
  ((rang[1] :/=:  NIL) AND 
      (rrc :=:
  rang[1]) | ctr+:= 1); 
  ctrt:= 16
  ; c(pav(ident):= (
  pav(ident) :=
  pav(ident) :=
  pav(ident) :=
  rc)); 
  ((pav(ident) :/=:  NIL) AND 
      (rrc :=:
  pav(ident)) | ctr+:= 1); 
  ctrt:= 17
  ; c(PROC REF REF COMPL BEGIN ident END := (
   PROC REF REF COMPL BEGIN ident END :=
   PROC REF REF COMPL BEGIN ident END :=
   PROC REF REF COMPL BEGIN ident END :=
  rc)); 
  ((PROC REF REF COMPL BEGIN ident END :/=:  NIL) AND 
      (rrc :=:
   PROC REF REF COMPL BEGIN ident END) | ctr+:= 1); 
  ctrt:= 18
  ; c(ident:= (
  ident :=
  ident :=
  ident :=
  rc)); 
  ((ident :/=:  NIL) AND 
      (rrc :=:
  ident) | ctr+:= 1); 
  ctrt:= 19
  ; c(BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END := (
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
  rc)); 
  ((BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :/=:  NIL) AND 
      (rrc :=:
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END) | ctr+:= 1); 
  ctrt:= 20
  ; c((TRUE | SKIP; ident):= (
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  rc)); 
  (((TRUE | SKIP; ident) :/=:  NIL) AND 
      (rrc :=:
  (TRUE | SKIP; ident)) | ctr+:= 1); 
  ctrt:= 21
  ; c(CASE -2 IN SKIP, ident
   OUT ident ESAC := (
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
  rc)); 
  ((CASE -2 IN SKIP, ident
   OUT ident ESAC :/=:  NIL) AND 
      (rrc :=:
   CASE -2 IN SKIP, ident
   OUT ident ESAC) | ctr+:= 1); 
  ctrt:= 22
  ; c((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  := (
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  rc)); 
  (((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :/=:  NIL) AND 
      (rrc :=:
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  ) | ctr+:= 1); 
   SKIP END; 
  
   BEGIN  # servitudes pour unites du mode PROC PROC PROC 
   REF PROC [] UNION (INT, COMPL) #
   PROC PROC PROC REF PROC [] UNION (INT, COMPL) ident =
   PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru; 
   OP  &=: = (BOOL a, PROC PROC PROC 
   REF PROC [] UNION (INT, COMPL)b) PROC PROC PROC 
   REF PROC [] UNION (INT, COMPL) : (a | b), 
   PRIO  &=: = 9, 
   STRUCT (PROC PROC PROC REF PROC [] UNION (INT, COMPL)
  de, of) de = (ident, SKIP); 
  [] PROC PROC PROC REF PROC [] UNION (INT, COMPL)
  rang = ident, 
   PROC pav = (PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   x)
       PROC PROC PROC REF PROC [] UNION (INT, COMPL) : x; 
       # contextes #
  ctrt:= 23
  ; c((PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru):= (
  (PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru) :=
  (PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru) :=
  (PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru) :=
  rpru)); 
  (((PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru) :/=:  NIL) AND 
      (rpru :=:
  (PROC PROC REF PROC [] UNION (INT, COMPL) :
   PROC REF PROC [] UNION (INT, COMPL) :
   REF PROC [] UNION (INT, COMPL) : rpru)) | ctr+:= 1); 
  ctrt:= 24
  ; c(NOT FALSE &=:ident:= (
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
  rpru)); 
  ((NOT FALSE &=:ident :/=:  NIL) AND 
      (rpru :=:
   NOT FALSE &=:ident) | ctr+:= 1); 
  ctrt:= 25
  ; c(de OF de:= (
  de OF de :=
  de OF de :=
  de OF de :=
  rpru)); 
  ((de OF de :/=:  NIL) AND 
      (rpru :=:
  de OF de) | ctr+:= 1); 
  ctrt:= 26
  ; c(rang[1]:= (
  rang[1] :=
  rang[1] :=
  rang[1] :=
  rpru)); 
  ((rang[1] :/=:  NIL) AND 
      (rpru :=:
  rang[1]) | ctr+:= 1); 
  ctrt:= 27
  ; c(pav(ident):= (
  pav(ident) :=
  pav(ident) :=
  pav(ident) :=
  rpru)); 
  ((pav(ident) :/=:  NIL) AND 
      (rpru :=:
  pav(ident)) | ctr+:= 1); 
  ctrt:= 28
  ; c(PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END := (
   PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END :=
   PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END :=
   PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END :=
  rpru)); 
  ((PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END :/=:  NIL) AND 
      (rpru :=:
   PROC PROC PROC REF PROC [] UNION (INT, COMPL)
   BEGIN ident END) | ctr+:= 1); 
  ctrt:= 29
  ; c(ident:= (
  ident :=
  ident :=
  ident :=
  rpru)); 
  ((ident :/=:  NIL) AND 
      (rpru :=:
  ident) | ctr+:= 1); 
  ctrt:= 30
  ; c(BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END := (
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
  rpru)); 
  ((BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :/=:  NIL) AND 
      (rpru :=:
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END) | ctr+:= 1); 
  ctrt:= 31
  ; c((TRUE | SKIP; ident):= (
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  rpru)); 
  (((TRUE | SKIP; ident) :/=:  NIL) AND 
      (rpru :=:
  (TRUE | SKIP; ident)) | ctr+:= 1); 
  ctrt:= 32
  ; c(CASE -2 IN SKIP, ident
   OUT ident ESAC := (
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
  rpru)); 
  ((CASE -2 IN SKIP, ident
   OUT ident ESAC :/=:  NIL) AND 
      (rpru :=:
   CASE -2 IN SKIP, ident
   OUT ident ESAC) | ctr+:= 1); 
  ctrt:= 33
  ; c((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  := (
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  rpru)); 
  (((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :/=:  NIL) AND 
      (rpru :=:
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  ) | ctr+:= 1); 
   SKIP END; 
  
   BEGIN  # servitudes pour unites du mode PROC PROC MODEREP  #
   PROC PROC MODEREP ident = PROC MODEREP :  MODEREP : ru; 
   OP  &=: = (BOOL a, PROC PROC MODEREP b) PROC PROC MODEREP 
   : (a | b), 
   PRIO  &=: = 9, 
   STRUCT (PROC PROC MODEREP de, of) de = (ident, SKIP); 
  [] PROC PROC MODEREP rang = ident, 
   PROC pav = (PROC PROC MODEREP x)
       PROC PROC MODEREP : x; 
       # contextes #
  ctrt:= 34
  ; c((PROC MODEREP :  MODEREP : ru):= (
  (PROC MODEREP :  MODEREP : ru) :=
  (PROC MODEREP :  MODEREP : ru) :=
  (PROC MODEREP :  MODEREP : ru) :=
  1)); 
  (((PROC MODEREP :  MODEREP : ru) :/=:  NIL) AND 
      (ru :=:
  (PROC MODEREP :  MODEREP : ru)) | ctr+:= 1); 
  ctrt:= 35
  ; c(NOT FALSE &=:ident:= (
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
   NOT FALSE &=:ident :=
  1)); 
  ((NOT FALSE &=:ident :/=:  NIL) AND 
      (ru :=:
   NOT FALSE &=:ident) | ctr+:= 1); 
  ctrt:= 36
  ; c(de OF de:= (
  de OF de :=
  de OF de :=
  de OF de :=
  1)); 
  ((de OF de :/=:  NIL) AND 
      (ru :=:
  de OF de) | ctr+:= 1); 
  ctrt:= 37
  ; c(rang[1]:= (
  rang[1] :=
  rang[1] :=
  rang[1] :=
  1)); 
  ((rang[1] :/=:  NIL) AND 
      (ru :=:
  rang[1]) | ctr+:= 1); 
  ctrt:= 38
  ; c(pav(ident):= (
  pav(ident) :=
  pav(ident) :=
  pav(ident) :=
  1)); 
  ((pav(ident) :/=:  NIL) AND 
      (ru :=:
  pav(ident)) | ctr+:= 1); 
  ctrt:= 39
  ; c(PROC PROC MODEREP BEGIN ident END := (
   PROC PROC MODEREP BEGIN ident END :=
   PROC PROC MODEREP BEGIN ident END :=
   PROC PROC MODEREP BEGIN ident END :=
  1)); 
  ((PROC PROC MODEREP BEGIN ident END :/=:  NIL) AND 
      (ru :=:
   PROC PROC MODEREP BEGIN ident END) | ctr+:= 1); 
  ctrt:= 40
  ; c(ident:= (
  ident :=
  ident :=
  ident :=
  1)); 
  ((ident :/=:  NIL) AND 
      (ru :=:
  ident) | ctr+:= 1); 
  ctrt:= 41
  ; c(BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END := (
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :=
  1)); 
  ((BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END :/=:  NIL) AND 
      (ru :=:
   BEGIN  (SKIP;  GOTO s)  EXIT 
  s: ident EXIT e: SKIP END) | ctr+:= 1); 
  ctrt:= 42
  ; c((TRUE | SKIP; ident):= (
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  (TRUE | SKIP; ident) :=
  1)); 
  (((TRUE | SKIP; ident) :/=:  NIL) AND 
      (ru :=:
  (TRUE | SKIP; ident)) | ctr+:= 1); 
  ctrt:= 43
  ; c(CASE -2 IN SKIP, ident
   OUT ident ESAC := (
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
   CASE -2 IN SKIP, ident
   OUT ident ESAC :=
  1)); 
  ((CASE -2 IN SKIP, ident
   OUT ident ESAC :/=:  NIL) AND 
      (ru :=:
   CASE -2 IN SKIP, ident
   OUT ident ESAC) | ctr+:= 1); 
  ctrt:= 44
  ; c((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  := (
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :=
  1)); 
  (((ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
   :/=:  NIL) AND 
      (ru :=:
  (ru | (UNION (COMPL, 
                       UNION (INT, COMPL), INT)): ident)
  ) | ctr+:= 1); 
   SKIP END; 
  
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r71a #
   BEGIN print((newline, "Independence of operators in the same range: ")); 
  #   controle   #
   INT vf = 110; 
   INT ctr:= 0; 
  [1:vf] BOOL tc; 
   FOR i TO vf DO tc[i]:= TRUE OD; 
   PROC pos = (INT i) BOOL :
      (tc[i] | ctr+:= 1; tc[i]:= FALSE  | 
      print(("er.1", i, newline));  SKIP); 
  #   declarations de servitude   #
   MODE M = STRUCT (CHAR e1, REF M e2); M vm= ("#", NIL); 
   OP  - = (REAL a) PROC (INT, INT) INT : SKIP, 
   PROC PROC (REAL, INT) VOID var :=
       PROC (REAL, INT) VOID :
           (REAL a, INT b) VOID :  HEAP INT, 
  
   OP  - = (INT par) BOOL :pos(1), 
   OP  - = (M par) BOOL :pos(2), 
   OP  - = (PROC (INT, REAL) INT par) BOOL :pos(3), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       par) BOOL :pos(4), 
   OP  - = (PROC STRUCT (INT x, y) par) BOOL :pos(5), 
   OP  - = (PROC (INT, INT) INT par) BOOL :pos(6), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                par) BOOL :pos(7), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           par) BOOL :pos(8), 
   OP  - = ([, , ][ ] BOOL par) BOOL :pos(9), 
   OP  - = ([, , ] BITS par) BOOL :pos(10), 
   OP  - = (INT p1, 
   INT p2) BOOL : pos(11), 
   OP  - = (INT p1, 
   M p2) BOOL : pos(12), 
   OP  - = (INT p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(13), 
   OP  - = (INT p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(14), 
   OP  - = (INT p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(15), 
   OP  - = (INT p1, 
   PROC (INT, INT) INT p2) BOOL : pos(16), 
   OP  - = (INT p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(17), 
   OP  - = (INT p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(18), 
   OP  - = (INT p1, 
  [, , ][ ] BOOL p2) BOOL : pos(19), 
   OP  - = (INT p1, 
  [, , ] BITS p2) BOOL : pos(20), 
   OP  - = (M p1, 
   INT p2) BOOL : pos(21), 
   OP  - = (M p1, 
   M p2) BOOL : pos(22), 
   OP  - = (M p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(23), 
   OP  - = (M p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(24), 
   OP  - = (M p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(25), 
   OP  - = (M p1, 
   PROC (INT, INT) INT p2) BOOL : pos(26), 
   OP  - = (M p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(27), 
   OP  - = (M p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(28), 
   OP  - = (M p1, 
  [, , ][ ] BOOL p2) BOOL : pos(29), 
   OP  - = (M p1, 
  [, , ] BITS p2) BOOL : pos(30), 
   OP  - = (PROC (INT, REAL) INT p1, 
   INT p2) BOOL : pos(31), 
   OP  - = (PROC (INT, REAL) INT p1, 
   M p2) BOOL : pos(32), 
   OP  - = (PROC (INT, REAL) INT p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(33), 
   OP  - = (PROC (INT, REAL) INT p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(34), 
   OP  - = (PROC (INT, REAL) INT p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(35), 
   OP  - = (PROC (INT, REAL) INT p1, 
   PROC (INT, INT) INT p2) BOOL : pos(36), 
   OP  - = (PROC (INT, REAL) INT p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(37), 
   OP  - = (PROC (INT, REAL) INT p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(38), 
   OP  - = (PROC (INT, REAL) INT p1, 
  [, , ][ ] BOOL p2) BOOL : pos(39), 
   OP  - = (PROC (INT, REAL) INT p1, 
  [, , ] BITS p2) BOOL : pos(40), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       INT p2) BOOL : pos(41), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       M p2) BOOL : pos(42), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       PROC (INT, REAL) INT p2) BOOL : pos(43), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(44), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       PROC STRUCT (INT x, y) p2) BOOL : pos(45), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       PROC (INT, INT) INT p2) BOOL : pos(46), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(47), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
       UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(48), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
      [, , ][ ] BOOL p2) BOOL : pos(49), 
   OP  - = (STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p1, 
      [, , ] BITS p2) BOOL : pos(50), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   INT p2) BOOL : pos(51), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   M p2) BOOL : pos(52), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(53), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(54), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(55), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   PROC (INT, INT) INT p2) BOOL : pos(56), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(57), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(58), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
  [, , ][ ] BOOL p2) BOOL : pos(59), 
   OP  - = (PROC STRUCT (INT x, y) p1, 
  [, , ] BITS p2) BOOL : pos(60), 
   OP  - = (PROC (INT, INT) INT p1, 
   INT p2) BOOL : pos(61), 
   OP  - = (PROC (INT, INT) INT p1, 
   M p2) BOOL : pos(62), 
   OP  - = (PROC (INT, INT) INT p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(63), 
   OP  - = (PROC (INT, INT) INT p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(64), 
   OP  - = (PROC (INT, INT) INT p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(65), 
   OP  - = (PROC (INT, INT) INT p1, 
   PROC (INT, INT) INT p2) BOOL : pos(66), 
   OP  - = (PROC (INT, INT) INT p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(67), 
   OP  - = (PROC (INT, INT) INT p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(68), 
   OP  - = (PROC (INT, INT) INT p1, 
  [, , ][ ] BOOL p2) BOOL : pos(69), 
   OP  - = (PROC (INT, INT) INT p1, 
  [, , ] BITS p2) BOOL : pos(70), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                INT p2) BOOL : pos(71), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                M p2) BOOL : pos(72), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                PROC (INT, REAL) INT p2) BOOL : pos(73), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(74), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                PROC STRUCT (INT x, y) p2) BOOL : pos(75), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                PROC (INT, INT) INT p2) BOOL : pos(76), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(77), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
                UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(78), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
               [, , ][ ] BOOL p2) BOOL : pos(79), 
   OP  - = (REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p1, 
               [, , ] BITS p2) BOOL : pos(80), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           INT p2) BOOL : pos(81), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           M p2) BOOL : pos(82), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           PROC (INT, REAL) INT p2) BOOL : pos(83), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(84), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           PROC STRUCT (INT x, y) p2) BOOL : pos(85), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           PROC (INT, INT) INT p2) BOOL : pos(86), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(87), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
           UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(88), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
          [, , ][ ] BOOL p2) BOOL : pos(89), 
   OP  - = (UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p1, 
          [, , ] BITS p2) BOOL : pos(90), 
   OP  - = ([, , ][ ] BOOL p1, 
   INT p2) BOOL : pos(91), 
   OP  - = ([, , ][ ] BOOL p1, 
   M p2) BOOL : pos(92), 
   OP  - = ([, , ][ ] BOOL p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(93), 
   OP  - = ([, , ][ ] BOOL p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(94), 
   OP  - = ([, , ][ ] BOOL p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(95), 
   OP  - = ([, , ][ ] BOOL p1, 
   PROC (INT, INT) INT p2) BOOL : pos(96), 
   OP  - = ([, , ][ ] BOOL p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(97), 
   OP  - = ([, , ][ ] BOOL p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(98), 
   OP  - = ([, , ][ ] BOOL p1, 
  [, , ][ ] BOOL p2) BOOL : pos(99), 
   OP  - = ([, , ][ ] BOOL p1, 
  [, , ] BITS p2) BOOL : pos(100), 
   OP  - = ([, , ] BITS p1, 
   INT p2) BOOL : pos(101), 
   OP  - = ([, , ] BITS p1, 
   M p2) BOOL : pos(102), 
   OP  - = ([, , ] BITS p1, 
   PROC (INT, REAL) INT p2) BOOL : pos(103), 
   OP  - = ([, , ] BITS p1, 
   STRUCT (CHAR e1, 
       REF STRUCT (CHAR e1, REF M e)e2)
       p2) BOOL : pos(104), 
   OP  - = ([, , ] BITS p1, 
   PROC STRUCT (INT x, y) p2) BOOL : pos(105), 
   OP  - = ([, , ] BITS p1, 
   PROC (INT, INT) INT p2) BOOL : pos(106), 
   OP  - = ([, , ] BITS p1, 
   REF UNION (STRUCT (INT x, y), 
                STRUCT (INT x, y, z))
                p2) BOOL : pos(107), 
   OP  - = ([, , ] BITS p1, 
   UNION (PROC (INT, REAL) VOID, 
           PROC (REAL, INT) VOID)
           p2) BOOL : pos(108), 
   OP  - = ([, , ] BITS p1, 
  [, , ][ ] BOOL p2) BOOL : pos(109), 
   OP  - = ([, , ] BITS p1, 
  [, , ] BITS p2) BOOL : pos(110), 
   BOOL b= FALSE; (
  -0000, 
  -vm, 
  -(PROC p= (INT a, REAL b) INT :0; p), 
  - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  -(STRUCT (INT x, y):(1, 2)), 
  --.1, 
  - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  0000
     -0000, 
  0000
     -vm, 
  0000
     -(PROC p= (INT a, REAL b) INT :0; p), 
  0000
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  0000
     -(STRUCT (INT x, y):(1, 2)), 
  0000
     --.1, 
  0000
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  0000
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  0000
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  0000
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  vm
     -0000, 
  vm
     -vm, 
  vm
     -(PROC p= (INT a, REAL b) INT :0; p), 
  vm
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  vm
     -(STRUCT (INT x, y):(1, 2)), 
  vm
     --.1, 
  vm
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  vm
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  vm
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  vm
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  (PROC p= (INT a, REAL b) INT :0; p)
     -0000, 
  (PROC p= (INT a, REAL b) INT :0; p)
     -vm, 
  (PROC p= (INT a, REAL b) INT :0; p)
     -(PROC p= (INT a, REAL b) INT :0; p), 
  (PROC p= (INT a, REAL b) INT :0; p)
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  (PROC p= (INT a, REAL b) INT :0; p)
     -(STRUCT (INT x, y):(1, 2)), 
  (PROC p= (INT a, REAL b) INT :0; p)
     --.1, 
  (PROC p= (INT a, REAL b) INT :0; p)
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  (PROC p= (INT a, REAL b) INT :0; p)
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  (PROC p= (INT a, REAL b) INT :0; p)
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  (PROC p= (INT a, REAL b) INT :0; p)
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     -0000, 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     -vm, 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     -(PROC p= (INT a, REAL b) INT :0; p), 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     -(STRUCT (INT x, y):(1, 2)), 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     --.1, 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
   STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP)
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  (STRUCT (INT x, y):(1, 2))
     -0000, 
  (STRUCT (INT x, y):(1, 2))
     -vm, 
  (STRUCT (INT x, y):(1, 2))
     -(PROC p= (INT a, REAL b) INT :0; p), 
  (STRUCT (INT x, y):(1, 2))
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  (STRUCT (INT x, y):(1, 2))
     -(STRUCT (INT x, y):(1, 2)), 
  (STRUCT (INT x, y):(1, 2))
     --.1, 
  (STRUCT (INT x, y):(1, 2))
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  (STRUCT (INT x, y):(1, 2))
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  (STRUCT (INT x, y):(1, 2))
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  (STRUCT (INT x, y):(1, 2))
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  -.1
     -0000, 
  -.1
     -vm, 
  -.1
     -(PROC p= (INT a, REAL b) INT :0; p), 
  -.1
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  -.1
     -(STRUCT (INT x, y):(1, 2)), 
  -.1
     --.1, 
  -.1
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  -.1
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  -.1
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  -.1
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     -0000, 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     -vm, 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     -(PROC p= (INT a, REAL b) INT :0; p), 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     -(STRUCT (INT x, y):(1, 2)), 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     --.1, 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
   LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z))
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     -0000, 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     -vm, 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     -(PROC p= (INT a, REAL b) INT :0; p), 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     -(STRUCT (INT x, y):(1, 2)), 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     --.1, 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
  (LOC REF PROC PROC (REAL, INT) VOID :=var)
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     -0000, 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     -vm, 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     -(PROC p= (INT a, REAL b) INT :0; p), 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     -(STRUCT (INT x, y):(1, 2)), 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     --.1, 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
   BEGIN [, , ][] BOOL tb= 4r1230321; tb END 
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     -0000, 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     -vm, 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     -(PROC p= (INT a, REAL b) INT :0; p), 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     - STRUCT (CHAR e1, REF STRUCT (CHAR e1, REF M e)e2)(SKIP), 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     -(STRUCT (INT x, y):(1, 2)), 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     --.1, 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     - LOC UNION (STRUCT (INT x, y), STRUCT (INT x, y, z)), 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     -(LOC REF PROC PROC (REAL, INT) VOID :=var), 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     - BEGIN [, , ][] BOOL tb= 4r1230321; tb END, 
   IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI 
     - IF [1, 1, 1]  BITS tb; b THEN tb ELSE 8r0 FI, 
   SKIP); FOR i TO vf DO (tc[i] | print(("err.2", i))) OD; 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error"))) END; 
  
  ######
  # r71b #
  (print((newline, "Independence of operators in different ranges: ")); 
   INT vf = 17; 
   INT ctr:= 0; 
   BOOL b = TRUE; 
   MODE M = STRUCT (CHAR e1, REF M e2); 
   PRIO  +> = 1, 
   OP   +> = (BOOL b) REF BOOL : HEAP BOOL :=b, 
       +> = (BOOL a, REF BOOL b) INT :ctr+:= (b | 0 | 1); 
  
  b+>+> FALSE; 
  
  (
      OP   +> = (INT a) INT :1
  , PRIO   +> = 2
  , OP   +> = (REAL a, b) INT :6
  ;  OP   +> = (INT a, b) INT :4
  , +> = (REAL a) INT :5
  ; b+>+> FALSE; 
   SKIP); 
   IF 
      OP   +> = (M a) INT :4
  , PRIO   +> = 1
  , OP   +> = (STRUCT (CHAR e1, 
            REF STRUCT (CHAR e1, REF M e)e2) a, b) INT :9
  ;  OP   +> = (M a, b) INT :2
  , +> = (STRUCT (CHAR e1, 
            REF STRUCT (CHAR e1, REF M e)e2) a) INT :7
  ; b+>+> FALSE; 
  b
   THEN 
      OP   +> = (PROC (INT, REAL) VOID a) INT :1
  , PRIO   +> = 6
  , OP   +> = (PROC (REAL, INT) VOID a, b) INT :2
  ;  OP   +> = (PROC (INT, REAL) VOID a, b) INT :6
  , +> = (PROC (REAL, INT) VOID a) INT :3
  ; b+>+> FALSE; 
   SKIP 
   ELSE 
      OP   +> = (STRUCT (INT x, y)a) INT :5
  , PRIO   +> = 6
  , OP   +> = (STRUCT (INT y, x) a, b) INT :2
  ;  OP   +> = (STRUCT (INT x, y) a, b) INT :8
  , +> = (STRUCT (INT y, x) a) INT :8
  ; b+>+> FALSE; 
   SKIP FI; 
   TO  1  WHILE 
      OP   +> = (PROC (INT, REAL) VOID a) INT :7
  , PRIO   +> = 6
  , OP   +> = (UNION (PROC (REAL, INT) VOID, 
            PROC (INT, REAL) INT) a, b) INT :6
  ;  OP   +> = (PROC (INT, REAL) VOID a, b) INT :5
  , +> = (UNION (PROC (REAL, INT) VOID, 
            PROC (INT, REAL) INT) a) INT :6
  ; b+>+> FALSE; 
  b
   DO 
      OP   +> = (UNION (PROC (INT, REAL) INT, 
            PROC (REAL, INT) INT)a) INT :3
  , PRIO   +> = 4
  , OP   +> = (UNION (PROC (REAL, INT) VOID, 
            PROC (INT, INT) INT) a, b) INT :3
  ;  OP   +> = (UNION (PROC (INT, REAL) INT, 
            PROC (REAL, INT) INT) a, b) INT :6
  , +> = (UNION (PROC (REAL, INT) VOID, 
            PROC (INT, INT) INT) a) INT :9
  ; b+>+> FALSE; 
   SKIP OD; 
  (
      OP   +> = (UNION (STRUCT (INT y, x), 
            STRUCT (INT x, y))a) INT :4
  , PRIO   +> = 4
  , OP   +> = (UNION (STRUCT (REAL x, y), 
            STRUCT (REAL y, x)) a, b) INT :6
  ;  OP   +> = (UNION (STRUCT (INT y, x), 
            STRUCT (INT x, y)) a, b) INT :7
  , +> = (UNION (STRUCT (REAL x, y), 
            STRUCT (REAL y, x)) a) INT :1
  ; b+>+> FALSE; 
   SKIP); 
   IF 
      OP   +> = (CHAR a) INT :8
  , PRIO   +> = 8
  , OP   +> = (REF REF PROC REF PROC [ ] CHAR a, b) INT :5
  ;  OP   +> = (CHAR a, b) INT :6
  , +> = (REF REF PROC REF PROC [ ] CHAR a) INT :4
  ; b+>+> FALSE; 
  b
   THEN 
      OP   +> = (PROC (INT, REAL) INT a) INT :7
  , PRIO   +> = 4
  , OP   +> = (INT a, b) INT :2
  ;  OP   +> = (PROC (INT, REAL) INT a, b) INT :8
  , +> = (INT a) INT :7
  ; b+>+> FALSE; 
   SKIP 
   ELSE 
      OP   +> = (REF PROC REF M a) INT :8
  , PRIO   +> = 8
  , OP   +> = (REF PROC M a, b) INT :3
  ;  OP   +> = (REF PROC REF M a, b) INT :6
  , +> = (REF PROC M a) INT :6
  ; b+>+> FALSE; 
   SKIP FI; 
   TO  1  WHILE 
      OP   +> = (PROC BOOL a) INT :6
  , PRIO   +> = 7
  , OP   +> = (REF BOOL a, b) INT :5
  ;  OP   +> = (PROC BOOL a, b) INT :4
  , +> = (REF BOOL a) INT :3
  ; b+>+> FALSE; 
  b
   DO 
      OP   +> = (REF PROC INT a) INT :3
  , PRIO   +> = 4
  , OP   +> = (COMPL a, b) INT :5
  ;  OP   +> = (REF PROC INT a, b) INT :4
  , +> = (COMPL a) INT :9
  ; b+>+> FALSE; 
   SKIP OD; 
  (
      OP   +> = (REAL a) INT :5
  , PRIO   +> = 3
  , OP   +> = (COMPL a, b) INT :6
  ;  OP   +> = (REAL a, b) INT :3
  , +> = (COMPL a) INT :2
  ; b+>+> FALSE; 
   SKIP); 
   IF 
      OP   +> = (INT a) INT :6
  , PRIO   +> = 5
  , OP   +> = (REF COMPL a, b) INT :4
  ;  OP   +> = (INT a, b) INT :1
  , +> = (REF COMPL a) INT :8
  ; b+>+> FALSE; 
  b
   THEN 
      OP   +> = ([] BOOL a) INT :3
  , PRIO   +> = 2
  , OP   +> = (BITS a, b) INT :3
  ;  OP   +> = ([] BOOL a, b) INT :3
  , +> = (BITS a) INT :4
  ; b+>+> FALSE; 
   SKIP 
   ELSE 
      MODE BITES = STRUCT  (INT n, [1 : 4]  CHAR text); 
      OP   +> = ([] CHAR a) INT :3
  , PRIO   +> = 7
  , OP   +> = (BITES a, b) INT :9
  ;  OP   +> = ([] CHAR a, b) INT :8
  , +> = (BITES a) INT :7
  ; b+>+> FALSE; 
   SKIP FI; 
   TO  1  WHILE 
      OP   +> = ([ ] REAL a) INT :5
  , PRIO   +> = 3
  , OP   +> = (REAL a, b) INT :2
  ;  OP   +> = ([ ] REAL a, b) INT :1
  , +> = (REAL a) INT :1
  ; b+>+> FALSE; 
  b
   DO 
      OP   +> = ([, , ][ ] M a) INT :3
  , PRIO   +> = 2
  , OP   +> = (M a, b) INT :1
  ;  OP   +> = ([, , ][ ] M a, b) INT :3
  , +> = (M a) INT :8
  ; b+>+> FALSE; 
   SKIP OD; 
  b+>+> FALSE; 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  ######
  # r72a #
  (print((newline, "Identification (identifiers from ", 
  "identity declaration, variable, case on union, loop index): ")); 
   INT nbcas = 9; 
   INT vf = 11*(48+5*nbcas); 
   INT ctr:= 0, ctrt; 
   MODE M = STRUCT (CHAR c, INT de), 
          UNE = UNION (STRING, INT); 
  
  # procedures de controle #
   PROC ce = (INT a, b) VOID : (a=b | ctr+:= 1 | 
          print(("test n0", ctrt, " error :", a, b, newline))); 
   PROC t = (M de, INT vrai) VOID : ce(de OF de, vrai); 
  
  # declarations de servitude #
   INT valk:= 0-1, 
  [] UNE rune= ("vide", "", 1, SKIP); 
   OP  - = (UNE a) INT : (a | (STRING):0, (INT a) : 0-a), 
   STRUCT (UNE deux, STRUCT (UNE de)de)de := (0, 
      (STRUCT (UNE de) of; de OF of:=rune[2]; of)); 
  
  # declarations et tests initiaux #
  
     # bloc  0 #
     M j= ("m", 109);  M i= ("m", 108);  M h:= ("m", 107);  M g= ("m", 106); 
   M f= ("m", 105);  M e= ("m", 104);  M d= ("m", 103);  M c:= ("m", 102); 
   M b= ("m", 101);  M a:= ("m", 100); 
     INT k = 999; 
    ctrt:= 1
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105); t(e, 
   104); t(d, 103); t(c, 102); t(b, 101); t(a, 100)
  ; IF 
       # bloc  1 #
       M b= ("m", 111);  M c:= ("m", 112); 
      ctrt:= 2
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105); t(
  e, 104); t(d, 103); t(c, 112); t(b, 111); t(a, 100)
  ; FALSE THEN SKIP 
       ELIF 
         # bloc  2 #  UNE declident = (
           # bloc  3 #
           M c= ("m", 122);  M d:= ("m", 123); 
          ctrt:= 3
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 104); t(d, 123); t(c, 122); t(b, 111); t(a, 100)
           # fin  3 #
  ; ""); 
                UNE declvariable := (
           # bloc  3 #
           M c= ("m", 222);  M d:= ("m", 223); 
          ctrt:= 4
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 104); t(d, 223); t(c, 222); t(b, 111); t(a, 100)
  ; (
             # bloc  4 #
             M d= ("m", 233);  M e:= ("m", 234); 
            ctrt:= 5
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 234); t(d, 233); t(c, 222); t(b, 111); t(a, 100)
             # fin  4 #
  ; "") # fin  3 #
  ); 
         M c= ("m", 322);  M d:= ("m", 323); 
        ctrt:= 6
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105); 
  t(e, 104); t(d, 323); t(c, 322); t(b, 111); t(a, 100)
  ; TRUE THEN 
           # bloc  3 #
          ctrt:= 7
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 104); t(d, 323); t(c, 322); t(b, 111); t(a, 100)
  ; CASE 
             # bloc  4 #  M valu= ("m", 345); 
             UNION (UNE, M, STRUCT (CHAR c, INT d)) u:=valu; 
             M d= ("m", 333);  M e:= ("m", 334); 
            ctrt:= 8
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 334); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; e:= ("m", 344); u
                   IN  (
               # bloc  5 #  M f) : ((
              ctrt:= 9
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 
   345); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ), (
                 # bloc  6 #
                 M f= ("m", 355);  M g:= ("m", 356); 
                ctrt:= 10
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 356); t(f, 
   355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; FOR 
                   # bloc  7 #  k FROM  (
                   M g= ("m", 466);  M h:= ("m", 467); 
                  ctrt:= 11
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 467); t(g, 466); t(
  f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; 0)  TO nbcas
                      WHILE 
                     # bloc  8 #  valk+:= 1; 
                     M g= ("m", 366);  M h:= ("m", 367); 
                    ctrt:= 12
  ; ce(k, valk); t(j, 109); t(i, 108); t(h, 367); t(g, 366
  ); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; TRUE    DO 
                       # bloc  9 #
                       M h= ("m", 377);  M i:= ("m", 378); 
                      ctrt:= 13
  ; ce(k, valk); t(j, 109); t(i, 378); t(h, 377); t(g, 366
  ); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; CASE 
                         # bloc 10 #
                         M i= ("m", 388);  M j:= ("m", 389); 
                        ctrt:= 14
  ; ce(k, valk); t(j, 389); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; k IN 
                        #k= 1# (
                           # bloc 11 #
                           M j= ("m", 199); 
                          ctrt:= 15
  ; ce(k, valk); t(j, 199); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                           # fin 11 #
  ), 
                        #k= 2#  TO  (
                         M j= ("m", 299); 
                        ctrt:= 16
  ; ce(k, valk); t(j, 299); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; 1)  DO 
                        ctrt:= 17
  ; ce(k, valk); t(j, 389); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                         OD, 
                        #k= 3# (
                         M j= ("m", 399); 
                        ctrt:= 18
  ; ce(k, valk); t(j, 399); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; HEAP UNE) := (
                         M j= ("m", 499); 
                        ctrt:= 19
  ; ce(k, valk); t(j, 499); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; ""), 
                        #k= 4# (
                         M j= ("m", 599); 
                        ctrt:= 20
  ; ce(k, valk); t(j, 599); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; rune) [2 : (
                         M j= ("m", 699); 
                        ctrt:= 21
  ; ce(k, valk); t(j, 699); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; 3) @ (
                         M j= ("m", 799); 
                        ctrt:= 22
  ; ce(k, valk); t(j, 799); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; 1) ], 
                        #k= 5# ((UNE x, y) VOID : (
                         M j= ("m", 899); 
                        ctrt:= 23
  ; ce(k, valk); t(j, 899); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ))((
                         M j= ("m", 999); 
                        ctrt:= 24
  ; ce(k, valk); t(j, 999); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; ""), SKIP), 
                        #k= 6#  LOC UNE :=: (
                         M j= ("m", 1099); 
                        ctrt:= 25
  ; ce(k, valk); t(j, 1099); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; HEAP UNE), 
                        #k= 7#   1+-(
                         M j= ("m", 1199); 
                        ctrt:= 26
  ; ce(k, valk); t(j, 1199); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; ""), 
                        #k= 8# de OF de OF (
                         M j= ("m", 1299); 
                        ctrt:= 27
  ; ce(k, valk); t(j, 1299); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; de), 
                        #k= 9#  UNE  (
                         M j= ("m", 1399); 
                        ctrt:= 28
  ; ce(k, valk); t(j, 1399); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; "")     OUT 
                           # bloc 11 #
                          # k= 0 #
                           M j= ("m", 1499); 
                          ctrt:= 29
  ; ce(k, valk); t(j, 1499); t(i, 388); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                           # fin 11 #
                         # fin 10 #
                       ESAC; 
                       IF 
                         # bloc 10 #
                        ctrt:= 30
  ; ce(k, valk); t(j, 109); t(i, 378); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; k = 1  THEN 
                           # bloc 11 #
                           M i= ("m", 88);  M j:= ("m", 89); 
                          ctrt:= 31
  ; ce(k, valk); t(j, 89); t(i, 88); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; CASE 
                             # bloc 12 #  UNE u:= (
                            ctrt:= 32
  ; ce(k, valk); t(j, 89); t(i, 88); t(h, 377); t(g
  , 366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; ""); u
                              IN  (INT) :  SKIP OUSE 
                               # bloc 13 #
                               M j= ("m", 99); 
                              ctrt:= 33
  ; ce(k, valk); t(j, 99); t(i, 88); t(h, 377); 
  t(g, 366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ; u IN (STRING) : (
                              ctrt:= 34
  ; ce(k, valk); t(j, 99); t(i, 88); t(h, 377); 
  t(g, 366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  ) # fin 13 #
                             # fin 12 #
                           ESAC; 
                          ctrt:= 35
  ; ce(k, valk); t(j, 89); t(i, 88); t(h, 377); t(g, 
   366); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                           # fin 11 #
                         # fin 10 #
                       FI; 
                      ctrt:= 36
  ; ce(k, valk); t(j, 109); t(i, 378); t(h, 377); t(g, 366
  ); t(f, 355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                       # fin  9 #
                     # fin  8 #
                   # fin  7 #
                 OD; 
                ctrt:= 37
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 356); t(f, 
   355); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
                 # fin  6 #
  ), (
              ctrt:= 38
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 
   345); t(e, 344); t(d, 333); t(c, 322); t(b, 111); t(a, 100)
  )) # fin  5 #
             # fin  4 #
           ESAC; 
          (
             # bloc  4 #  UNE u= (
            ctrt:= 39
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 104); t(d, 323); t(c, 322); t(b, 111); t(a, 100)
  ; ""); u | (INT) :  SKIP  | 
               # bloc  5 #
               M d= ("m", 433);  M e:= ("m", 434); 
              ctrt:= 40
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 
   105); t(e, 434); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
  ; (
                 # bloc  6 # [ (
                   # bloc  7 #
                   M e= ("m", 444);  M f:= ("m", 445); 
                  ctrt:= 41
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(
  f, 445); t(e, 444); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
  ; 0 # fin  7 #
  ) : 0]  UNE u; LWB u< UPB u |  SKIP  | 
                   # bloc  7 #
                   M e= ("m", 544);  M f:= ("m", 545); 
                  ctrt:= 42
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(
  f, 545); t(e, 544); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
  ; (
                     # bloc  8 # 0 | 1, SKIP |:
                       # bloc  9 #
                       M f= ("m", 555);  M g:= ("m", 556); 
                      ctrt:= 43
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 556
  ); t(f, 555); t(e, 544); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
  ; 2 |  SKIP, (
                      ctrt:= 44
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 556
  ); t(f, 555); t(e, 544); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
  ) # fin  9 #
                     # fin  8 #
  ); 
                  ctrt:= 45
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(
  f, 545); t(e, 544); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
                   # fin  7 #
                 # fin  6 #
  ); 
              ctrt:= 46
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 
   105); t(e, 434); t(d, 433); t(c, 322); t(b, 111); t(a, 100)
               # fin  5 #
             # fin  4 #
  ); 
          ctrt:= 47
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105
  ); t(e, 104); t(d, 323); t(c, 322); t(b, 111); t(a, 100)
           # fin  3 #
         # fin  2 #
       # fin  1 #
     FI; 
    ctrt:= 48
  ; ce(k, 999); t(j, 109); t(i, 108); t(h, 107); t(g, 106); t(f, 105); t(e, 
   104); t(d, 103); t(c, 102); t(b, 101); t(a, 100)
     # fin  0 #
  
  ; print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r8 #   # reads 2 cards #
  (print((newline, "Denotations (")); 
   INT vf = 70; 
   PRIO   ?=:= = 1; 
  #tests syntaxiques#
  # BOOL #
  ((FALSE; SKIP; 
       FALSE; FALSE); 
  (FALSE, SKIP, 
       FALSE, FALSE); 
   STRUCT (BOOL a, b, c, d) a=
      (FALSE, SKIP, 
          FALSE, FALSE); 
  [] BOOL b= (FALSE, SKIP, 
       FALSE, FALSE); 
   CASE  3  IN FALSE, SKIP, 
       FALSE, FALSE 
            OUT FALSE ESAC; 
  (UNION (REF BOOL, PROC BOOL)a:= HEAP BOOL 
  ; a | (REF BOOL): FALSE); 
   BOOL d= FALSE; 
   BOOL v, vv:= FALSE; v:= FALSE; 
   PROC pp= (BOOL a, b) BOOL : FALSE 
  ; pp(FALSE, FALSE); 
   OP  ?=:= = (BOOL a, b) BOOL :b, 
      ?=:== (BOOL a) BOOL :a; 
  ?=:= FALSE ?=:=?=:=?=:= FALSE ?=:= FALSE); 
  # INT #
  ((2147483647; SKIP; 
      2147483647; 2147483647); 
  (2147483647, SKIP, 
      2147483647, 2147483647); 
   STRUCT (INT a, b, c, d) a=
      (2147483647, SKIP, 
         2147483647, 2147483647); 
  [] INT b= (2147483647, SKIP, 
      2147483647, 2147483647); 
   CASE  3  IN 2147483647, SKIP, 
      2147483647, 2147483647
            OUT 2147483647 ESAC; 
  (UNION (REF INT, PROC INT)a:= HEAP INT 
  ; a | (REF INT):2147483647); 
   INT d= 2147483647; 
   INT v, vv:= 2147483647; v:= 2147483647; 
   PROC pp= (INT a, b) INT :2147483647
  ; pp(2147483647, 2147483647); 
   OP  ?=:= = (INT a, b) INT :b, 
      ?=:== (INT a) INT :a; 
  ?=:= 2147483647?=:=?=:=?=:= 2147483647?=:= 2147483647); 
  # REAL #
  ((-1e-00000; SKIP; 
      -1e-00000; -1e-00000); 
  (-1e-00000, SKIP, 
      -1e-00000, -1e-00000); 
   STRUCT (REAL a, b, c, d) a=
      (-1e-00000, SKIP, 
         -1e-00000, -1e-00000); 
  [] REAL b= (-1e-00000, SKIP, 
      -1e-00000, -1e-00000); 
   CASE  3  IN -1e-00000, SKIP, 
      -1e-00000, -1e-00000
            OUT -1e-00000 ESAC; 
  (UNION (REF REAL, PROC REAL)a:= HEAP REAL 
  ; a | (REF REAL):-1e-00000); 
   REAL d=-1e-00000; 
   REAL v, vv:=-1e-00000; v:=-1e-00000; 
   PROC pp= (REAL a, b) REAL :-1e-00000
  ; pp(-1e-00000, -1e-00000); 
   OP  ?=:= = (REAL a, b) REAL :b, 
      ?=:== (REAL a) REAL :a; 
  ?=:=-1e-00000?=:=?=:=?=:=-1e-00000?=:=-1e-00000); 
  # CHAR #
  ((""""; SKIP; 
      """"; """"); 
  ("""", SKIP, 
      """", """"); 
   STRUCT (CHAR a, b, c, d) a=
      ("""", SKIP, 
         """", """"); 
  [] CHAR b= ("""", SKIP, 
      """", """"); 
   CASE  3  IN """", SKIP, 
      """", """"
            OUT """" ESAC; 
  (UNION (REF CHAR, PROC CHAR)a:= HEAP CHAR 
  ; a | (REF CHAR):""""); 
   CHAR d=""""; 
   CHAR v, vv:=""""; v:=""""; 
   PROC pp= (CHAR a, b) CHAR :""""
  ; pp("""", """"); 
   OP  ?=:= = (CHAR a, b) CHAR :b, 
      ?=:== (CHAR a) CHAR :a; 
  ?=:=""""?=:=?=:=?=:=""""?=:=""""); 
  # COMPL #
  ((001 I -02; SKIP; 
      001 I -02; 001 I -02); 
  (001 I -02, SKIP, 
      001 I -02, 001 I -02); 
   STRUCT (COMPL a, b, c, d) a=
      (001 I -02, SKIP, 
         001 I -02, 001 I -02); 
  [] COMPL b= (001 I -02, SKIP, 
      001 I -02, 001 I -02); 
   CASE  3  IN 001 I -02, SKIP, 
      001 I -02, 001 I -02
            OUT 001 I -02 ESAC; 
  (UNION (REF COMPL, PROC COMPL)a:= HEAP COMPL 
  ; a | (REF COMPL):001 I -02); 
   COMPL d= 001 I -02; 
   COMPL v, vv:= 001 I -02; v:= 001 I -02; 
   PROC pp= (COMPL a, b) COMPL :001 I -02
  ; pp(001 I -02, 001 I -02); 
   OP  ?=:= = (COMPL a, b) COMPL :b, 
      ?=:== (COMPL a) COMPL :a; 
  ?=:= (001 I -02)?=:=?=:=?=:= (001 I -02)?=:= (001 I -02)); 
  # BITS #
  ((8r7054; SKIP; 
      8r7054; 8r7054); 
  (8r7054, SKIP, 
      8r7054, 8r7054); 
   STRUCT (BITS a, b, c, d) a=
      (8r7054, SKIP, 
         8r7054, 8r7054); 
  [] BITS b= (8r7054, SKIP, 
      8r7054, 8r7054); 
   CASE  3  IN 8r7054, SKIP, 
      8r7054, 8r7054
            OUT 8r7054 ESAC; 
  (UNION (REF BITS, PROC BITS)a:= HEAP BITS 
  ; a | (REF BITS):8r7054); 
   BITS d= 8r7054; 
   BITS v, vv:= 8r7054; v:= 8r7054; 
   PROC pp= (BITS a, b) BITS :8r7054
  ; pp(8r7054, 8r7054); 
   OP  ?=:= = (BITS a, b) BITS :b, 
      ?=:== (BITS a) BITS :a; 
  ?=:= 8r7054?=:=?=:=?=:= 8r7054?=:= 8r7054); 
  # STRING #
  (("#("" END #"; SKIP; 
      "#("" END #"; "#("" END #"); 
  ("#("" END #", SKIP, 
      "#("" END #", "#("" END #"); 
   STRUCT (STRING a, b, c, d) a=
      ("#("" END #", SKIP, 
         "#("" END #", "#("" END #"); 
  [] STRING b= ("#("" END #", SKIP, 
      "#("" END #", "#("" END #"); 
   CASE  3  IN "#("" END #", SKIP, 
      "#("" END #", "#("" END #"
            OUT "#("" END #" ESAC; 
  (UNION (REF STRING, PROC STRING)a:= HEAP STRING 
  ; a | (REF STRING):"#("" END #"); 
   STRING d="#("" END #"; 
   STRING v, vv:="#("" END #"; v:="#("" END #"; 
   PROC pp= (STRING a, b) STRING :"#("" END #"
  ; pp("#("" END #", "#("" END #"); 
   OP  ?=:= = (STRING a, b) STRING :b, 
      ?=:= = (STRING a) STRING :a; 
  ?=:="#("" END #"?=:=?=:=?=:="#("" END #"?=:="#("" END #"); 
  
  #tests semantiques#    INT ctr:= 0; 
  print(("BOOL")); 
  
  ctr+:= ABS TRUE +1- ABS FALSE; 
  
  print((", INT")); 
  
  print((", REAL")); 
  
  print((", CHAR")); 
  [] CHAR k = (
  "#", "@", ",", "?", "$", "*", ".", "<", "-", "+", 
  "a", " ", "z", ")", "e", "[", "r", "t", "|"
  , "y", "1", "u", "2", "i", "3", "o", "&", "p", "0"
  , "/", "q", ">", "s", ":", "d", ";", "f", "^", "g"
  , "'", "h", "4", "j", "5", "k", "6", "l", "w", "?"
  , "x", """", "c", "=", "v", "]", "b", "(", "n", "7", "m", "8", "9", " "); 
  [1: UPB k] CHAR l; FOR i TO UPB k DO 
  l[i]:=k[i]; 
      (k[i] = l[i] | ctr+:= 1 | print("err.char"))  OD; 
  
  print((", COMPL")); 
  (ABS (-2*re OF COMPL (-00001, 002)-
       IM COMPL (-000001, 0000000000000000000002)) > .001
       | print("err.compl") | ctr+:= 1); 
  
  print((", BITS")); 
  (2r101010111100110111101111/= 16rabcdef | print("err.bits")
   |:8r3377337733/= 4r123333123233123 | ctr+:= 1 | print("err.bits")); 
  
  print((", STRING")); 
   STRING s := "string"; 
  (s = "string" | ctr +:= 1 | print("err.string")); 
  s := "gnirts"; 
  (s = "gnirts" | ctr +:= 1 | print("err.string")); 
   
  print((", VOID): ")); 
  (UNION (BYTES, VOID) u:= EMPTY; u | 
      (VOID) : ctr+:= 1 | print("err.void")); 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r811 #
  (print((newline, "Integral denotations: ")); 
   INT vf = 258; 
   INT ctr:= 0; 
   PROC e = (INT a, b) VOID :
      (a=b | ctr+:= 1 | print(("er int", a, b, newline))); 
  
  e(1+255, 256); 
  e(1+256, 257); 
  e(1+4095, 4096); 
  e(1+10000, 10001); 
  e(1+32768, 32769); 
  e(1-255, -254); 
  e(1-256, -255); 
  e(1-4095, -4094); 
  e(1-10000, -9999); 
  e(1-32768, -32767); 
  e(1*255, 255); 
  e(1*256, 256); 
  e(1*4095, 4095); 
  e(1*10000, 10000); 
  e(1*32768, 32768); 
  e(0+255, 255); 
  e(0+256, 256); 
  e(0+4095, 4095); 
  e(0+10000, 10000); 
  e(0+32768, 32768); 
  e(0-255, -255); 
  e(0-256, -256); 
  e(0-4095, -4095); 
  e(0-10000, -10000); 
  e(0-32768, -32768); 
  e(0*255, 0); 
  e(0*256, 0); 
  e(0*4095, 0); 
  e(0*10000, 0); 
  e(0*32768, 0); 
  e(0000+255, 255); 
  e(0000+256, 256); 
  e(0000+4095, 4095); 
  e(0000+10000, 10000); 
  e(0000+32768, 32768); 
  e(0000-255, -255); 
  e(0000-256, -256); 
  e(0000-4095, -4095); 
  e(0000-10000, -10000); 
  e(0000-32768, -32768); 
  e(0000*255, 0); 
  e(0000*256, 0); 
  e(0000*4095, 0); 
  e(0000*10000, 0); 
  e(0000*32768, 0); 
  e(4+255, 259); 
  e(4+256, 260); 
  e(4+4095, 4099); 
  e(4+10000, 10004); 
  e(4+32768, 32772); 
  e(4-255, -251); 
  e(4-256, -252); 
  e(4-4095, -4091); 
  e(4-10000, -9996); 
  e(4-32768, -32764); 
  e(4*255, 1020); 
  e(4*256, 1024); 
  e(4*4095, 16380); 
  e(4*10000, 40000); 
  e(4*32768, 131072); 
  e(10+255, 265); 
  e(10+256, 266); 
  e(10+4095, 4105); 
  e(10+10000, 10010); 
  e(10+32768, 32778); 
  e(10-255, -245); 
  e(10-256, -246); 
  e(10-4095, -4085); 
  e(10-10000, -9990); 
  e(10-32768, -32758); 
  e(10*255, 2550); 
  e(10*256, 2560); 
  e(10*4095, 40950); 
  e(10*10000, 100000); 
  e(10*32768, 327680); 
  e(16+255, 271); 
  e(16+256, 272); 
  e(16+4095, 4111); 
  e(16+10000, 10016); 
  e(16+32768, 32784); 
  e(16-255, -239); 
  e(16-256, -240); 
  e(16-4095, -4079); 
  e(16-10000, -9984); 
  e(16-32768, -32752); 
  e(16*255, 4080); 
  e(16*256, 4096); 
  e(16*4095, 65520); 
  e(16*10000, 160000); 
  e(16*32768, 524288); 
  e(64+255, 319); 
  e(64+256, 320); 
  e(64+4095, 4159); 
  e(64+10000, 10064); 
  e(64+32768, 32832); 
  e(64-255, -191); 
  e(64-256, -192); 
  e(64-4095, -4031); 
  e(64-10000, -9936); 
  e(64-32768, -32704); 
  e(64*255, 16320); 
  e(64*256, 16384); 
  e(64*4095, 262080); 
  e(64*10000, 640000); 
  e(64*32768, 2097152); 
  e(00011+255, 266); 
  e(00011+256, 267); 
  e(00011+4095, 4106); 
  e(00011+10000, 10011); 
  e(00011+32768, 32779); 
  e(00011-255, -244); 
  e(00011-256, -245); 
  e(00011-4095, -4084); 
  e(00011-10000, -9989); 
  e(00011-32768, -32757); 
  e(00011*255, 2805); 
  e(00011*256, 2816); 
  e(00011*4095, 45045); 
  e(00011*10000, 110000); 
  e(00011*32768, 360448); 
  e(255+1, 256); 
  e(255+0, 255); 
  e(255+0000, 255); 
  e(255+4, 259); 
  e(255+10, 265); 
  e(255+16, 271); 
  e(255+64, 319); 
  e(255+00011, 266); 
  e(255-1, 254); 
  e(255-0, 255); 
  e(255-0000, 255); 
  e(255-4, 251); 
  e(255-10, 245); 
  e(255-16, 239); 
  e(255-64, 191); 
  e(255-00011, 244); 
  e(255*1, 255); 
  e(255*0, 0); 
  e(255*0000, 0); 
  e(255*4, 1020); 
  e(255*10, 2550); 
  e(255*16, 4080); 
  e(255*64, 16320); 
  e(255*00011, 2805); 
  e(256+1, 257); 
  e(256+0, 256); 
  e(256+0000, 256); 
  e(256+4, 260); 
  e(256+10, 266); 
  e(256+16, 272); 
  e(256+64, 320); 
  e(256+00011, 267); 
  e(256-1, 255); 
  e(256-0, 256); 
  e(256-0000, 256); 
  e(256-4, 252); 
  e(256-10, 246); 
  e(256-16, 240); 
  e(256-64, 192); 
  e(256-00011, 245); 
  e(256*1, 256); 
  e(256*0, 0); 
  e(256*0000, 0); 
  e(256*4, 1024); 
  e(256*10, 2560); 
  e(256*16, 4096); 
  e(256*64, 16384); 
  e(256*00011, 2816); 
  e(4095+1, 4096); 
  e(4095+0, 4095); 
  e(4095+0000, 4095); 
  e(4095+4, 4099); 
  e(4095+10, 4105); 
  e(4095+16, 4111); 
  e(4095+64, 4159); 
  e(4095+00011, 4106); 
  e(4095-1, 4094); 
  e(4095-0, 4095); 
  e(4095-0000, 4095); 
  e(4095-4, 4091); 
  e(4095-10, 4085); 
  e(4095-16, 4079); 
  e(4095-64, 4031); 
  e(4095-00011, 4084); 
  e(4095*1, 4095); 
  e(4095*0, 0); 
  e(4095*0000, 0); 
  e(4095*4, 16380); 
  e(4095*10, 40950); 
  e(4095*16, 65520); 
  e(4095*64, 262080); 
  e(4095*00011, 45045); 
  e(10000+1, 10001); 
  e(10000+0, 10000); 
  e(10000+0000, 10000); 
  e(10000+4, 10004); 
  e(10000+10, 10010); 
  e(10000+16, 10016); 
  e(10000+64, 10064); 
  e(10000+00011, 10011); 
  e(10000-1, 9999); 
  e(10000-0, 10000); 
  e(10000-0000, 10000); 
  e(10000-4, 9996); 
  e(10000-10, 9990); 
  e(10000-16, 9984); 
  e(10000-64, 9936); 
  e(10000-00011, 9989); 
  e(10000*1, 10000); 
  e(10000*0, 0); 
  e(10000*0000, 0); 
  e(10000*4, 40000); 
  e(10000*10, 100000); 
  e(10000*16, 160000); 
  e(10000*64, 640000); 
  e(10000*00011, 110000); 
  e(32768+1, 32769); 
  e(32768+0, 32768); 
  e(32768+0000, 32768); 
  e(32768+4, 32772); 
  e(32768+10, 32778); 
  e(32768+16, 32784); 
  e(32768+64, 32832); 
  e(32768+00011, 32779); 
  e(32768-1, 32767); 
  e(32768-0, 32768); 
  e(32768-0000, 32768); 
  e(32768-4, 32764); 
  e(32768-10, 32758); 
  e(32768-16, 32752); 
  e(32768-64, 32704); 
  e(32768-00011, 32757); 
  e(32768*1, 32768); 
  e(32768*0, 0); 
  e(32768*0000, 0); 
  e(32768*4, 131072); 
  e(32768*10, 327680); 
  e(32768*16, 524288); 
  e(32768*64, 2097152); 
  e(32768*00011, 360448); 
  e(1+131001, 131002); 
  e(1+1000000000, 1000000001); 
  e(1+2147483646, 2147483647); 
  e(1-131001, -131000); 
  e(1-1000000000, -999999999); 
  e(1-2147483646, -2147483645); 
  e(1*131001, 131001); 
  e(1*1000000000, 1000000000); 
  e(1*2147483646, 2147483646); 
  e(131001+1, 131002); 
  e(131001-1, 131000); 
  e(131001*1, 131001); 
  e(1000000000+1, 1000000001); 
  e(1000000000-1, 999999999); 
  e(1000000000*1, 1000000000); 
  e(2147483646+1, 2147483647); 
  e(2147483646-1, 2147483645); 
  e(2147483646*1, 2147483646); 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests ", (ctr=(to test +:= vf; vf) | "ok" | "error")))); 
  
  # r812 #
  (print((newline, "Real denotations: ")); 
   INT vf = 704; 
   INT ctr:= 0, ct:= 0; 
   REAL erc:= 0, super:= 0, er; 
   PROC r = (REAL a, b) VOID :
      ((b= 0 | a= 0 | (er:= ABS ((a-b)/b))<1e-5)
           | ctr+:= 1; (b/= 0 | ct+:= 1; erc+:=er; (er>super | super:=er))
           | print(("er real", a, b, newline))); 
  
  r(.1*2.73801, 2.7380079e-01); 
  r(.1e1*2.73801, 2.7380094e+00); 
  r(.1e+0*2.73801, 2.7380079e-01); 
  r(.1e-0000*2.73801, 2.7380079e-01); 
  r(.1e4*2.73801, 2.7380092e+03); 
  r(.1e+10*2.73801, 2.7380093e+09); 
  r(.1e-16*2.73801, 2.7380088e-17); 
  r(.1e64*2.73801, 2.7380090e+63); 
  r(.1e+00011*2.73801, 2.7380088e+10); 
  r(.0*2.73801, 0.0000000e+00); 
  r(.0e-1*2.73801, 0.0000000e+00); 
  r(.0e0*2.73801, 0.0000000e+00); 
  r(.0e+0000*2.73801, 0.0000000e+00); 
  r(.0e-4*2.73801, 0.0000000e+00); 
  r(.0e10*2.73801, 0.0000000e+00); 
  r(.0e+16*2.73801, 0.0000000e+00); 
  r(.0e-64*2.73801, 0.0000000e+00); 
  r(.0e00011*2.73801, 0.0000000e+00); 
  r(.0000*2.73801, 0.0000000e+00); 
  r(.0000e+1*2.73801, 0.0000000e+00); 
  r(.0000e-0*2.73801, 0.0000000e+00); 
  r(.0000e0000*2.73801, 0.0000000e+00); 
  r(.0000e+4*2.73801, 0.0000000e+00); 
  r(.0000e-10*2.73801, 0.0000000e+00); 
  r(.0000e16*2.73801, 0.0000000e+00); 
  r(.0000e+64*2.73801, 0.0000000e+00); 
  r(.0000e-00011*2.73801, 0.0000000e+00); 
  r(.4*2.73801, 1.0952033e+00); 
  r(.4e1*2.73801, 1.0952037e+01); 
  r(.4e+0*2.73801, 1.0952033e+00); 
  r(.4e-0000*2.73801, 1.0952033e+00); 
  r(.4e4*2.73801, 1.0952035e+04); 
  r(.4e+10*2.73801, 1.0952036e+10); 
  r(.4e-16*2.73801, 1.0952035e-16); 
  r(.4e64*2.73801, 1.0952036e+64); 
  r(.4e+00011*2.73801, 1.0952035e+11); 
  r(.10*2.73801, 2.7380079e-01); 
  r(.10e-1*2.73801, 2.7380086e-02); 
  r(.10e0*2.73801, 2.7380079e-01); 
  r(.10e+0000*2.73801, 2.7380079e-01); 
  r(.10e-4*2.73801, 2.7380083e-05); 
  r(.10e10*2.73801, 2.7380093e+09); 
  r(.10e+16*2.73801, 2.7380091e+15); 
  r(.10e-64*2.73801, 2.7380081e-65); 
  r(.10e00011*2.73801, 2.7380088e+10); 
  r(.16*2.73801, 4.3808138e-01); 
  r(.16e+1*2.73801, 4.3808126e+00); 
  r(.16e-0*2.73801, 4.3808138e-01); 
  r(.16e0000*2.73801, 4.3808138e-01); 
  r(.16e+4*2.73801, 4.3808125e+03); 
  r(.16e-10*2.73801, 4.3808123e-11); 
  r(.16e16*2.73801, 4.3808145e+15); 
  r(.16e+64*2.73801, 4.3808148e+63); 
  r(.16e-00011*2.73801, 4.3808134e-12); 
  r(.64*2.73801, 1.7523250e+00); 
  r(.64e1*2.73801, 1.7523254e+01); 
  r(.64e+0*2.73801, 1.7523250e+00); 
  r(.64e-0000*2.73801, 1.7523250e+00); 
  r(.64e4*2.73801, 1.7523257e+04); 
  r(.64e+10*2.73801, 1.7523257e+10); 
  r(.64e-16*2.73801, 1.7523258e-16); 
  r(.64e64*2.73801, 1.7523257e+64); 
  r(.64e+00011*2.73801, 1.7523258e+11); 
  r(.00011*2.73801, 3.0118087e-04); 
  r(.00011e-1*2.73801, 3.0118098e-05); 
  r(.00011e0*2.73801, 3.0118087e-04); 
  r(.00011e+0000*2.73801, 3.0118087e-04); 
  r(.00011e-4*2.73801, 3.0118094e-08); 
  r(.00011e10*2.73801, 3.0118100e+06); 
  r(.00011e+16*2.73801, 3.0118080e+12); 
  r(.00011e-64*2.73801, 3.0118100e-68); 
  r(.00011e00011*2.73801, 3.0118096e+07); 
  r(.255*2.73801, 6.9819235e-01); 
  r(.255e+1*2.73801, 6.9819211e+00); 
  r(.255e-0*2.73801, 6.9819235e-01); 
  r(.255e0000*2.73801, 6.9819235e-01); 
  r(.255e+4*2.73801, 6.9819218e+03); 
  r(.255e-10*2.73801, 6.9819205e-11); 
  r(.255e16*2.73801, 6.9819203e+15); 
  r(.255e+64*2.73801, 6.9819198e+63); 
  r(.255e-00011*2.73801, 6.9819219e-12); 
  r(.256*2.73801, 7.0093035e-01); 
  r(.256e1*2.73801, 7.0093021e+00); 
  r(.256e+0*2.73801, 7.0093035e-01); 
  r(.256e-0000*2.73801, 7.0093035e-01); 
  r(.256e4*2.73801, 7.0093007e+03); 
  r(.256e+10*2.73801, 7.0093004e+09); 
  r(.256e-16*2.73801, 7.0093021e-17); 
  r(.256e64*2.73801, 7.0093005e+63); 
  r(.256e+00011*2.73801, 7.0092980e+10); 
  r(.4095*2.73801, 1.1212139e+00); 
  r(.4095e-1*2.73801, 1.1212146e-01); 
  r(.4095e0*2.73801, 1.1212139e+00); 
  r(.4095e+0000*2.73801, 1.1212139e+00); 
  r(.4095e-4*2.73801, 1.1212145e-04); 
  r(.4095e10*2.73801, 1.1212144e+10); 
  r(.4095e+16*2.73801, 1.1212145e+16); 
  r(.4095e-64*2.73801, 1.1212147e-64); 
  r(.4095e00011*2.73801, 1.1212147e+11); 
  r(.10000*2.73801, 2.7380079e-01); 
  r(.10000e+1*2.73801, 2.7380084e+00); 
  r(.10000e-0*2.73801, 2.7380079e-01); 
  r(.10000e0000*2.73801, 2.7380079e-01); 
  r(.10000e+4*2.73801, 2.7380085e+03); 
  r(.10000e-10*2.73801, 2.7380084e-11); 
  r(.10000e16*2.73801, 2.7380091e+15); 
  r(.10000e+64*2.73801, 2.7380090e+63); 
  r(.10000e-00011*2.73801, 2.7380077e-12); 
  r(.32768*2.73801, 8.9719086e-01); 
  r(.32768e1*2.73801, 8.9719066e+00); 
  r(.32768e+0*2.73801, 8.9719086e-01); 
  r(.32768e-0000*2.73801, 8.9719086e-01); 
  r(.32768e4*2.73801, 8.9719062e+03); 
  r(.32768e+10*2.73801, 8.9719070e+09); 
  r(.32768e-16*2.73801, 8.9719079e-17); 
  r(.32768e64*2.73801, 8.9719054e+63); 
  r(.32768e+00011*2.73801, 8.9719046e+10); 
  r(.131001*2.73801, 3.5868191e-01); 
  r(.131001e-1*2.73801, 3.5868193e-02); 
  r(.131001e0*2.73801, 3.5868191e-01); 
  r(.131001e+0000*2.73801, 3.5868191e-01); 
  r(.131001e-4*2.73801, 3.5868186e-05); 
  r(.131001e10*2.73801, 3.5868193e+09); 
  r(.131001e+16*2.73801, 3.5868192e+15); 
  r(.131001e-64*2.73801, 3.5868195e-65); 
  r(.131001e00011*2.73801, 3.5868188e+10); 
  r(.1000000000*2.73801, 2.7380079e-01); 
  r(.1000000000e+1*2.73801, 2.7380084e+00); 
  r(.1000000000e-0*2.73801, 2.7380079e-01); 
  r(.1000000000e0000*2.73801, 2.7380079e-01); 
  r(.1000000000e+4*2.73801, 2.7380085e+03); 
  r(.1000000000e-10*2.73801, 2.7380084e-11); 
  r(.1000000000e16*2.73801, 2.7380091e+15); 
  r(.1000000000e+64*2.73801, 2.7380090e+63); 
  r(.1000000000e-00011*2.73801, 2.7380077e-12); 
  r(.2147483646*2.73801, 5.8798289e-01); 
  r(.2147483646e1*2.73801, 5.8798274e+00); 
  r(.2147483646e+0*2.73801, 5.8798289e-01); 
  r(.2147483646e-0000*2.73801, 5.8798289e-01); 
  r(.2147483646e4*2.73801, 5.8798281e+03); 
  r(.2147483646e+10*2.73801, 5.8798284e+09); 
  r(.2147483646e-16*2.73801, 5.8798274e-17); 
  r(.2147483646e64*2.73801, 5.8798302e+63); 
  r(.2147483646e+00011*2.73801, 5.8798292e+10); 
  r(1.1*2.73801, 3.0118083e+00); 
  r(1.0e-1*2.73801, 2.7380079e-01); 
  r(1.10e0*2.73801, 3.0118083e+00); 
  r(1.4e+0000*2.73801, 3.8332118e+00); 
  r(1.4e-4*2.73801, 3.8332119e-04); 
  r(1.0000e10*2.73801, 2.7380088e+10); 
  r(1.1e+16*2.73801, 3.0118101e+16); 
  r(1.00011e-64*2.73801, 2.7383098e-64); 
  r(1.0e00011*2.73801, 2.7380075e+11); 
  r(0.64*2.73801, 1.7523250e+00); 
  r(0.1e+1*2.73801, 2.7380094e+00); 
  r(0.16e-0*2.73801, 4.3808138e-01); 
  r(0.0e0000*2.73801, 0.0000000e+00); 
  r(0.16e+4*2.73801, 4.3808125e+03); 
  r(0.0000e-10*2.73801, 0.0000000e+00); 
  r(0.4e16*2.73801, 1.0952033e+16); 
  r(0.10e+64*2.73801, 2.7380090e+63); 
  r(0.0e-00011*2.73801, 0.0000000e+00); 
  r(0000.64*2.73801, 1.7523250e+00); 
  r(0000.64e1*2.73801, 1.7523254e+01); 
  r(0000.16e+0*2.73801, 4.3808138e-01); 
  r(0000.16e-0000*2.73801, 4.3808138e-01); 
  r(0000.10e4*2.73801, 2.7380092e+03); 
  r(0000.10e+10*2.73801, 2.7380093e+09); 
  r(0000.10e-16*2.73801, 2.7380088e-17); 
  r(0000.0000e64*2.73801, 0.0000000e+00); 
  r(0000.0000e+00011*2.73801, 0.0000000e+00); 
  r(4.0000*2.73801, 1.0952034e+01); 
  r(4.16e-1*2.73801, 1.1390113e+00); 
  r(4.00011e0*2.73801, 1.0952337e+01); 
  r(4.0000e+0000*2.73801, 1.0952034e+01); 
  r(4.4e-4*2.73801, 1.2047237e-03); 
  r(4.16e10*2.73801, 1.1390117e+11); 
  r(4.16e+16*2.73801, 1.1390115e+17); 
  r(4.1e-64*2.73801, 1.1225838e-63); 
  r(4.64e00011*2.73801, 1.2704358e+12); 
  r(10.64*2.73801, 2.9132415e+01); 
  r(10.4e+1*2.73801, 2.8475292e+02); 
  r(10.10e-0*2.73801, 2.7653884e+01); 
  r(10.4e0000*2.73801, 2.8475296e+01); 
  r(10.16e+4*2.73801, 2.7818175e+05); 
  r(10.4e-10*2.73801, 2.8475293e-09); 
  r(10.0e16*2.73801, 2.7380079e+17); 
  r(10.64e+64*2.73801, 2.9132410e+65); 
  r(10.64e-00011*2.73801, 2.9132407e-10); 
  r(16.64*2.73801, 4.5560470e+01); 
  r(16.64e1*2.73801, 4.5560473e+02); 
  r(16.0e+0*2.73801, 4.3808135e+01); 
  r(16.10e-0000*2.73801, 4.4081924e+01); 
  r(16.10e4*2.73801, 4.4081950e+05); 
  r(16.10e+10*2.73801, 4.4081944e+11); 
  r(16.16e-16*2.73801, 4.4246222e-15); 
  r(16.4e64*2.73801, 4.4903342e+65); 
  r(16.4e+00011*2.73801, 4.4903327e+12); 
  r(64.0*2.73801, 1.7523255e+02); 
  r(64.0e-1*2.73801, 1.7523254e+01); 
  r(64.4e0*2.73801, 1.7632778e+02); 
  r(64.10e+0000*2.73801, 1.7550637e+02); 
  r(64.4e-4*2.73801, 1.7632775e-02); 
  r(64.00011e10*2.73801, 1.7523288e+12); 
  r(64.4e+16*2.73801, 1.7632780e+18); 
  r(64.0000e-64*2.73801, 1.7523256e-62); 
  r(64.10e00011*2.73801, 1.7550639e+13); 
  r(00011.0*2.73801, 3.0118087e+01); 
  r(00011.0e+1*2.73801, 3.0118090e+02); 
  r(00011.16e-0*2.73801, 3.0556182e+01); 
  r(00011.4e0000*2.73801, 3.1213302e+01); 
  r(00011.4e+4*2.73801, 3.1213306e+05); 
  r(00011.1e-10*2.73801, 3.0391900e-09); 
  r(00011.64e16*2.73801, 3.1870409e+17); 
  r(00011.0000e+64*2.73801, 3.0118076e+65); 
  r(00011.0e-00011*2.73801, 3.0118085e-10); 
  r(255.0000*2.73801, 6.9819213e+02); 
  r(255.0000e1*2.73801, 6.9819218e+03); 
  r(255.4e+0*2.73801, 6.9928735e+02); 
  r(255.0000e-0000*2.73801, 6.9819213e+02); 
  r(255.16e4*2.73801, 6.9863040e+06); 
  r(255.00011e+10*2.73801, 6.9819254e+12); 
  r(255.64e-16*2.73801, 6.9994465e-14); 
  r(255.16e64*2.73801, 6.9863013e+66); 
  r(255.4e+00011*2.73801, 6.9928728e+13); 
  r(256.0*2.73801, 7.0093017e+02); 
  r(256.0e-1*2.73801, 7.0093002e+01); 
  r(256.1e0*2.73801, 7.0120361e+02); 
  r(256.1e+0000*2.73801, 7.0120361e+02); 
  r(256.0000e-4*2.73801, 7.0092976e-02); 
  r(256.0e10*2.73801, 7.0093027e+12); 
  r(256.1e+16*2.73801, 7.0120386e+18); 
  r(256.0000e-64*2.73801, 7.0093016e-62); 
  r(256.64e00011*2.73801, 7.0268231e+13); 
  r(4095.10*2.73801, 1.1212421e+04); 
  r(4095.0000e+1*2.73801, 1.1212143e+05); 
  r(4095.16e-0*2.73801, 1.1212585e+04); 
  r(4095.0e0000*2.73801, 1.1212144e+04); 
  r(4095.64e+4*2.73801, 1.1213900e+08); 
  r(4095.0000e-10*2.73801, 1.1212141e-06); 
  r(4095.10e16*2.73801, 1.1212416e+20); 
  r(4095.1e+64*2.73801, 1.1212414e+68); 
  r(4095.0000e-00011*2.73801, 1.1212148e-07); 
  r(10000.4*2.73801, 2.7381183e+04); 
  r(10000.10e1*2.73801, 2.7380350e+05); 
  r(10000.00011e+0*2.73801, 2.7380093e+04); 
  r(10000.4e-0000*2.73801, 2.7381183e+04); 
  r(10000.10e4*2.73801, 2.7380352e+08); 
  r(10000.16e+10*2.73801, 2.7380527e+14); 
  r(10000.1e-16*2.73801, 2.7380363e-12); 
  r(10000.0000e64*2.73801, 2.7380090e+68); 
  r(10000.00011e+00011*2.73801, 2.7380091e+15); 
  r(32768.0*2.73801, 8.9719062e+04); 
  r(32768.4e-1*2.73801, 8.9720156e+03); 
  r(32768.00011e0*2.73801, 8.9719062e+04); 
  r(32768.0e+0000*2.73801, 8.9719062e+04); 
  r(32768.64e-4*2.73801, 8.9720821e+00); 
  r(32768.00011e10*2.73801, 8.9719075e+14); 
  r(32768.16e+16*2.73801, 8.9719445e+20); 
  r(32768.0000e-64*2.73801, 8.9719091e-60); 
  r(32768.00011e00011*2.73801, 8.9719075e+15); 
  r(131001.0000*2.73801, 3.5868175e+05); 
  r(131001.1e+1*2.73801, 3.5868220e+06); 
  r(131001.64e-0*2.73801, 3.5868368e+05); 
  r(131001.4e0000*2.73801, 3.5868300e+05); 
  r(131001.64e+4*2.73801, 3.5868367e+09); 
  r(131001.0e-10*2.73801, 3.5868186e-05); 
  r(131001.10e16*2.73801, 3.5868215e+21); 
  r(131001.10e+64*2.73801, 3.5868218e+69); 
  r(131001.10e-00011*2.73801, 3.5868215e-06); 
  r(1000000000.1*2.73801, 2.7380093e+09); 
  r(1000000000.4e1*2.73801, 2.7380088e+10); 
  r(1000000000.4e+0*2.73801, 2.7380093e+09); 
  r(1000000000.16e-0000*2.73801, 2.7380093e+09); 
  r(1000000000.10e4*2.73801, 2.7380080e+13); 
  r(1000000000.4e+10*2.73801, 2.7380091e+19); 
  r(1000000000.16e-16*2.73801, 2.7380082e-07); 
  r(1000000000.0e64*2.73801, 2.7380090e+73); 
  r(1000000000.0e+00011*2.73801, 2.7380089e+20); 
  r(2147483646.0000*2.73801, 5.8798284e+09); 
  r(2147483646.10e-1*2.73801, 5.8798284e+08); 
  r(2147483646.0e0*2.73801, 5.8798284e+09); 
  r(2147483646.64e+0000*2.73801, 5.8798284e+09); 
  r(2147483646.0000e-4*2.73801, 5.8798287e+05); 
  r(2147483646.0000e10*2.73801, 5.8798293e+19); 
  r(2147483646.16e+16*2.73801, 5.8798277e+25); 
  r(2147483646.10e-64*2.73801, 5.8798303e-55); 
  r(2147483646.4e00011*2.73801, 5.8798293e+20); 
  r(1.4095*2.73801, 3.8592214e+00); 
  r(1.4095e+1*2.73801, 3.8592239e+01); 
  r(1.32768e-0*2.73801, 3.6351985e+00); 
  r(1.255e0000*2.73801, 3.4361991e+00); 
  r(1.4095e+4*2.73801, 3.8592242e+04); 
  r(1.256e-10*2.73801, 3.4389380e-10); 
  r(1.255e16*2.73801, 3.4362010e+16); 
  r(1.32768e+64*2.73801, 3.6351995e+64); 
  r(1.256e-00011*2.73801, 3.4389394e-11); 
  r(0.32768*2.73801, 8.9719086e-01); 
  r(0.256e1*2.73801, 7.0093021e+00); 
  r(0.255e+0*2.73801, 6.9819235e-01); 
  r(0.256e-0000*2.73801, 7.0093035e-01); 
  r(0.255e4*2.73801, 6.9819218e+03); 
  r(0.32768e+10*2.73801, 8.9719070e+09); 
  r(0.256e-16*2.73801, 7.0093021e-17); 
  r(0.10000e64*2.73801, 2.7380090e+63); 
  r(0.255e+00011*2.73801, 6.9819170e+10); 
  r(0000.10000*2.73801, 2.7380079e-01); 
  r(0000.256e-1*2.73801, 7.0092976e-02); 
  r(0000.255e0*2.73801, 6.9819235e-01); 
  r(0000.10000e+0000*2.73801, 2.7380079e-01); 
  r(0000.32768e-4*2.73801, 8.9719047e-05); 
  r(0000.255e10*2.73801, 6.9819228e+09); 
  r(0000.32768e+16*2.73801, 8.9719075e+15); 
  r(0000.255e-64*2.73801, 6.9819222e-65); 
  r(0000.32768e00011*2.73801, 8.9719046e+10); 
  r(4.32768*2.73801, 1.1849226e+01); 
  r(4.4095e+1*2.73801, 1.2073248e+02); 
  r(4.32768e-0*2.73801, 1.1849226e+01); 
  r(4.10000e0000*2.73801, 1.1225836e+01); 
  r(4.256e+4*2.73801, 1.1652962e+05); 
  r(4.255e-10*2.73801, 1.1650225e-09); 
  r(4.4095e16*2.73801, 1.2073249e+17); 
  r(4.255e+64*2.73801, 1.1650220e+65); 
  r(4.4095e-00011*2.73801, 1.2073249e-10); 
  r(10.256*2.73801, 2.8081008e+01); 
  r(10.4095e1*2.73801, 2.8501293e+02); 
  r(10.256e+0*2.73801, 2.8081008e+01); 
  r(10.32768e-0000*2.73801, 2.8277282e+01); 
  r(10.32768e4*2.73801, 2.8277268e+05); 
  r(10.256e+10*2.73801, 2.8081016e+11); 
  r(10.255e-16*2.73801, 2.8078280e-15); 
  r(10.255e64*2.73801, 2.8078279e+65); 
  r(10.255e+00011*2.73801, 2.8078285e+12); 
  r(16.256*2.73801, 4.4509063e+01); 
  r(16.10000e-1*2.73801, 4.4081935e+00); 
  r(16.256e0*2.73801, 4.4509063e+01); 
  r(16.255e+0000*2.73801, 4.4506301e+01); 
  r(16.32768e-4*2.73801, 4.4705308e-03); 
  r(16.32768e10*2.73801, 4.4705336e+11); 
  r(16.32768e+16*2.73801, 4.4705338e+17); 
  r(16.256e-64*2.73801, 4.4509059e-63); 
  r(16.4095e00011*2.73801, 4.4929332e+12); 
  r(64.32768*2.73801, 1.7612976e+02); 
  r(64.256e+1*2.73801, 1.7593347e+03); 
  r(64.4095e-0*2.73801, 1.7635377e+02); 
  r(64.255e0000*2.73801, 1.7593075e+02); 
  r(64.4095e+4*2.73801, 1.7635380e+06); 
  r(64.10000e-10*2.73801, 1.7550632e-08); 
  r(64.32768e16*2.73801, 1.7612977e+18); 
  r(64.10000e+64*2.73801, 1.7550623e+66); 
  r(64.10000e-00011*2.73801, 1.7550636e-09); 
  r(00011.256*2.73801, 3.0819030e+01); 
  r(00011.32768e1*2.73801, 3.1015283e+02); 
  r(00011.255e+0*2.73801, 3.0816284e+01); 
  r(00011.256e-0000*2.73801, 3.0819030e+01); 
  r(00011.4095e4*2.73801, 3.1239318e+05); 
  r(00011.32768e+10*2.73801, 3.1015279e+11); 
  r(00011.10000e-16*2.73801, 3.0391900e-15); 
  r(00011.10000e64*2.73801, 3.0391888e+65); 
  r(00011.10000e+00011*2.73801, 3.0391884e+12); 
  r(255.255*2.73801, 6.9889038e+02); 
  r(255.256e-1*2.73801, 6.9889297e+01); 
  r(255.10000e0*2.73801, 6.9846606e+02); 
  r(255.256e+0000*2.73801, 6.9889331e+02); 
  r(255.256e-4*2.73801, 6.9889307e-02); 
  r(255.10000e10*2.73801, 6.9846612e+12); 
  r(255.255e+16*2.73801, 6.9889038e+18); 
  r(255.4095e-64*2.73801, 6.9931332e-62); 
  r(255.10000e00011*2.73801, 6.9846586e+13); 
  r(256.256*2.73801, 7.0163085e+02); 
  r(256.10000e+1*2.73801, 7.0120390e+03); 
  r(256.32768e-0*2.73801, 7.0182739e+02); 
  r(256.32768e0000*2.73801, 7.0182739e+02); 
  r(256.256e+4*2.73801, 7.0163130e+06); 
  r(256.4095e-10*2.73801, 7.0205146e-08); 
  r(256.4095e16*2.73801, 7.0205136e+18); 
  r(256.256e+64*2.73801, 7.0163125e+66); 
  r(256.10000e-00011*2.73801, 7.0120407e-09); 
  r(4095.4095*2.73801, 1.1213269e+04); 
  r(4095.32768e1*2.73801, 1.1213043e+05); 
  r(4095.255e+0*2.73801, 1.1212843e+04); 
  r(4095.255e-0000*2.73801, 1.1212843e+04); 
  r(4095.10000e4*2.73801, 1.1212419e+08); 
  r(4095.32768e+10*2.73801, 1.1213042e+14); 
  r(4095.10000e-16*2.73801, 1.1212419e-12); 
  r(4095.10000e64*2.73801, 1.1212414e+68); 
  r(4095.10000e+00011*2.73801, 1.1212417e+15); 
  r(10000.255*2.73801, 2.7380789e+04); 
  r(10000.255e-1*2.73801, 2.7380788e+03); 
  r(10000.10000e0*2.73801, 2.7380359e+04); 
  r(10000.4095e+0000*2.73801, 2.7381203e+04); 
  r(10000.4095e-4*2.73801, 2.7381181e+00); 
  r(10000.255e10*2.73801, 2.7380788e+14); 
  r(10000.256e+16*2.73801, 2.7380793e+20); 
  r(10000.32768e-64*2.73801, 2.7380974e-60); 
  r(10000.255e00011*2.73801, 2.7380789e+15); 
  r(32768.10000*2.73801, 8.9719312e+04); 
  r(32768.255e+1*2.73801, 8.9719775e+05); 
  r(32768.4095e-0*2.73801, 8.9720187e+04); 
  r(32768.256e0000*2.73801, 8.9719750e+04); 
  r(32768.256e+4*2.73801, 8.9719782e+08); 
  r(32768.4095e-10*2.73801, 8.9720188e-06); 
  r(32768.256e16*2.73801, 8.9719754e+20); 
  r(32768.32768e+64*2.73801, 8.9719984e+68); 
  r(32768.10000e-00011*2.73801, 8.9719361e-07); 
  r(131001.32768*2.73801, 3.5868281e+05); 
  r(131001.256e1*2.73801, 3.5868250e+06); 
  r(131001.4095e+0*2.73801, 3.5868300e+05); 
  r(131001.4095e-0000*2.73801, 3.5868300e+05); 
  r(131001.255e4*2.73801, 3.5868262e+09); 
  r(131001.255e+10*2.73801, 3.5868265e+15); 
  r(131001.256e-16*2.73801, 3.5868252e-11); 
  r(131001.4095e64*2.73801, 3.5868296e+69); 
  r(131001.4095e+00011*2.73801, 3.5868302e+16); 
  r(1000000000.256*2.73801, 2.7380093e+09); 
  r(1000000000.256e-1*2.73801, 2.7380070e+08); 
  r(1000000000.10000e0*2.73801, 2.7380093e+09); 
  r(1000000000.255e+0000*2.73801, 2.7380093e+09); 
  r(1000000000.256e-4*2.73801, 2.7380093e+05); 
  r(1000000000.255e10*2.73801, 2.7380091e+19); 
  r(1000000000.4095e+16*2.73801, 2.7380077e+25); 
  r(1000000000.32768e-64*2.73801, 2.7380084e-55); 
  r(1000000000.256e00011*2.73801, 2.7380089e+20); 
  r(2147483646.10000*2.73801, 5.8798284e+09); 
  r(2147483646.256e+1*2.73801, 5.8798292e+10); 
  r(2147483646.4095e-0*2.73801, 5.8798284e+09); 
  r(2147483646.256e0000*2.73801, 5.8798284e+09); 
  r(2147483646.10000e+4*2.73801, 5.8798253e+13); 
  r(2147483646.256e-10*2.73801, 5.8798289e-01); 
  r(2147483646.10000e16*2.73801, 5.8798277e+25); 
  r(2147483646.10000e+64*2.73801, 5.8798295e+73); 
  r(2147483646.255e-00011*2.73801, 5.8798298e-02); 
  r(1.131001*2.73801, 3.0966892e+00); 
  r(1.131001e1*2.73801, 3.0966903e+01); 
  r(1.1000000000e+0*2.73801, 3.0118083e+00); 
  r(1.131001e-0000*2.73801, 3.0966892e+00); 
  r(1.131001e4*2.73801, 3.0966906e+04); 
  r(1.1000000000e+10*2.73801, 3.0118092e+10); 
  r(1.2147483646e-16*2.73801, 3.3259913e-16); 
  r(1.1000000000e64*2.73801, 3.0118099e+64); 
  r(1.2147483646e+00011*2.73801, 3.3259906e+11); 
  r(0.1000000000*2.73801, 2.7380079e-01); 
  r(0.1000000000e-1*2.73801, 2.7380086e-02); 
  r(0.2147483646e0*2.73801, 5.8798289e-01); 
  r(0.1000000000e+0000*2.73801, 2.7380079e-01); 
  r(0.1000000000e-4*2.73801, 2.7380083e-05); 
  r(0.2147483646e10*2.73801, 5.8798284e+09); 
  r(0.1000000000e+16*2.73801, 2.7380091e+15); 
  r(0.1000000000e-64*2.73801, 2.7380081e-65); 
  r(0.131001e00011*2.73801, 3.5868188e+10); 
  r(0000.1000000000*2.73801, 2.7380079e-01); 
  r(0000.1000000000e+1*2.73801, 2.7380084e+00); 
  r(0000.2147483646e-0*2.73801, 5.8798289e-01); 
  r(0000.131001e0000*2.73801, 3.5868191e-01); 
  r(0000.2147483646e+4*2.73801, 5.8798281e+03); 
  r(0000.131001e-10*2.73801, 3.5868197e-11); 
  r(0000.2147483646e16*2.73801, 5.8798274e+15); 
  r(0000.2147483646e+64*2.73801, 5.8798302e+63); 
  r(0000.131001e-00011*2.73801, 3.5868174e-12); 
  r(4.1000000000*2.73801, 1.1225836e+01); 
  r(4.2147483646e1*2.73801, 1.1540017e+02); 
  r(4.1000000000e+0*2.73801, 1.1225836e+01); 
  r(4.131001e-0000*2.73801, 1.1310717e+01); 
  r(4.2147483646e4*2.73801, 1.1540018e+05); 
  r(4.1000000000e+10*2.73801, 1.1225831e+11); 
  r(4.2147483646e-16*2.73801, 1.1540017e-15); 
  r(4.1000000000e64*2.73801, 1.1225828e+65); 
  r(4.2147483646e+00011*2.73801, 1.1540019e+12); 
  r(10.1000000000*2.73801, 2.7653884e+01); 
  r(10.1000000000e-1*2.73801, 2.7653875e+00); 
  r(10.1000000000e0*2.73801, 2.7653884e+01); 
  r(10.131001e+0000*2.73801, 2.7738769e+01); 
  r(10.2147483646e-4*2.73801, 2.7968075e-03); 
  r(10.2147483646e10*2.73801, 2.7968058e+11); 
  r(10.131001e+16*2.73801, 2.7738761e+17); 
  r(10.131001e-64*2.73801, 2.7738764e-63); 
  r(10.2147483646e00011*2.73801, 2.7968069e+12); 
  r(16.2147483646*2.73801, 4.4396102e+01); 
  r(16.1000000000e+1*2.73801, 4.4081933e+02); 
  r(16.2147483646e-0*2.73801, 4.4396102e+01); 
  r(16.2147483646e0000*2.73801, 4.4396102e+01); 
  r(16.1000000000e+4*2.73801, 4.4081931e+05); 
  r(16.131001e-10*2.73801, 4.4166803e-09); 
  r(16.131001e16*2.73801, 4.4166818e+17); 
  r(16.131001e+64*2.73801, 4.4166812e+65); 
  r(16.1000000000e-00011*2.73801, 4.4081938e-10); 
  r(64.2147483646*2.73801, 1.7582055e+02); 
  r(64.131001e1*2.73801, 1.7559121e+03); 
  r(64.2147483646e+0*2.73801, 1.7582055e+02); 
  r(64.131001e-0000*2.73801, 1.7559126e+02); 
  r(64.1000000000e4*2.73801, 1.7550630e+06); 
  r(64.1000000000e+10*2.73801, 1.7550635e+12); 
  r(64.131001e-16*2.73801, 1.7559125e-14); 
  r(64.1000000000e64*2.73801, 1.7550623e+66); 
  r(64.131001e+00011*2.73801, 1.7559125e+13); 
  r(00011.2147483646*2.73801, 3.0706069e+01); 
  r(00011.131001e-1*2.73801, 3.0476779e+00); 
  r(00011.131001e0*2.73801, 3.0476776e+01); 
  r(00011.1000000000e+0000*2.73801, 3.0391891e+01); 
  r(00011.2147483646e-4*2.73801, 3.0706080e-03); 
  r(00011.1000000000e10*2.73801, 3.0391894e+11); 
  r(00011.2147483646e+16*2.73801, 3.0706068e+17); 
  r(00011.131001e-64*2.73801, 3.0476761e-63); 
  r(00011.2147483646e00011*2.73801, 3.0706059e+12); 
  r(255.131001*2.73801, 6.9855102e+02); 
  r(255.2147483646e+1*2.73801, 6.9878007e+03); 
  r(255.2147483646e-0*2.73801, 6.9878027e+02); 
  r(255.1000000000e0000*2.73801, 6.9846606e+02); 
  r(255.131001e+4*2.73801, 6.9855100e+06); 
  r(255.131001e-10*2.73801, 6.9855104e-08); 
  r(255.131001e16*2.73801, 6.9855074e+18); 
  r(255.2147483646e+64*2.73801, 6.9878022e+66); 
  r(255.2147483646e-00011*2.73801, 6.9878005e-09); 
  r(256.1000000000*2.73801, 7.0120361e+02); 
  r(256.131001e1*2.73801, 7.0128867e+03); 
  r(256.2147483646e+0*2.73801, 7.0151782e+02); 
  r(256.131001e-0000*2.73801, 7.0128857e+02); 
  r(256.131001e4*2.73801, 7.0128900e+06); 
  r(256.1000000000e+10*2.73801, 7.0120395e+12); 
  r(256.131001e-16*2.73801, 7.0128852e-14); 
  r(256.131001e64*2.73801, 7.0128897e+66); 
  r(256.131001e+00011*2.73801, 7.0128863e+13); 
  r(4095.2147483646*2.73801, 1.1212734e+04); 
  r(4095.131001e-1*2.73801, 1.1212502e+03); 
  r(4095.2147483646e0*2.73801, 1.1212734e+04); 
  r(4095.1000000000e+0000*2.73801, 1.1212421e+04); 
  r(4095.2147483646e-4*2.73801, 1.1212730e+00); 
  r(4095.1000000000e10*2.73801, 1.1212418e+14); 
  r(4095.2147483646e+16*2.73801, 1.1212735e+20); 
  r(4095.2147483646e-64*2.73801, 1.1212734e-60); 
  r(4095.1000000000e00011*2.73801, 1.1212417e+15); 
  r(10000.131001*2.73801, 2.7380445e+04); 
  r(10000.2147483646e+1*2.73801, 2.7380675e+05); 
  r(10000.1000000000e-0*2.73801, 2.7380359e+04); 
  r(10000.131001e0000*2.73801, 2.7380445e+04); 
  r(10000.2147483646e+4*2.73801, 2.7380659e+08); 
  r(10000.2147483646e-10*2.73801, 2.7380674e-06); 
  r(10000.1000000000e16*2.73801, 2.7380364e+20); 
  r(10000.131001e+64*2.73801, 2.7380447e+68); 
  r(10000.1000000000e-00011*2.73801, 2.7380360e-07); 
  r(32768.2147483646*2.73801, 8.9719625e+04); 
  r(32768.2147483646e1*2.73801, 8.9719675e+05); 
  r(32768.1000000000e+0*2.73801, 8.9719312e+04); 
  r(32768.131001e-0000*2.73801, 8.9719437e+04); 
  r(32768.1000000000e4*2.73801, 8.9719296e+08); 
  r(32768.131001e+10*2.73801, 8.9719450e+14); 
  r(32768.2147483646e-16*2.73801, 8.9719655e-12); 
  r(32768.1000000000e64*2.73801, 8.9719325e+68); 
  r(32768.131001e+00011*2.73801, 8.9719418e+15); 
  r(131001.2147483646*2.73801, 3.5868243e+05); 
  r(131001.1000000000e-1*2.73801, 3.5868222e+04); 
  r(131001.2147483646e0*2.73801, 3.5868243e+05); 
  r(131001.2147483646e+0000*2.73801, 3.5868243e+05); 
  r(131001.131001e-4*2.73801, 3.5868225e+01); 
  r(131001.2147483646e10*2.73801, 3.5868251e+15); 
  r(131001.131001e+16*2.73801, 3.5868232e+21); 
  r(131001.1000000000e-64*2.73801, 3.5868206e-59); 
  r(131001.2147483646e00011*2.73801, 3.5868246e+16); 
  r(1000000000.1000000000*2.73801, 2.7380093e+09); 
  r(1000000000.2147483646e+1*2.73801, 2.7380088e+10); 
  r(1000000000.1000000000e-0*2.73801, 2.7380093e+09); 
  r(1000000000.1000000000e0000*2.73801, 2.7380093e+09); 
  r(1000000000.131001e+4*2.73801, 2.7380080e+13); 
  r(1000000000.131001e-10*2.73801, 2.7380079e-01); 
  r(1000000000.2147483646e16*2.73801, 2.7380077e+25); 
  r(1000000000.131001e+64*2.73801, 2.7380090e+73); 
  r(1000000000.2147483646e-00011*2.73801, 2.7380086e-02); 
  r(2147483646.2147483646*2.73801, 5.8798284e+09); 
  r(2147483646.1000000000e1*2.73801, 5.8798292e+10); 
  r(2147483646.131001e+0*2.73801, 5.8798284e+09); 
  r(2147483646.2147483646e-0000*2.73801, 5.8798284e+09); 
  r(2147483646.131001e4*2.73801, 5.8798253e+13); 
  r(2147483646.131001e+10*2.73801, 5.8798293e+19); 
  r(2147483646.1000000000e-16*2.73801, 5.8798298e-07); 
  r(2147483646.1000000000e64*2.73801, 5.8798295e+73); 
  r(2147483646.1000000000e+00011*2.73801, 5.8798293e+20); 
  r(1e-1*2.73801, 2.7380079e-01); 
  r(1e0*2.73801, 2.7380094e+00); 
  r(1e+0000*2.73801, 2.7380094e+00); 
  r(1e-4*2.73801, 2.7380068e-04); 
  r(1e10*2.73801, 2.7380088e+10); 
  r(1e+16*2.73801, 2.7380085e+16); 
  r(1e-64*2.73801, 2.7380084e-64); 
  r(1e00011*2.73801, 2.7380075e+11); 
  r(0e+1*2.73801, 0.0000000e+00); 
  r(0e-0*2.73801, 0.0000000e+00); 
  r(0e0000*2.73801, 0.0000000e+00); 
  r(0e+4*2.73801, 0.0000000e+00); 
  r(0e-10*2.73801, 0.0000000e+00); 
  r(0e16*2.73801, 0.0000000e+00); 
  r(0e+64*2.73801, 0.0000000e+00); 
  r(0e-00011*2.73801, 0.0000000e+00); 
  r(0000e1*2.73801, 0.0000000e+00); 
  r(0000e+0*2.73801, 0.0000000e+00); 
  r(0000e-0000*2.73801, 0.0000000e+00); 
  r(0000e4*2.73801, 0.0000000e+00); 
  r(0000e+10*2.73801, 0.0000000e+00); 
  r(0000e-16*2.73801, 0.0000000e+00); 
  r(0000e64*2.73801, 0.0000000e+00); 
  r(0000e+00011*2.73801, 0.0000000e+00); 
  r(4e-1*2.73801, 1.0952033e+00); 
  r(4e0*2.73801, 1.0952037e+01); 
  r(4e+0000*2.73801, 1.0952037e+01); 
  r(4e-4*2.73801, 1.0952029e-03); 
  r(4e10*2.73801, 1.0952035e+11); 
  r(4e+16*2.73801, 1.0952036e+17); 
  r(4e-64*2.73801, 1.0952035e-63); 
  r(4e00011*2.73801, 1.0952036e+12); 
  r(10e+1*2.73801, 2.7380078e+02); 
  r(10e-0*2.73801, 2.7380081e+01); 
  r(10e0000*2.73801, 2.7380081e+01); 
  r(10e+4*2.73801, 2.7380093e+05); 
  r(10e-10*2.73801, 2.7380089e-09); 
  r(10e16*2.73801, 2.7380079e+17); 
  r(10e+64*2.73801, 2.7380085e+65); 
  r(10e-00011*2.73801, 2.7380075e-10); 
  r(16e1*2.73801, 4.3808129e+02); 
  r(16e+0*2.73801, 4.3808151e+01); 
  r(16e-0000*2.73801, 4.3808151e+01); 
  r(16e4*2.73801, 4.3808150e+05); 
  r(16e+10*2.73801, 4.3808142e+11); 
  r(16e-16*2.73801, 4.3808137e-15); 
  r(16e64*2.73801, 4.3808124e+65); 
  r(16e+00011*2.73801, 4.3808121e+12); 
  r(64e-1*2.73801, 1.7523254e+01); 
  r(64e0*2.73801, 1.7523260e+02); 
  r(64e+0000*2.73801, 1.7523260e+02); 
  r(64e-4*2.73801, 1.7523247e-02); 
  r(64e10*2.73801, 1.7523256e+12); 
  r(64e+16*2.73801, 1.7523257e+18); 
  r(64e-64*2.73801, 1.7523256e-62); 
  r(64e00011*2.73801, 1.7523257e+13); 
  r(00011e+1*2.73801, 3.0118090e+02); 
  r(00011e-0*2.73801, 3.0118103e+01); 
  r(00011e0000*2.73801, 3.0118103e+01); 
  r(00011e+4*2.73801, 3.0118100e+05); 
  r(00011e-10*2.73801, 3.0118099e-09); 
  r(00011e16*2.73801, 3.0118090e+17); 
  r(00011e+64*2.73801, 3.0118076e+65); 
  r(00011e-00011*2.73801, 3.0118085e-10); 
  r(255e1*2.73801, 6.9819218e+03); 
  r(255e+0*2.73801, 6.9819238e+02); 
  r(255e-0000*2.73801, 6.9819238e+02); 
  r(255e4*2.73801, 6.9819240e+06); 
  r(255e+10*2.73801, 6.9819223e+12); 
  r(255e-16*2.73801, 6.9819204e-14); 
  r(255e64*2.73801, 6.9819192e+66); 
  r(255e+00011*2.73801, 6.9819206e+13); 
  r(256e-1*2.73801, 7.0093002e+01); 
  r(256e0*2.73801, 7.0093041e+02); 
  r(256e+0000*2.73801, 7.0093041e+02); 
  r(256e-4*2.73801, 7.0092976e-02); 
  r(256e10*2.73801, 7.0093027e+12); 
  r(256e+16*2.73801, 7.0093019e+18); 
  r(256e-64*2.73801, 7.0093016e-62); 
  r(256e00011*2.73801, 7.0092993e+13); 
  r(4095e+1*2.73801, 1.1212143e+05); 
  r(4095e-0*2.73801, 1.1212148e+04); 
  r(4095e0000*2.73801, 1.1212148e+04); 
  r(4095e+4*2.73801, 1.1212147e+08); 
  r(4095e-10*2.73801, 1.1212141e-06); 
  r(4095e16*2.73801, 1.1212147e+20); 
  r(4095e+64*2.73801, 1.1212141e+68); 
  r(4095e-00011*2.73801, 1.1212148e-07); 
  r(10000e1*2.73801, 2.7380093e+05); 
  r(10000e+0*2.73801, 2.7380093e+04); 
  r(10000e-0000*2.73801, 2.7380093e+04); 
  r(10000e4*2.73801, 2.7380070e+08); 
  r(10000e+10*2.73801, 2.7380091e+14); 
  r(10000e-16*2.73801, 2.7380077e-12); 
  r(10000e64*2.73801, 2.7380090e+68); 
  r(10000e+00011*2.73801, 2.7380091e+15); 
  r(32768e-1*2.73801, 8.9719062e+03); 
  r(32768e0*2.73801, 8.9719062e+04); 
  r(32768e+0000*2.73801, 8.9719062e+04); 
  r(32768e-4*2.73801, 8.9719066e+00); 
  r(32768e10*2.73801, 8.9719075e+14); 
  r(32768e+16*2.73801, 8.9719051e+20); 
  r(32768e-64*2.73801, 8.9719091e-60); 
  r(32768e00011*2.73801, 8.9719075e+15); 
  r(131001e+1*2.73801, 3.5868190e+06); 
  r(131001e-0*2.73801, 3.5868193e+05); 
  r(131001e0000*2.73801, 3.5868193e+05); 
  r(131001e+4*2.73801, 3.5868193e+09); 
  r(131001e-10*2.73801, 3.5868186e-05); 
  r(131001e16*2.73801, 3.5868193e+21); 
  r(131001e+64*2.73801, 3.5868185e+69); 
  r(131001e-00011*2.73801, 3.5868188e-06); 
  r(1000000000e1*2.73801, 2.7380088e+10); 
  r(1000000000e+0*2.73801, 2.7380093e+09); 
  r(1000000000e-0000*2.73801, 2.7380093e+09); 
  r(1000000000e4*2.73801, 2.7380080e+13); 
  r(1000000000e+10*2.73801, 2.7380091e+19); 
  r(1000000000e-16*2.73801, 2.7380082e-07); 
  r(1000000000e64*2.73801, 2.7380090e+73); 
  r(1000000000e+00011*2.73801, 2.7380089e+20); 
  r(2147483646e-1*2.73801, 5.8798284e+08); 
  r(2147483646e0*2.73801, 5.8798284e+09); 
  r(2147483646e+0000*2.73801, 5.8798284e+09); 
  r(2147483646e-4*2.73801, 5.8798287e+05); 
  r(2147483646e10*2.73801, 5.8798293e+19); 
  r(2147483646e+16*2.73801, 5.8798277e+25); 
  r(2147483646e-64*2.73801, 5.8798303e-55); 
  r(2147483646e00011*2.73801, 5.8798293e+20); 
  print((whole (((tests ok +:= ctr; ctr); ctr), 0), " tests real ", (ctr=(to test +:= vf; vf) | "ok" | "error"), 
      " mean rel. differ.: ", fixed (erc/ct, 0, 9), " max rel diff : ", fixed (super, 0, 9)))); 
  
  ######
  # r9 #
  (print((newline, "Test of operator identifiers: TAM and TAD: ")); 
  
   INT nbt= 271; [1:nbt] BOOL tc; 
   FOR i TO nbt DO tc[i]:= TRUE OD; 
   INT ctr:= 0; 
   PROC pos= (INT i) BOOL :
      (ctr+:= 1; tc[i] | tc[i]:= FALSE  | 
           print(("err.1", i, newline));  SKIP); (
  
   OP TTT = (INT a) BOOL :pos(1); 
   OP  &:= = (INT a) BOOL :pos(2); 
   OP  &=: = (INT a) BOOL :pos(3); 
   OP  & = (INT a) BOOL :pos(4); 
   OP  ?:= = (INT a) BOOL :pos(5); 
   OP  ?=: = (INT a) BOOL :pos(6); 
   OP  ? = (INT a) BOOL :pos(7); 
   OP  +:= = (INT a) BOOL :pos(8); 
   OP  +=: = (INT a) BOOL :pos(9); 
   OP  + = (INT a) BOOL :pos(10); 
   OP  -:= = (INT a) BOOL :pos(11); 
   OP  -=: = (INT a) BOOL :pos(12); 
   OP  - = (INT a) BOOL :pos(13); 
   OP  ^:= = (INT a) BOOL :pos(14); 
   OP  ^=: = (INT a) BOOL :pos(15); 
   OP  ^ = (INT a) BOOL :pos(16); 
   OP  &<:= = (INT a) BOOL :pos(17); 
   OP  &<=: = (INT a) BOOL :pos(18); 
   OP  &< = (INT a) BOOL :pos(19); 
   OP  &>:= = (INT a) BOOL :pos(20); 
   OP  &>=: = (INT a) BOOL :pos(21); 
   OP  &> = (INT a) BOOL :pos(22); 
   OP  &/:= = (INT a) BOOL :pos(23); 
   OP  &/=: = (INT a) BOOL :pos(24); 
   OP  &/ = (INT a) BOOL :pos(25); 
   OP  &*:= = (INT a) BOOL :pos(26); 
   OP  &*=: = (INT a) BOOL :pos(27); 
   OP  &* = (INT a) BOOL :pos(28); 
   OP  &=:= = (INT a) BOOL :pos(29); 
   OP  &==: = (INT a) BOOL :pos(30); 
   OP  &= = (INT a) BOOL :pos(31); 
   OP  ?<:= = (INT a) BOOL :pos(32); 
   OP  ?<=: = (INT a) BOOL :pos(33); 
   OP  ?< = (INT a) BOOL :pos(34); 
   OP  ?>:= = (INT a) BOOL :pos(35); 
   OP  ?>=: = (INT a) BOOL :pos(36); 
   OP  ?> = (INT a) BOOL :pos(37); 
   OP  ?/:= = (INT a) BOOL :pos(38); 
   OP  ?/=: = (INT a) BOOL :pos(39); 
   OP  ?/ = (INT a) BOOL :pos(40); 
   OP  ?*:= = (INT a) BOOL :pos(41); 
   OP  ?*=: = (INT a) BOOL :pos(42); 
   OP  ?* = (INT a) BOOL :pos(43); 
   OP  ?=:= = (INT a) BOOL :pos(44); 
   OP  ?==: = (INT a) BOOL :pos(45); 
   OP  ?= = (INT a) BOOL :pos(46); 
   OP  +<:= = (INT a) BOOL :pos(47); 
   OP  +<=: = (INT a) BOOL :pos(48); 
   OP  +< = (INT a) BOOL :pos(49); 
   OP  +>:= = (INT a) BOOL :pos(50); 
   OP  +>=: = (INT a) BOOL :pos(51); 
   OP  +> = (INT a) BOOL :pos(52); 
   OP  +/:= = (INT a) BOOL :pos(53); 
   OP  +/=: = (INT a) BOOL :pos(54); 
   OP  +/ = (INT a) BOOL :pos(55); 
   OP  +*:= = (INT a) BOOL :pos(56); 
   OP  +*=: = (INT a) BOOL :pos(57); 
   OP  +* = (INT a) BOOL :pos(58); 
   OP  +=:= = (INT a) BOOL :pos(59); 
   OP  +==: = (INT a) BOOL :pos(60); 
   OP  += = (INT a) BOOL :pos(61); 
   OP  -<:= = (INT a) BOOL :pos(62); 
   OP  -<=: = (INT a) BOOL :pos(63); 
   OP  -< = (INT a) BOOL :pos(64); 
   OP  ->:= = (INT a) BOOL :pos(65); 
   OP  ->=: = (INT a) BOOL :pos(66); 
   OP  -> = (INT a) BOOL :pos(67); 
   OP  -/:= = (INT a) BOOL :pos(68); 
   OP  -/=: = (INT a) BOOL :pos(69); 
   OP  -/ = (INT a) BOOL :pos(70); 
   OP  -*:= = (INT a) BOOL :pos(71); 
   OP  -*=: = (INT a) BOOL :pos(72); 
   OP  -* = (INT a) BOOL :pos(73); 
   OP  -=:= = (INT a) BOOL :pos(74); 
   OP  -==: = (INT a) BOOL :pos(75); 
   OP  -= = (INT a) BOOL :pos(76); 
   OP  ^<:= = (INT a) BOOL :pos(77); 
   OP  ^<=: = (INT a) BOOL :pos(78); 
   OP  ^< = (INT a) BOOL :pos(79); 
   OP  ^>:= = (INT a) BOOL :pos(80); 
   OP  ^>=: = (INT a) BOOL :pos(81); 
   OP  ^> = (INT a) BOOL :pos(82); 
   OP  ^/:= = (INT a) BOOL :pos(83); 
   OP  ^/=: = (INT a) BOOL :pos(84); 
   OP  ^/ = (INT a) BOOL :pos(85); 
   OP  ^*:= = (INT a) BOOL :pos(86); 
   OP  ^*=: = (INT a) BOOL :pos(87); 
   OP  ^* = (INT a) BOOL :pos(88); 
   OP  ^=:= = (INT a) BOOL :pos(89); 
   OP  ^==: = (INT a) BOOL :pos(90); 
   OP  ^= = (INT a) BOOL :pos(91); 
   TTT 1; 
  &:= 2; 
  &=:6; 
  &4; 
  ?:= 5; 
  ?=:4; 
  ?1; 
  +:= 9; 
  +=:2; 
  +7; 
  -:= 1; 
  -=:6; 
  -2; 
  ^:= 6; 
  ^=:3; 
  ^5; 
  &<:= 6; 
  &<=:2; 
  &<8; 
  &>:= 8; 
  &>=:7; 
  &>6; 
  &/:= 6; 
  &/=:5; 
  &/6; 
  &*:= 3; 
  &*=:4; 
  &*3; 
  &=:= 6; 
  &==:9; 
  &= 4; 
  ?<:= 4; 
  ?<=:6; 
  ?<7; 
  ?>:= 1; 
  ?>=:8; 
  ?>8; 
  ?/:= 5; 
  ?/=:6; 
  ?/4; 
  ?*:= 7; 
  ?*=:4; 
  ?*2; 
  ?=:= 8; 
  ?==:7; 
  ?= 8; 
  +<:= 8; 
  +<=:3; 
  +<6; 
  +>:= 6; 
  +>=:6; 
  +>7; 
  +/:= 5; 
  +/=:4; 
  +/3; 
  +*:= 3; 
  +*=:4; 
  +*5; 
  +=:= 4; 
  +==:9; 
  += 5; 
  -<:= 3; 
  -<=:6; 
  -<3; 
  ->:= 2; 
  ->=:6; 
  ->5; 
  -/:= 4; 
  -/=:1; 
  -/8; 
  -*:= 3; 
  -*=:2; 
  -*3; 
  -=:= 3; 
  -==:4; 
  -= 3; 
  ^<:= 7; 
  ^<=:9; 
  ^<8; 
  ^>:= 7; 
  ^>=:5; 
  ^>3; 
  ^/:= 2; 
  ^/=:1; 
  ^/1; 
  ^*:= 3; 
  ^*=:2; 
  ^*1; 
  ^=:= 3; 
  ^==:8; 
  ^= 6; SKIP); (
   PRIO  &:= = 7; 
   PRIO  ?:= = 8; 
   PRIO  +:= = 9; 
   PRIO  -:= = 1; 
   PRIO  ^:= = 2; 
   PRIO  <:= = 3; 
   PRIO  >:= = 4; 
   PRIO  /:= = 5; 
   PRIO  *:= = 6; 
   PRIO =:= = 7; 
   PRIO  &<:= = 8; 
   PRIO  &>:= = 9; 
   PRIO  &/:= = 1; 
   PRIO  &*:= = 2; 
   PRIO  &=:= = 3; 
   PRIO  ?<:= = 4; 
   PRIO  ?>:= = 5; 
   PRIO  ?/:= = 6; 
   PRIO  ?*:= = 7; 
   PRIO  ?=:= = 8; 
   PRIO  +<:= = 9; 
   PRIO  +>:= = 1; 
   PRIO  +/:= = 2; 
   PRIO  +*:= = 3; 
   PRIO  +=:= = 4; 
   PRIO  -<:= = 5; 
   PRIO  ->:= = 6; 
   PRIO  -/:= = 7; 
   PRIO  -*:= = 8; 
   PRIO  -=:= = 9; 
   PRIO  ^<:= = 1; 
   PRIO  ^>:= = 2; 
   PRIO  ^/:= = 3; 
   PRIO  ^*:= = 4; 
   PRIO  ^=:= = 5; 
   PRIO  <<:= = 6; 
   PRIO  <>:= = 7; 
   PRIO  </:= = 8; 
   PRIO  <*:= = 9; 
   PRIO  <=:= = 1; 
   PRIO  ><:= = 2; 
   PRIO  >>:= = 3; 
   PRIO  >/:= = 4; 
   PRIO  >*:= = 5; 
   PRIO  >=:= = 6; 
   PRIO  /<:= = 7; 
   PRIO  />:= = 8; 
   PRIO  //:= = 9; 
   PRIO  /*:= = 1; 
   PRIO  /=:= = 2; 
   PRIO  *<:= = 3; 
   PRIO  *>:= = 4; 
   PRIO  */:= = 5; 
   PRIO  **:= = 6; 
   PRIO  *=:= = 7; 
   PRIO =<:= = 8; 
   PRIO =>:= = 9; 
   PRIO =/:= = 1; 
   PRIO =*:= = 2; 
   PRIO ==:= = 3; 
   OP  &:= = (INT a, b) BOOL :pos(92); 
   OP  ?:= = (INT a, b) BOOL :pos(93); 
   OP  +:= = (INT a, b) BOOL :pos(94); 
   OP  -:= = (INT a, b) BOOL :pos(95); 
   OP  ^:= = (INT a, b) BOOL :pos(96); 
   OP  <:= = (INT a, b) BOOL :pos(97); 
   OP  >:= = (INT a, b) BOOL :pos(98); 
   OP  /:= = (INT a, b) BOOL :pos(99); 
   OP  *:= = (INT a, b) BOOL :pos(100); 
   OP =:= = (INT a, b) BOOL :pos(101); 
   OP  &<:= = (INT a, b) BOOL :pos(102); 
   OP  &>:= = (INT a, b) BOOL :pos(103); 
   OP  &/:= = (INT a, b) BOOL :pos(104); 
   OP  &*:= = (INT a, b) BOOL :pos(105); 
   OP  &=:= = (INT a, b) BOOL :pos(106); 
   OP  ?<:= = (INT a, b) BOOL :pos(107); 
   OP  ?>:= = (INT a, b) BOOL :pos(108); 
   OP  ?/:= = (INT a, b) BOOL :pos(109); 
   OP  ?*:= = (INT a, b) BOOL :pos(110); 
   OP  ?=:= = (INT a, b) BOOL :pos(111); 
   OP  +<:= = (INT a, b) BOOL :pos(112); 
   OP  +>:= = (INT a, b) BOOL :pos(113); 
   OP  +/:= = (INT a, b) BOOL :pos(114); 
   OP  +*:= = (INT a, b) BOOL :pos(115); 
   OP  +=:= = (INT a, b) BOOL :pos(116); 
   OP  -<:= = (INT a, b) BOOL :pos(117); 
   OP  ->:= = (INT a, b) BOOL :pos(118); 
   OP  -/:= = (INT a, b) BOOL :pos(119); 
   OP  -*:= = (INT a, b) BOOL :pos(120); 
   OP  -=:= = (INT a, b) BOOL :pos(121); 
   OP  ^<:= = (INT a, b) BOOL :pos(122); 
   OP  ^>:= = (INT a, b) BOOL :pos(123); 
   OP  ^/:= = (INT a, b) BOOL :pos(124); 
   OP  ^*:= = (INT a, b) BOOL :pos(125); 
   OP  ^=:= = (INT a, b) BOOL :pos(126); 
   OP  <<:= = (INT a, b) BOOL :pos(127); 
   OP  <>:= = (INT a, b) BOOL :pos(128); 
   OP  </:= = (INT a, b) BOOL :pos(129); 
   OP  <*:= = (INT a, b) BOOL :pos(130); 
   OP  <=:= = (INT a, b) BOOL :pos(131); 
   OP  ><:= = (INT a, b) BOOL :pos(132); 
   OP  >>:= = (INT a, b) BOOL :pos(133); 
   OP  >/:= = (INT a, b) BOOL :pos(134); 
   OP  >*:= = (INT a, b) BOOL :pos(135); 
   OP  >=:= = (INT a, b) BOOL :pos(136); 
   OP  /<:= = (INT a, b) BOOL :pos(137); 
   OP  />:= = (INT a, b) BOOL :pos(138); 
   OP  //:= = (INT a, b) BOOL :pos(139); 
   OP  /*:= = (INT a, b) BOOL :pos(140); 
   OP  /=:= = (INT a, b) BOOL :pos(141); 
   OP  *<:= = (INT a, b) BOOL :pos(142); 
   OP  *>:= = (INT a, b) BOOL :pos(143); 
   OP  */:= = (INT a, b) BOOL :pos(144); 
   OP  **:= = (INT a, b) BOOL :pos(145); 
   OP  *=:= = (INT a, b) BOOL :pos(146); 
   OP =<:= = (INT a, b) BOOL :pos(147); 
   OP =>:= = (INT a, b) BOOL :pos(148); 
   OP =/:= = (INT a, b) BOOL :pos(149); 
   OP =*:= = (INT a, b) BOOL :pos(150); 
   OP ==:= = (INT a, b) BOOL :pos(151); 
  3&:= 7; 
  2?:= 8; 
  3+:= 6; 
  1-:= 4; 
  5^:= 5; 
  9<:= 5; 
  6>:= 6; 
  1/:= 3; 
  9*:= 2; 
  5=:= 9; 
  2&<:= 8; 
  9&>:= 7; 
  3&/:= 9; 
  4&*:= 1; 
  8&=:= 5; 
  8?<:= 3; 
  5?>:= 6; 
  6?/:= 1; 
  5?*:= 4; 
  6?=:= 6; 
  5+<:= 7; 
  2+>:= 2; 
  3+/:= 6; 
  3+*:= 8; 
  3+=:= 3; 
  7-<:= 6; 
  4->:= 4; 
  5-/:= 9; 
  1-*:= 5; 
  2-=:= 2; 
  9^<:= 3; 
  9^>:= 3; 
  2^/:= 3; 
  1^*:= 9; 
  3^=:= 7; 
  2<<:= 7; 
  2<>:= 2; 
  7</:= 9; 
  1<*:= 9; 
  2<=:= 8; 
  8><:= 5; 
  8>>:= 7; 
  3>/:= 2; 
  5>*:= 2; 
  4>=:= 3; 
  5/<:= 3; 
  9/>:= 9; 
  4//:= 2; 
  1/*:= 1; 
  3/=:= 7; 
  3*<:= 1; 
  9*>:= 9; 
  8*/:= 3; 
  5**:= 9; 
  4*=:= 5; 
  1=<:= 4; 
  7=>:= 9; 
  6=/:= 7; 
  3=*:= 9; 
  1==:= 3; SKIP); (
   PRIO  &=: = 4; 
   PRIO  ?=: = 5; 
   PRIO  +=: = 6; 
   PRIO  -=: = 7; 
   PRIO  ^=: = 8; 
   PRIO  <=: = 9; 
   PRIO  >=: = 1; 
   PRIO  /=: = 2; 
   PRIO  *=: = 3; 
   PRIO ==: = 4; 
   PRIO  &<=: = 5; 
   PRIO  &>=: = 6; 
   PRIO  &/=: = 7; 
   PRIO  &*=: = 8; 
   PRIO  &==: = 9; 
   PRIO  ?<=: = 1; 
   PRIO  ?>=: = 2; 
   PRIO  ?/=: = 3; 
   PRIO  ?*=: = 4; 
   PRIO  ?==: = 5; 
   PRIO  +<=: = 6; 
   PRIO  +>=: = 7; 
   PRIO  +/=: = 8; 
   PRIO  +*=: = 9; 
   PRIO  +==: = 1; 
   PRIO  -<=: = 2; 
   PRIO  ->=: = 3; 
   PRIO  -/=: = 4; 
   PRIO  -*=: = 5; 
   PRIO  -==: = 6; 
   PRIO  ^<=: = 7; 
   PRIO  ^>=: = 8; 
   PRIO  ^/=: = 9; 
   PRIO  ^*=: = 1; 
   PRIO  ^==: = 2; 
   PRIO  <<=: = 3; 
   PRIO  <>=: = 4; 
   PRIO  </=: = 5; 
   PRIO  <*=: = 6; 
   PRIO  <==: = 7; 
   PRIO  ><=: = 8; 
   PRIO  >>=: = 9; 
   PRIO  >/=: = 1; 
   PRIO  >*=: = 2; 
   PRIO  >==: = 3; 
   PRIO  /<=: = 4; 
   PRIO  />=: = 5; 
   PRIO  //=: = 6; 
   PRIO  /*=: = 7; 
   PRIO  /==: = 8; 
   PRIO  *<=: = 9; 
   PRIO  *>=: = 1; 
   PRIO  */=: = 2; 
   PRIO  **=: = 3; 
   PRIO  *==: = 4; 
   PRIO =<=: = 5; 
   PRIO =>=: = 6; 
   PRIO =/=: = 7; 
   PRIO =*=: = 8; 
   PRIO ===: = 9; 
   OP  &=: = (INT a, b) BOOL :pos(152); 
   OP  ?=: = (INT a, b) BOOL :pos(153); 
   OP  +=: = (INT a, b) BOOL :pos(154); 
   OP  -=: = (INT a, b) BOOL :pos(155); 
   OP  ^=: = (INT a, b) BOOL :pos(156); 
   OP  <=: = (INT a, b) BOOL :pos(157); 
   OP  >=: = (INT a, b) BOOL :pos(158); 
   OP  /=: = (INT a, b) BOOL :pos(159); 
   OP  *=: = (INT a, b) BOOL :pos(160); 
   OP ==: = (INT a, b) BOOL :pos(161); 
   OP  &<=: = (INT a, b) BOOL :pos(162); 
   OP  &>=: = (INT a, b) BOOL :pos(163); 
   OP  &/=: = (INT a, b) BOOL :pos(164); 
   OP  &*=: = (INT a, b) BOOL :pos(165); 
   OP  &==: = (INT a, b) BOOL :pos(166); 
   OP  ?<=: = (INT a, b) BOOL :pos(167); 
   OP  ?>=: = (INT a, b) BOOL :pos(168); 
   OP  ?/=: = (INT a, b) BOOL :pos(169); 
   OP  ?*=: = (INT a, b) BOOL :pos(170); 
   OP  ?==: = (INT a, b) BOOL :pos(171); 
   OP  +<=: = (INT a, b) BOOL :pos(172); 
   OP  +>=: = (INT a, b) BOOL :pos(173); 
   OP  +/=: = (INT a, b) BOOL :pos(174); 
   OP  +*=: = (INT a, b) BOOL :pos(175); 
   OP  +==: = (INT a, b) BOOL :pos(176); 
   OP  -<=: = (INT a, b) BOOL :pos(177); 
   OP  ->=: = (INT a, b) BOOL :pos(178); 
   OP  -/=: = (INT a, b) BOOL :pos(179); 
   OP  -*=: = (INT a, b) BOOL :pos(180); 
   OP  -==: = (INT a, b) BOOL :pos(181); 
   OP  ^<=: = (INT a, b) BOOL :pos(182); 
   OP  ^>=: = (INT a, b) BOOL :pos(183); 
   OP  ^/=: = (INT a, b) BOOL :pos(184); 
   OP  ^*=: = (INT a, b) BOOL :pos(185); 
   OP  ^==: = (INT a, b) BOOL :pos(186); 
   OP  <<=: = (INT a, b) BOOL :pos(187); 
   OP  <>=: = (INT a, b) BOOL :pos(188); 
   OP  </=: = (INT a, b) BOOL :pos(189); 
   OP  <*=: = (INT a, b) BOOL :pos(190); 
   OP  <==: = (INT a, b) BOOL :pos(191); 
   OP  ><=: = (INT a, b) BOOL :pos(192); 
   OP  >>=: = (INT a, b) BOOL :pos(193); 
   OP  >/=: = (INT a, b) BOOL :pos(194); 
   OP  >*=: = (INT a, b) BOOL :pos(195); 
   OP  >==: = (INT a, b) BOOL :pos(196); 
   OP  /<=: = (INT a, b) BOOL :pos(197); 
   OP  />=: = (INT a, b) BOOL :pos(198); 
   OP  //=: = (INT a, b) BOOL :pos(199); 
   OP  /*=: = (INT a, b) BOOL :pos(200); 
   OP  /==: = (INT a, b) BOOL :pos(201); 
   OP  *<=: = (INT a, b) BOOL :pos(202); 
   OP  *>=: = (INT a, b) BOOL :pos(203); 
   OP  */=: = (INT a, b) BOOL :pos(204); 
   OP  **=: = (INT a, b) BOOL :pos(205); 
   OP  *==: = (INT a, b) BOOL :pos(206); 
   OP =<=: = (INT a, b) BOOL :pos(207); 
   OP =>=: = (INT a, b) BOOL :pos(208); 
   OP =/=: = (INT a, b) BOOL :pos(209); 
   OP =*=: = (INT a, b) BOOL :pos(210); 
   OP ===: = (INT a, b) BOOL :pos(211); 
  6&=:8; 
  6?=:7; 
  7+=:1; 
  2-=:8; 
  3^=:4; 
  6<=:2; 
  5>=:7; 
  4/=:6; 
  8*=:9; 
  4==:6; 
  5&<=:3; 
  7&>=:4; 
  9&/=:1; 
  1&*=:7; 
  9&==:8; 
  6?<=:6; 
  2?>=:1; 
  8?/=:6; 
  5?*=:1; 
  3?==:8; 
  2+<=:6; 
  1+>=:5; 
  3+/=:3; 
  4+*=:2; 
  8+==:6; 
  9-<=:3; 
  6->=:4; 
  1-/=:2; 
  4-*=:4; 
  5-==:4; 
  3^<=:6; 
  1^>=:3; 
  1^/=:4; 
  9^*=:2; 
  7^==:4; 
  4<<=:4; 
  6<>=:3; 
  7</=:8; 
  1<*=:3; 
  1<==:4; 
  2><=:3; 
  6>>=:8; 
  6>/=:8; 
  6>*=:6; 
  7>==:5; 
  4/<=:7; 
  4/>=:6; 
  1//=:6; 
  6/*=:8; 
  1/==:7; 
  2*<=:7; 
  9*>=:2; 
  6*/=:9; 
  4**=:3; 
  8*==:4; 
  8=<=:5; 
  9=>=:6; 
  6=/=:4; 
  1=*=:7; 
  8===:1; SKIP); (
   PRIO  & = 2; 
   PRIO  ? = 3; 
   PRIO  + = 4; 
   PRIO  - = 5; 
   PRIO  ^ = 6; 
   PRIO  < = 7; 
   PRIO  > = 8; 
   PRIO  / = 9; 
   PRIO  * = 1; 
   PRIO = = 2; 
   PRIO  &< = 3; 
   PRIO  &> = 4; 
   PRIO  &/ = 5; 
   PRIO  &* = 6; 
   PRIO  &= = 7; 
   PRIO  ?< = 8; 
   PRIO  ?> = 9; 
   PRIO  ?/ = 1; 
   PRIO  ?* = 2; 
   PRIO  ?= = 3; 
   PRIO  +< = 4; 
   PRIO  +> = 5; 
   PRIO  +/ = 6; 
   PRIO  +* = 7; 
   PRIO  += = 8; 
   PRIO  -< = 9; 
   PRIO  -> = 1; 
   PRIO  -/ = 2; 
   PRIO  -* = 3; 
   PRIO  -= = 4; 
   PRIO  ^< = 5; 
   PRIO  ^> = 6; 
   PRIO  ^/ = 7; 
   PRIO  ^* = 8; 
   PRIO  ^= = 9; 
   PRIO  << = 1; 
   PRIO  <> = 2; 
   PRIO  </ = 3; 
   PRIO  <* = 4; 
   PRIO  <= = 5; 
   PRIO  >< = 6; 
   PRIO  >> = 7; 
   PRIO  >/ = 8; 
   PRIO  >* = 9; 
   PRIO  >= = 1; 
   PRIO  /< = 2; 
   PRIO  /> = 3; 
   PRIO  // = 4; 
   PRIO  /* = 5; 
   PRIO  /= = 6; 
   PRIO  *< = 7; 
   PRIO  *> = 8; 
   PRIO  */ = 9; 
   PRIO  ** = 1; 
   PRIO  *= = 2; 
   PRIO =< = 3; 
   PRIO => = 4; 
   PRIO =/ = 5; 
   PRIO =* = 6; 
   PRIO == = 7; 
   OP  & = (INT a, b) BOOL :pos(212); 
   OP  ? = (INT a, b) BOOL :pos(213); 
   OP  + = (INT a, b) BOOL :pos(214); 
   OP  - = (INT a, b) BOOL :pos(215); 
   OP  ^ = (INT a, b) BOOL :pos(216); 
   OP  < = (INT a, b) BOOL :pos(217); 
   OP  > = (INT a, b) BOOL :pos(218); 
   OP  / = (INT a, b) BOOL :pos(219); 
   OP  * = (INT a, b) BOOL :pos(220); 
   OP = = (INT a, b) BOOL :pos(221); 
   OP  &< = (INT a, b) BOOL :pos(222); 
   OP  &> = (INT a, b) BOOL :pos(223); 
   OP  &/ = (INT a, b) BOOL :pos(224); 
   OP  &* = (INT a, b) BOOL :pos(225); 
   OP  &= = (INT a, b) BOOL :pos(226); 
   OP  ?< = (INT a, b) BOOL :pos(227); 
   OP  ?> = (INT a, b) BOOL :pos(228); 
   OP  ?/ = (INT a, b) BOOL :pos(229); 
   OP  ?* = (INT a, b) BOOL :pos(230); 
   OP  ?= = (INT a, b) BOOL :pos(231); 
   OP  +< = (INT a, b) BOOL :pos(232); 
   OP  +> = (INT a, b) BOOL :pos(233); 
   OP  +/ = (INT a, b) BOOL :pos(234); 
   OP  +* = (INT a, b) BOOL :pos(235); 
   OP  += = (INT a, b) BOOL :pos(236); 
   OP  -< = (INT a, b) BOOL :pos(237); 
   OP  -> = (INT a, b) BOOL :pos(238); 
   OP  -/ = (INT a, b) BOOL :pos(239); 
   OP  -* = (INT a, b) BOOL :pos(240); 
   OP  -= = (INT a, b) BOOL :pos(241); 
   OP  ^< = (INT a, b) BOOL :pos(242); 
   OP  ^> = (INT a, b) BOOL :pos(243); 
   OP  ^/ = (INT a, b) BOOL :pos(244); 
   OP  ^* = (INT a, b) BOOL :pos(245); 
   OP  ^= = (INT a, b) BOOL :pos(246); 
   OP  << = (INT a, b) BOOL :pos(247); 
   OP  <> = (INT a, b) BOOL :pos(248); 
   OP  </ = (INT a, b) BOOL :pos(249); 
   OP  <* = (INT a, b) BOOL :pos(250); 
   OP  <= = (INT a, b) BOOL :pos(251); 
   OP  >< = (INT a, b) BOOL :pos(252); 
   OP  >> = (INT a, b) BOOL :pos(253); 
   OP  >/ = (INT a, b) BOOL :pos(254); 
   OP  >* = (INT a, b) BOOL :pos(255); 
   OP  >= = (INT a, b) BOOL :pos(256); 
   OP  /< = (INT a, b) BOOL :pos(257); 
   OP  /> = (INT a, b) BOOL :pos(258); 
   OP  // = (INT a, b) BOOL :pos(259); 
   OP  /* = (INT a, b) BOOL :pos(260); 
   OP  /= = (INT a, b) BOOL :pos(261); 
   OP  *< = (INT a, b) BOOL :pos(262); 
   OP  *> = (INT a, b) BOOL :pos(263); 
   OP  */ = (INT a, b) BOOL :pos(264); 
   OP  ** = (INT a, b) BOOL :pos(265); 
   OP  *= = (INT a, b) BOOL :pos(266); 
   OP =< = (INT a, b) BOOL :pos(267); 
   OP => = (INT a, b) BOOL :pos(268); 
   OP =/ = (INT a, b) BOOL :pos(269); 
   OP =* = (INT a, b) BOOL :pos(270); 
   OP == = (INT a, b) BOOL :pos(271); 
  3&8; 
  9?5; 
  9+9; 
  4-1; 
  3^1; 
  6<8; 
  3>8; 
  2/4; 
  5*3; 
  5= 2; 
  7&<3; 
  3&>4; 
  9&/4; 
  9&*1; 
  8&= 3; 
  8?<8; 
  6?>1; 
  2?/2; 
  8?*7; 
  4?= 1; 
  8+<2; 
  2+>5; 
  2+/3; 
  3+*8; 
  1+= 8; 
  6-<8; 
  5->7; 
  9-/6; 
  3-*8; 
  6-= 2; 
  9^<7; 
  6^>3; 
  5^/9; 
  8^*4; 
  2^= 4; 
  2<<8; 
  6<>1; 
  8</6; 
  7<*9; 
  2<= 9; 
  2><4; 
  8>>6; 
  7>/5; 
  6>*2; 
  2>= 8; 
  1/<7; 
  9/>5; 
  2//7; 
  1/*3; 
  6/= 6; 
  5*<1; 
  9*>3; 
  9*/7; 
  9**5; 
  2*= 7; 
  6=<7; 
  2=>7; 
  3=/1; 
  8=*4; 
  5== 6; 
   SKIP); 
  
  FOR i TO nbt 
  DO (tc[i] | print(("err.2", i))) 
  OD; 
  
  pretty ((to test +:= ctr; ctr));
  writef (($" tests "b("ok", "error")l$, ctr = (tests ok +:= nbt; nbt))); 
  );
  
  total to +:= tests ok;
  total ok +:= to test;
  write ("Tests ok: ");
  pretty (total ok);
  write (" out of ");
  pretty (total to);
  write (newline);
  sweep heap;
  write ("Garbage collector: ");
  pretty (collections);
  write (" sweep, ");
  pretty (garbage);
  write (" bytes");
  newline (standout)
END
